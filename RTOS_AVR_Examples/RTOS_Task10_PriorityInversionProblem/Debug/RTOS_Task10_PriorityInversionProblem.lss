
RTOS_Task10_PriorityInversionProblem.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000028ba  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000020  00800060  000028ba  0000294e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002f9  00800080  00800080  0000296e  2**0
                  ALLOC
  3 .stab         000046b0  00000000  00000000  00002970  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002b7f  00000000  00000000  00007020  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 cd 08 	jmp	0x119a	; 0x119a <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea eb       	ldi	r30, 0xBA	; 186
      68:	f8 e2       	ldi	r31, 0x28	; 40
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a0 38       	cpi	r26, 0x80	; 128
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a0 e8       	ldi	r26, 0x80	; 128
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a9 37       	cpi	r26, 0x79	; 121
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 49 00 	call	0x92	; 0x92 <main>
      8a:	0c 94 5b 14 	jmp	0x28b6	; 0x28b6 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <main>:
      92:	af 92       	push	r10
      94:	bf 92       	push	r11
      96:	cf 92       	push	r12
      98:	df 92       	push	r13
      9a:	ef 92       	push	r14
      9c:	ff 92       	push	r15
      9e:	0f 93       	push	r16
      a0:	df 93       	push	r29
      a2:	cf 93       	push	r28
      a4:	00 d0       	rcall	.+0      	; 0xa6 <main+0x14>
      a6:	00 d0       	rcall	.+0      	; 0xa8 <main+0x16>
      a8:	00 d0       	rcall	.+0      	; 0xaa <main+0x18>
      aa:	cd b7       	in	r28, 0x3d	; 61
      ac:	de b7       	in	r29, 0x3e	; 62
      ae:	1a 82       	std	Y+2, r1	; 0x02
      b0:	19 82       	std	Y+1, r1	; 0x01
      b2:	20 e6       	ldi	r18, 0x60	; 96
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	87 ed       	ldi	r24, 0xD7	; 215
      b8:	90 e0       	ldi	r25, 0x00	; 0
      ba:	b9 01       	movw	r22, r18
      bc:	45 e5       	ldi	r20, 0x55	; 85
      be:	50 e0       	ldi	r21, 0x00	; 0
      c0:	20 e0       	ldi	r18, 0x00	; 0
      c2:	30 e0       	ldi	r19, 0x00	; 0
      c4:	03 e0       	ldi	r16, 0x03	; 3
      c6:	fe 01       	movw	r30, r28
      c8:	31 96       	adiw	r30, 0x01	; 1
      ca:	7f 01       	movw	r14, r30
      cc:	cc 24       	eor	r12, r12
      ce:	dd 24       	eor	r13, r13
      d0:	aa 24       	eor	r10, r10
      d2:	bb 24       	eor	r11, r11
      d4:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <xTaskGenericCreate>
      d8:	1c 82       	std	Y+4, r1	; 0x04
      da:	1b 82       	std	Y+3, r1	; 0x03
      dc:	26 e6       	ldi	r18, 0x66	; 102
      de:	30 e0       	ldi	r19, 0x00	; 0
      e0:	8d e1       	ldi	r24, 0x1D	; 29
      e2:	91 e0       	ldi	r25, 0x01	; 1
      e4:	fe 01       	movw	r30, r28
      e6:	33 96       	adiw	r30, 0x03	; 3
      e8:	b9 01       	movw	r22, r18
      ea:	45 e5       	ldi	r20, 0x55	; 85
      ec:	50 e0       	ldi	r21, 0x00	; 0
      ee:	20 e0       	ldi	r18, 0x00	; 0
      f0:	30 e0       	ldi	r19, 0x00	; 0
      f2:	02 e0       	ldi	r16, 0x02	; 2
      f4:	7f 01       	movw	r14, r30
      f6:	cc 24       	eor	r12, r12
      f8:	dd 24       	eor	r13, r13
      fa:	aa 24       	eor	r10, r10
      fc:	bb 24       	eor	r11, r11
      fe:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <xTaskGenericCreate>
     102:	1e 82       	std	Y+6, r1	; 0x06
     104:	1d 82       	std	Y+5, r1	; 0x05
     106:	24 e7       	ldi	r18, 0x74	; 116
     108:	30 e0       	ldi	r19, 0x00	; 0
     10a:	8a e5       	ldi	r24, 0x5A	; 90
     10c:	91 e0       	ldi	r25, 0x01	; 1
     10e:	fe 01       	movw	r30, r28
     110:	35 96       	adiw	r30, 0x05	; 5
     112:	b9 01       	movw	r22, r18
     114:	45 e5       	ldi	r20, 0x55	; 85
     116:	50 e0       	ldi	r21, 0x00	; 0
     118:	20 e0       	ldi	r18, 0x00	; 0
     11a:	30 e0       	ldi	r19, 0x00	; 0
     11c:	01 e0       	ldi	r16, 0x01	; 1
     11e:	7f 01       	movw	r14, r30
     120:	cc 24       	eor	r12, r12
     122:	dd 24       	eor	r13, r13
     124:	aa 24       	eor	r10, r10
     126:	bb 24       	eor	r11, r11
     128:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <xTaskGenericCreate>
     12c:	0e 94 c5 00 	call	0x18a	; 0x18a <init>
     130:	81 e0       	ldi	r24, 0x01	; 1
     132:	60 e0       	ldi	r22, 0x00	; 0
     134:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <xQueueCreate>
     138:	90 93 81 00 	sts	0x0081, r25
     13c:	80 93 80 00 	sts	0x0080, r24
     140:	80 91 80 00 	lds	r24, 0x0080
     144:	90 91 81 00 	lds	r25, 0x0081
     148:	00 97       	sbiw	r24, 0x00	; 0
     14a:	59 f0       	breq	.+22     	; 0x162 <main+0xd0>
     14c:	80 91 80 00 	lds	r24, 0x0080
     150:	90 91 81 00 	lds	r25, 0x0081
     154:	60 e0       	ldi	r22, 0x00	; 0
     156:	70 e0       	ldi	r23, 0x00	; 0
     158:	40 e0       	ldi	r20, 0x00	; 0
     15a:	50 e0       	ldi	r21, 0x00	; 0
     15c:	20 e0       	ldi	r18, 0x00	; 0
     15e:	0e 94 79 09 	call	0x12f2	; 0x12f2 <xQueueGenericSend>
     162:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vTaskStartScheduler>
     166:	80 e0       	ldi	r24, 0x00	; 0
     168:	90 e0       	ldi	r25, 0x00	; 0
     16a:	26 96       	adiw	r28, 0x06	; 6
     16c:	0f b6       	in	r0, 0x3f	; 63
     16e:	f8 94       	cli
     170:	de bf       	out	0x3e, r29	; 62
     172:	0f be       	out	0x3f, r0	; 63
     174:	cd bf       	out	0x3d, r28	; 61
     176:	cf 91       	pop	r28
     178:	df 91       	pop	r29
     17a:	0f 91       	pop	r16
     17c:	ff 90       	pop	r15
     17e:	ef 90       	pop	r14
     180:	df 90       	pop	r13
     182:	cf 90       	pop	r12
     184:	bf 90       	pop	r11
     186:	af 90       	pop	r10
     188:	08 95       	ret

0000018a <init>:

	/*Never Enter Here */
	return 0;
}

void init(void){
     18a:	df 93       	push	r29
     18c:	cf 93       	push	r28
     18e:	cd b7       	in	r28, 0x3d	; 61
     190:	de b7       	in	r29, 0x3e	; 62

	DDRB = 0xFF;
     192:	e7 e3       	ldi	r30, 0x37	; 55
     194:	f0 e0       	ldi	r31, 0x00	; 0
     196:	8f ef       	ldi	r24, 0xFF	; 255
     198:	80 83       	st	Z, r24

	DDRC = 0x00;
     19a:	e4 e3       	ldi	r30, 0x34	; 52
     19c:	f0 e0       	ldi	r31, 0x00	; 0
     19e:	10 82       	st	Z, r1

	PORTC = 0xFF;
     1a0:	e5 e3       	ldi	r30, 0x35	; 53
     1a2:	f0 e0       	ldi	r31, 0x00	; 0
     1a4:	8f ef       	ldi	r24, 0xFF	; 255
     1a6:	80 83       	st	Z, r24

}
     1a8:	cf 91       	pop	r28
     1aa:	df 91       	pop	r29
     1ac:	08 95       	ret

000001ae <Led2>:
 void Led2(void * pvparam){
     1ae:	df 93       	push	r29
     1b0:	cf 93       	push	r28
     1b2:	00 d0       	rcall	.+0      	; 0x1b4 <Led2+0x6>
     1b4:	00 d0       	rcall	.+0      	; 0x1b6 <Led2+0x8>
     1b6:	00 d0       	rcall	.+0      	; 0x1b8 <Led2+0xa>
     1b8:	cd b7       	in	r28, 0x3d	; 61
     1ba:	de b7       	in	r29, 0x3e	; 62
     1bc:	9e 83       	std	Y+6, r25	; 0x06
     1be:	8d 83       	std	Y+5, r24	; 0x05

	 portTickType Freq = 1000;
     1c0:	88 ee       	ldi	r24, 0xE8	; 232
     1c2:	93 e0       	ldi	r25, 0x03	; 3
     1c4:	9a 83       	std	Y+2, r25	; 0x02
     1c6:	89 83       	std	Y+1, r24	; 0x01
	 portTickType Start = xTaskGetTickCount();
     1c8:	0e 94 23 10 	call	0x2046	; 0x2046 <xTaskGetTickCount>
     1cc:	9c 83       	std	Y+4, r25	; 0x04
     1ce:	8b 83       	std	Y+3, r24	; 0x03
	 vTaskDelay(20);
     1d0:	84 e1       	ldi	r24, 0x14	; 20
     1d2:	90 e0       	ldi	r25, 0x00	; 0
     1d4:	0e 94 15 0f 	call	0x1e2a	; 0x1e2a <vTaskDelay>
     1d8:	0c c0       	rjmp	.+24     	; 0x1f2 <Led2+0x44>
	 while (1){

			 /* If the Resource No One is Using so Take the Semaphore  **/
			 while(pdFALSE == xSemaphoreTake(ButtonSemaphore,100)){
				 vTaskDelay(100);
     1da:	84 e6       	ldi	r24, 0x64	; 100
     1dc:	90 e0       	ldi	r25, 0x00	; 0
     1de:	0e 94 15 0f 	call	0x1e2a	; 0x1e2a <vTaskDelay>
				 PORTB ^= 0x02;
     1e2:	a8 e3       	ldi	r26, 0x38	; 56
     1e4:	b0 e0       	ldi	r27, 0x00	; 0
     1e6:	e8 e3       	ldi	r30, 0x38	; 56
     1e8:	f0 e0       	ldi	r31, 0x00	; 0
     1ea:	90 81       	ld	r25, Z
     1ec:	82 e0       	ldi	r24, 0x02	; 2
     1ee:	89 27       	eor	r24, r25
     1f0:	8c 93       	st	X, r24
	 portTickType Start = xTaskGetTickCount();
	 vTaskDelay(20);
	 while (1){

			 /* If the Resource No One is Using so Take the Semaphore  **/
			 while(pdFALSE == xSemaphoreTake(ButtonSemaphore,100)){
     1f2:	80 91 80 00 	lds	r24, 0x0080
     1f6:	90 91 81 00 	lds	r25, 0x0081
     1fa:	60 e0       	ldi	r22, 0x00	; 0
     1fc:	70 e0       	ldi	r23, 0x00	; 0
     1fe:	44 e6       	ldi	r20, 0x64	; 100
     200:	50 e0       	ldi	r21, 0x00	; 0
     202:	20 e0       	ldi	r18, 0x00	; 0
     204:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <xQueueGenericReceive>
     208:	88 23       	and	r24, r24
     20a:	39 f3       	breq	.-50     	; 0x1da <Led2+0x2c>
				 vTaskDelay(100);
				 PORTB ^= 0x02;
			 }

			 vTaskDelay(10000);
     20c:	80 e1       	ldi	r24, 0x10	; 16
     20e:	97 e2       	ldi	r25, 0x27	; 39
     210:	0e 94 15 0f 	call	0x1e2a	; 0x1e2a <vTaskDelay>

			 xSemaphoreGive(ButtonSemaphore);
     214:	80 91 80 00 	lds	r24, 0x0080
     218:	90 91 81 00 	lds	r25, 0x0081
     21c:	60 e0       	ldi	r22, 0x00	; 0
     21e:	70 e0       	ldi	r23, 0x00	; 0
     220:	40 e0       	ldi	r20, 0x00	; 0
     222:	50 e0       	ldi	r21, 0x00	; 0
     224:	20 e0       	ldi	r18, 0x00	; 0
     226:	0e 94 79 09 	call	0x12f2	; 0x12f2 <xQueueGenericSend>

		 /*Make the Task Periodic with Period 50 Tick */
		 vTaskDelayUntil(&Start,Freq);
     22a:	ce 01       	movw	r24, r28
     22c:	03 96       	adiw	r24, 0x03	; 3
     22e:	29 81       	ldd	r18, Y+1	; 0x01
     230:	3a 81       	ldd	r19, Y+2	; 0x02
     232:	b9 01       	movw	r22, r18
     234:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <vTaskDelayUntil>
     238:	dc cf       	rjmp	.-72     	; 0x1f2 <Led2+0x44>

0000023a <PushButton2>:
	 }

 }


 void PushButton2(void * pvparam){
     23a:	df 93       	push	r29
     23c:	cf 93       	push	r28
     23e:	00 d0       	rcall	.+0      	; 0x240 <PushButton2+0x6>
     240:	00 d0       	rcall	.+0      	; 0x242 <PushButton2+0x8>
     242:	00 d0       	rcall	.+0      	; 0x244 <PushButton2+0xa>
     244:	cd b7       	in	r28, 0x3d	; 61
     246:	de b7       	in	r29, 0x3e	; 62
     248:	9e 83       	std	Y+6, r25	; 0x06
     24a:	8d 83       	std	Y+5, r24	; 0x05
	 portTickType Freq = 100;
     24c:	84 e6       	ldi	r24, 0x64	; 100
     24e:	90 e0       	ldi	r25, 0x00	; 0
     250:	9a 83       	std	Y+2, r25	; 0x02
     252:	89 83       	std	Y+1, r24	; 0x01
	 portTickType Start = xTaskGetTickCount();
     254:	0e 94 23 10 	call	0x2046	; 0x2046 <xTaskGetTickCount>
     258:	9c 83       	std	Y+4, r25	; 0x04
     25a:	8b 83       	std	Y+3, r24	; 0x03
	 while (1){

				 while(pdFALSE == xSemaphoreTake(ButtonSemaphore,100));
     25c:	80 91 80 00 	lds	r24, 0x0080
     260:	90 91 81 00 	lds	r25, 0x0081
     264:	60 e0       	ldi	r22, 0x00	; 0
     266:	70 e0       	ldi	r23, 0x00	; 0
     268:	44 e6       	ldi	r20, 0x64	; 100
     26a:	50 e0       	ldi	r21, 0x00	; 0
     26c:	20 e0       	ldi	r18, 0x00	; 0
     26e:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <xQueueGenericReceive>
     272:	88 23       	and	r24, r24
     274:	99 f3       	breq	.-26     	; 0x25c <PushButton2+0x22>

				 /*Change the State **/
				 PORTB ^= 0x04;
     276:	a8 e3       	ldi	r26, 0x38	; 56
     278:	b0 e0       	ldi	r27, 0x00	; 0
     27a:	e8 e3       	ldi	r30, 0x38	; 56
     27c:	f0 e0       	ldi	r31, 0x00	; 0
     27e:	90 81       	ld	r25, Z
     280:	84 e0       	ldi	r24, 0x04	; 4
     282:	89 27       	eor	r24, r25
     284:	8c 93       	st	X, r24

				 vTaskDelay(1000);
     286:	88 ee       	ldi	r24, 0xE8	; 232
     288:	93 e0       	ldi	r25, 0x03	; 3
     28a:	0e 94 15 0f 	call	0x1e2a	; 0x1e2a <vTaskDelay>

				 /**Give the Semaphore */

				 xSemaphoreGive(ButtonSemaphore);
     28e:	80 91 80 00 	lds	r24, 0x0080
     292:	90 91 81 00 	lds	r25, 0x0081
     296:	60 e0       	ldi	r22, 0x00	; 0
     298:	70 e0       	ldi	r23, 0x00	; 0
     29a:	40 e0       	ldi	r20, 0x00	; 0
     29c:	50 e0       	ldi	r21, 0x00	; 0
     29e:	20 e0       	ldi	r18, 0x00	; 0
     2a0:	0e 94 79 09 	call	0x12f2	; 0x12f2 <xQueueGenericSend>

		 /*Make the Task Periodic with Period 50 Tick */
		 vTaskDelayUntil(&Start,Freq);
     2a4:	ce 01       	movw	r24, r28
     2a6:	03 96       	adiw	r24, 0x03	; 3
     2a8:	29 81       	ldd	r18, Y+1	; 0x01
     2aa:	3a 81       	ldd	r19, Y+2	; 0x02
     2ac:	b9 01       	movw	r22, r18
     2ae:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <vTaskDelayUntil>
     2b2:	d4 cf       	rjmp	.-88     	; 0x25c <PushButton2+0x22>

000002b4 <Led>:

 }



 void Led(void * pvparam){
     2b4:	df 93       	push	r29
     2b6:	cf 93       	push	r28
     2b8:	00 d0       	rcall	.+0      	; 0x2ba <Led+0x6>
     2ba:	00 d0       	rcall	.+0      	; 0x2bc <Led+0x8>
     2bc:	00 d0       	rcall	.+0      	; 0x2be <Led+0xa>
     2be:	cd b7       	in	r28, 0x3d	; 61
     2c0:	de b7       	in	r29, 0x3e	; 62
     2c2:	9e 83       	std	Y+6, r25	; 0x06
     2c4:	8d 83       	std	Y+5, r24	; 0x05
	 portTickType Freq = 100;
     2c6:	84 e6       	ldi	r24, 0x64	; 100
     2c8:	90 e0       	ldi	r25, 0x00	; 0
     2ca:	9a 83       	std	Y+2, r25	; 0x02
     2cc:	89 83       	std	Y+1, r24	; 0x01
	 portTickType Start = xTaskGetTickCount();
     2ce:	0e 94 23 10 	call	0x2046	; 0x2046 <xTaskGetTickCount>
     2d2:	9c 83       	std	Y+4, r25	; 0x04
     2d4:	8b 83       	std	Y+3, r24	; 0x03
	 vTaskDelay(30);
     2d6:	8e e1       	ldi	r24, 0x1E	; 30
     2d8:	90 e0       	ldi	r25, 0x00	; 0
     2da:	0e 94 15 0f 	call	0x1e2a	; 0x1e2a <vTaskDelay>
	 while (1){

		 PORTB ^= 0x01;
     2de:	a8 e3       	ldi	r26, 0x38	; 56
     2e0:	b0 e0       	ldi	r27, 0x00	; 0
     2e2:	e8 e3       	ldi	r30, 0x38	; 56
     2e4:	f0 e0       	ldi	r31, 0x00	; 0
     2e6:	90 81       	ld	r25, Z
     2e8:	81 e0       	ldi	r24, 0x01	; 1
     2ea:	89 27       	eor	r24, r25
     2ec:	8c 93       	st	X, r24

		 /*Make the Task Periodic with Period 50 Tick */
		 vTaskDelayUntil(&Start,Freq);
     2ee:	ce 01       	movw	r24, r28
     2f0:	03 96       	adiw	r24, 0x03	; 3
     2f2:	29 81       	ldd	r18, Y+1	; 0x01
     2f4:	3a 81       	ldd	r19, Y+2	; 0x02
     2f6:	b9 01       	movw	r22, r18
     2f8:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <vTaskDelayUntil>
     2fc:	f0 cf       	rjmp	.-32     	; 0x2de <Led+0x2a>

000002fe <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     2fe:	df 93       	push	r29
     300:	cf 93       	push	r28
     302:	cd b7       	in	r28, 0x3d	; 61
     304:	de b7       	in	r29, 0x3e	; 62
     306:	27 97       	sbiw	r28, 0x07	; 7
     308:	0f b6       	in	r0, 0x3f	; 63
     30a:	f8 94       	cli
     30c:	de bf       	out	0x3e, r29	; 62
     30e:	0f be       	out	0x3f, r0	; 63
     310:	cd bf       	out	0x3d, r28	; 61
     312:	9d 83       	std	Y+5, r25	; 0x05
     314:	8c 83       	std	Y+4, r24	; 0x04
     316:	6e 83       	std	Y+6, r22	; 0x06
     318:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     31a:	8a e1       	ldi	r24, 0x1A	; 26
     31c:	90 e0       	ldi	r25, 0x00	; 0
     31e:	0e 94 57 04 	call	0x8ae	; 0x8ae <pvPortMalloc>
     322:	9a 83       	std	Y+2, r25	; 0x02
     324:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     326:	89 81       	ldd	r24, Y+1	; 0x01
     328:	9a 81       	ldd	r25, Y+2	; 0x02
     32a:	00 97       	sbiw	r24, 0x00	; 0
     32c:	09 f4       	brne	.+2      	; 0x330 <xCoRoutineCreate+0x32>
     32e:	6f c0       	rjmp	.+222    	; 0x40e <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     330:	80 91 82 00 	lds	r24, 0x0082
     334:	90 91 83 00 	lds	r25, 0x0083
     338:	00 97       	sbiw	r24, 0x00	; 0
     33a:	41 f4       	brne	.+16     	; 0x34c <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     33c:	89 81       	ldd	r24, Y+1	; 0x01
     33e:	9a 81       	ldd	r25, Y+2	; 0x02
     340:	90 93 83 00 	sts	0x0083, r25
     344:	80 93 82 00 	sts	0x0082, r24
			prvInitialiseCoRoutineLists();
     348:	0e 94 e6 03 	call	0x7cc	; 0x7cc <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     34c:	8e 81       	ldd	r24, Y+6	; 0x06
     34e:	82 30       	cpi	r24, 0x02	; 2
     350:	10 f0       	brcs	.+4      	; 0x356 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     352:	81 e0       	ldi	r24, 0x01	; 1
     354:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     356:	e9 81       	ldd	r30, Y+1	; 0x01
     358:	fa 81       	ldd	r31, Y+2	; 0x02
     35a:	11 8e       	std	Z+25, r1	; 0x19
     35c:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     35e:	e9 81       	ldd	r30, Y+1	; 0x01
     360:	fa 81       	ldd	r31, Y+2	; 0x02
     362:	8e 81       	ldd	r24, Y+6	; 0x06
     364:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     366:	e9 81       	ldd	r30, Y+1	; 0x01
     368:	fa 81       	ldd	r31, Y+2	; 0x02
     36a:	8f 81       	ldd	r24, Y+7	; 0x07
     36c:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     36e:	e9 81       	ldd	r30, Y+1	; 0x01
     370:	fa 81       	ldd	r31, Y+2	; 0x02
     372:	8c 81       	ldd	r24, Y+4	; 0x04
     374:	9d 81       	ldd	r25, Y+5	; 0x05
     376:	91 83       	std	Z+1, r25	; 0x01
     378:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     37a:	89 81       	ldd	r24, Y+1	; 0x01
     37c:	9a 81       	ldd	r25, Y+2	; 0x02
     37e:	02 96       	adiw	r24, 0x02	; 2
     380:	0e 94 ed 04 	call	0x9da	; 0x9da <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     384:	89 81       	ldd	r24, Y+1	; 0x01
     386:	9a 81       	ldd	r25, Y+2	; 0x02
     388:	0c 96       	adiw	r24, 0x0c	; 12
     38a:	0e 94 ed 04 	call	0x9da	; 0x9da <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     38e:	e9 81       	ldd	r30, Y+1	; 0x01
     390:	fa 81       	ldd	r31, Y+2	; 0x02
     392:	89 81       	ldd	r24, Y+1	; 0x01
     394:	9a 81       	ldd	r25, Y+2	; 0x02
     396:	91 87       	std	Z+9, r25	; 0x09
     398:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     39a:	e9 81       	ldd	r30, Y+1	; 0x01
     39c:	fa 81       	ldd	r31, Y+2	; 0x02
     39e:	89 81       	ldd	r24, Y+1	; 0x01
     3a0:	9a 81       	ldd	r25, Y+2	; 0x02
     3a2:	93 8b       	std	Z+19, r25	; 0x13
     3a4:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     3a6:	8e 81       	ldd	r24, Y+6	; 0x06
     3a8:	28 2f       	mov	r18, r24
     3aa:	30 e0       	ldi	r19, 0x00	; 0
     3ac:	85 e0       	ldi	r24, 0x05	; 5
     3ae:	90 e0       	ldi	r25, 0x00	; 0
     3b0:	82 1b       	sub	r24, r18
     3b2:	93 0b       	sbc	r25, r19
     3b4:	e9 81       	ldd	r30, Y+1	; 0x01
     3b6:	fa 81       	ldd	r31, Y+2	; 0x02
     3b8:	95 87       	std	Z+13, r25	; 0x0d
     3ba:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     3bc:	e9 81       	ldd	r30, Y+1	; 0x01
     3be:	fa 81       	ldd	r31, Y+2	; 0x02
     3c0:	96 89       	ldd	r25, Z+22	; 0x16
     3c2:	80 91 84 00 	lds	r24, 0x0084
     3c6:	89 17       	cp	r24, r25
     3c8:	28 f4       	brcc	.+10     	; 0x3d4 <xCoRoutineCreate+0xd6>
     3ca:	e9 81       	ldd	r30, Y+1	; 0x01
     3cc:	fa 81       	ldd	r31, Y+2	; 0x02
     3ce:	86 89       	ldd	r24, Z+22	; 0x16
     3d0:	80 93 84 00 	sts	0x0084, r24
     3d4:	e9 81       	ldd	r30, Y+1	; 0x01
     3d6:	fa 81       	ldd	r31, Y+2	; 0x02
     3d8:	86 89       	ldd	r24, Z+22	; 0x16
     3da:	28 2f       	mov	r18, r24
     3dc:	30 e0       	ldi	r19, 0x00	; 0
     3de:	c9 01       	movw	r24, r18
     3e0:	88 0f       	add	r24, r24
     3e2:	99 1f       	adc	r25, r25
     3e4:	88 0f       	add	r24, r24
     3e6:	99 1f       	adc	r25, r25
     3e8:	88 0f       	add	r24, r24
     3ea:	99 1f       	adc	r25, r25
     3ec:	82 0f       	add	r24, r18
     3ee:	93 1f       	adc	r25, r19
     3f0:	ac 01       	movw	r20, r24
     3f2:	45 57       	subi	r20, 0x75	; 117
     3f4:	5f 4f       	sbci	r21, 0xFF	; 255
     3f6:	89 81       	ldd	r24, Y+1	; 0x01
     3f8:	9a 81       	ldd	r25, Y+2	; 0x02
     3fa:	9c 01       	movw	r18, r24
     3fc:	2e 5f       	subi	r18, 0xFE	; 254
     3fe:	3f 4f       	sbci	r19, 0xFF	; 255
     400:	ca 01       	movw	r24, r20
     402:	b9 01       	movw	r22, r18
     404:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInsertEnd>

		xReturn = pdPASS;
     408:	81 e0       	ldi	r24, 0x01	; 1
     40a:	8b 83       	std	Y+3, r24	; 0x03
     40c:	02 c0       	rjmp	.+4      	; 0x412 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     40e:	8f ef       	ldi	r24, 0xFF	; 255
     410:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     412:	8b 81       	ldd	r24, Y+3	; 0x03
}
     414:	27 96       	adiw	r28, 0x07	; 7
     416:	0f b6       	in	r0, 0x3f	; 63
     418:	f8 94       	cli
     41a:	de bf       	out	0x3e, r29	; 62
     41c:	0f be       	out	0x3f, r0	; 63
     41e:	cd bf       	out	0x3d, r28	; 61
     420:	cf 91       	pop	r28
     422:	df 91       	pop	r29
     424:	08 95       	ret

00000426 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     426:	df 93       	push	r29
     428:	cf 93       	push	r28
     42a:	00 d0       	rcall	.+0      	; 0x42c <vCoRoutineAddToDelayedList+0x6>
     42c:	00 d0       	rcall	.+0      	; 0x42e <vCoRoutineAddToDelayedList+0x8>
     42e:	00 d0       	rcall	.+0      	; 0x430 <vCoRoutineAddToDelayedList+0xa>
     430:	cd b7       	in	r28, 0x3d	; 61
     432:	de b7       	in	r29, 0x3e	; 62
     434:	9c 83       	std	Y+4, r25	; 0x04
     436:	8b 83       	std	Y+3, r24	; 0x03
     438:	7e 83       	std	Y+6, r23	; 0x06
     43a:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     43c:	20 91 85 00 	lds	r18, 0x0085
     440:	30 91 86 00 	lds	r19, 0x0086
     444:	8b 81       	ldd	r24, Y+3	; 0x03
     446:	9c 81       	ldd	r25, Y+4	; 0x04
     448:	82 0f       	add	r24, r18
     44a:	93 1f       	adc	r25, r19
     44c:	9a 83       	std	Y+2, r25	; 0x02
     44e:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     450:	80 91 82 00 	lds	r24, 0x0082
     454:	90 91 83 00 	lds	r25, 0x0083
     458:	02 96       	adiw	r24, 0x02	; 2
     45a:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     45e:	e0 91 82 00 	lds	r30, 0x0082
     462:	f0 91 83 00 	lds	r31, 0x0083
     466:	89 81       	ldd	r24, Y+1	; 0x01
     468:	9a 81       	ldd	r25, Y+2	; 0x02
     46a:	93 83       	std	Z+3, r25	; 0x03
     46c:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     46e:	20 91 85 00 	lds	r18, 0x0085
     472:	30 91 86 00 	lds	r19, 0x0086
     476:	89 81       	ldd	r24, Y+1	; 0x01
     478:	9a 81       	ldd	r25, Y+2	; 0x02
     47a:	82 17       	cp	r24, r18
     47c:	93 07       	cpc	r25, r19
     47e:	70 f4       	brcc	.+28     	; 0x49c <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     480:	80 91 b1 00 	lds	r24, 0x00B1
     484:	90 91 b2 00 	lds	r25, 0x00B2
     488:	20 91 82 00 	lds	r18, 0x0082
     48c:	30 91 83 00 	lds	r19, 0x0083
     490:	2e 5f       	subi	r18, 0xFE	; 254
     492:	3f 4f       	sbci	r19, 0xFF	; 255
     494:	b9 01       	movw	r22, r18
     496:	0e 94 49 05 	call	0xa92	; 0xa92 <vListInsert>
     49a:	0d c0       	rjmp	.+26     	; 0x4b6 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     49c:	80 91 af 00 	lds	r24, 0x00AF
     4a0:	90 91 b0 00 	lds	r25, 0x00B0
     4a4:	20 91 82 00 	lds	r18, 0x0082
     4a8:	30 91 83 00 	lds	r19, 0x0083
     4ac:	2e 5f       	subi	r18, 0xFE	; 254
     4ae:	3f 4f       	sbci	r19, 0xFF	; 255
     4b0:	b9 01       	movw	r22, r18
     4b2:	0e 94 49 05 	call	0xa92	; 0xa92 <vListInsert>
	}

	if( pxEventList )
     4b6:	8d 81       	ldd	r24, Y+5	; 0x05
     4b8:	9e 81       	ldd	r25, Y+6	; 0x06
     4ba:	00 97       	sbiw	r24, 0x00	; 0
     4bc:	61 f0       	breq	.+24     	; 0x4d6 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     4be:	80 91 82 00 	lds	r24, 0x0082
     4c2:	90 91 83 00 	lds	r25, 0x0083
     4c6:	9c 01       	movw	r18, r24
     4c8:	24 5f       	subi	r18, 0xF4	; 244
     4ca:	3f 4f       	sbci	r19, 0xFF	; 255
     4cc:	8d 81       	ldd	r24, Y+5	; 0x05
     4ce:	9e 81       	ldd	r25, Y+6	; 0x06
     4d0:	b9 01       	movw	r22, r18
     4d2:	0e 94 49 05 	call	0xa92	; 0xa92 <vListInsert>
	}
}
     4d6:	26 96       	adiw	r28, 0x06	; 6
     4d8:	0f b6       	in	r0, 0x3f	; 63
     4da:	f8 94       	cli
     4dc:	de bf       	out	0x3e, r29	; 62
     4de:	0f be       	out	0x3f, r0	; 63
     4e0:	cd bf       	out	0x3d, r28	; 61
     4e2:	cf 91       	pop	r28
     4e4:	df 91       	pop	r29
     4e6:	08 95       	ret

000004e8 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     4e8:	df 93       	push	r29
     4ea:	cf 93       	push	r28
     4ec:	00 d0       	rcall	.+0      	; 0x4ee <prvCheckPendingReadyList+0x6>
     4ee:	cd b7       	in	r28, 0x3d	; 61
     4f0:	de b7       	in	r29, 0x3e	; 62
     4f2:	3a c0       	rjmp	.+116    	; 0x568 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     4f4:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     4f6:	e0 91 b8 00 	lds	r30, 0x00B8
     4fa:	f0 91 b9 00 	lds	r31, 0x00B9
     4fe:	86 81       	ldd	r24, Z+6	; 0x06
     500:	97 81       	ldd	r25, Z+7	; 0x07
     502:	9a 83       	std	Y+2, r25	; 0x02
     504:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     506:	89 81       	ldd	r24, Y+1	; 0x01
     508:	9a 81       	ldd	r25, Y+2	; 0x02
     50a:	0c 96       	adiw	r24, 0x0c	; 12
     50c:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListRemove>
		}
		portENABLE_INTERRUPTS();
     510:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     512:	89 81       	ldd	r24, Y+1	; 0x01
     514:	9a 81       	ldd	r25, Y+2	; 0x02
     516:	02 96       	adiw	r24, 0x02	; 2
     518:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     51c:	e9 81       	ldd	r30, Y+1	; 0x01
     51e:	fa 81       	ldd	r31, Y+2	; 0x02
     520:	96 89       	ldd	r25, Z+22	; 0x16
     522:	80 91 84 00 	lds	r24, 0x0084
     526:	89 17       	cp	r24, r25
     528:	28 f4       	brcc	.+10     	; 0x534 <prvCheckPendingReadyList+0x4c>
     52a:	e9 81       	ldd	r30, Y+1	; 0x01
     52c:	fa 81       	ldd	r31, Y+2	; 0x02
     52e:	86 89       	ldd	r24, Z+22	; 0x16
     530:	80 93 84 00 	sts	0x0084, r24
     534:	e9 81       	ldd	r30, Y+1	; 0x01
     536:	fa 81       	ldd	r31, Y+2	; 0x02
     538:	86 89       	ldd	r24, Z+22	; 0x16
     53a:	28 2f       	mov	r18, r24
     53c:	30 e0       	ldi	r19, 0x00	; 0
     53e:	c9 01       	movw	r24, r18
     540:	88 0f       	add	r24, r24
     542:	99 1f       	adc	r25, r25
     544:	88 0f       	add	r24, r24
     546:	99 1f       	adc	r25, r25
     548:	88 0f       	add	r24, r24
     54a:	99 1f       	adc	r25, r25
     54c:	82 0f       	add	r24, r18
     54e:	93 1f       	adc	r25, r19
     550:	ac 01       	movw	r20, r24
     552:	45 57       	subi	r20, 0x75	; 117
     554:	5f 4f       	sbci	r21, 0xFF	; 255
     556:	89 81       	ldd	r24, Y+1	; 0x01
     558:	9a 81       	ldd	r25, Y+2	; 0x02
     55a:	9c 01       	movw	r18, r24
     55c:	2e 5f       	subi	r18, 0xFE	; 254
     55e:	3f 4f       	sbci	r19, 0xFF	; 255
     560:	ca 01       	movw	r24, r20
     562:	b9 01       	movw	r22, r18
     564:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     568:	80 91 b3 00 	lds	r24, 0x00B3
     56c:	88 23       	and	r24, r24
     56e:	09 f0       	breq	.+2      	; 0x572 <prvCheckPendingReadyList+0x8a>
     570:	c1 cf       	rjmp	.-126    	; 0x4f4 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     572:	0f 90       	pop	r0
     574:	0f 90       	pop	r0
     576:	cf 91       	pop	r28
     578:	df 91       	pop	r29
     57a:	08 95       	ret

0000057c <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     57c:	df 93       	push	r29
     57e:	cf 93       	push	r28
     580:	00 d0       	rcall	.+0      	; 0x582 <prvCheckDelayedList+0x6>
     582:	00 d0       	rcall	.+0      	; 0x584 <prvCheckDelayedList+0x8>
     584:	cd b7       	in	r28, 0x3d	; 61
     586:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     588:	0e 94 23 10 	call	0x2046	; 0x2046 <xTaskGetTickCount>
     58c:	20 91 87 00 	lds	r18, 0x0087
     590:	30 91 88 00 	lds	r19, 0x0088
     594:	82 1b       	sub	r24, r18
     596:	93 0b       	sbc	r25, r19
     598:	90 93 8a 00 	sts	0x008A, r25
     59c:	80 93 89 00 	sts	0x0089, r24
     5a0:	85 c0       	rjmp	.+266    	; 0x6ac <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     5a2:	80 91 85 00 	lds	r24, 0x0085
     5a6:	90 91 86 00 	lds	r25, 0x0086
     5aa:	01 96       	adiw	r24, 0x01	; 1
     5ac:	90 93 86 00 	sts	0x0086, r25
     5b0:	80 93 85 00 	sts	0x0085, r24
		xPassedTicks--;
     5b4:	80 91 89 00 	lds	r24, 0x0089
     5b8:	90 91 8a 00 	lds	r25, 0x008A
     5bc:	01 97       	sbiw	r24, 0x01	; 1
     5be:	90 93 8a 00 	sts	0x008A, r25
     5c2:	80 93 89 00 	sts	0x0089, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     5c6:	80 91 85 00 	lds	r24, 0x0085
     5ca:	90 91 86 00 	lds	r25, 0x0086
     5ce:	00 97       	sbiw	r24, 0x00	; 0
     5d0:	09 f0       	breq	.+2      	; 0x5d4 <prvCheckDelayedList+0x58>
     5d2:	64 c0       	rjmp	.+200    	; 0x69c <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     5d4:	80 91 af 00 	lds	r24, 0x00AF
     5d8:	90 91 b0 00 	lds	r25, 0x00B0
     5dc:	9a 83       	std	Y+2, r25	; 0x02
     5de:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     5e0:	80 91 b1 00 	lds	r24, 0x00B1
     5e4:	90 91 b2 00 	lds	r25, 0x00B2
     5e8:	90 93 b0 00 	sts	0x00B0, r25
     5ec:	80 93 af 00 	sts	0x00AF, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     5f0:	89 81       	ldd	r24, Y+1	; 0x01
     5f2:	9a 81       	ldd	r25, Y+2	; 0x02
     5f4:	90 93 b2 00 	sts	0x00B2, r25
     5f8:	80 93 b1 00 	sts	0x00B1, r24
     5fc:	4f c0       	rjmp	.+158    	; 0x69c <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     5fe:	e0 91 af 00 	lds	r30, 0x00AF
     602:	f0 91 b0 00 	lds	r31, 0x00B0
     606:	05 80       	ldd	r0, Z+5	; 0x05
     608:	f6 81       	ldd	r31, Z+6	; 0x06
     60a:	e0 2d       	mov	r30, r0
     60c:	86 81       	ldd	r24, Z+6	; 0x06
     60e:	97 81       	ldd	r25, Z+7	; 0x07
     610:	9c 83       	std	Y+4, r25	; 0x04
     612:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     614:	eb 81       	ldd	r30, Y+3	; 0x03
     616:	fc 81       	ldd	r31, Y+4	; 0x04
     618:	22 81       	ldd	r18, Z+2	; 0x02
     61a:	33 81       	ldd	r19, Z+3	; 0x03
     61c:	80 91 85 00 	lds	r24, 0x0085
     620:	90 91 86 00 	lds	r25, 0x0086
     624:	82 17       	cp	r24, r18
     626:	93 07       	cpc	r25, r19
     628:	08 f4       	brcc	.+2      	; 0x62c <prvCheckDelayedList+0xb0>
     62a:	40 c0       	rjmp	.+128    	; 0x6ac <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     62c:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     62e:	8b 81       	ldd	r24, Y+3	; 0x03
     630:	9c 81       	ldd	r25, Y+4	; 0x04
     632:	02 96       	adiw	r24, 0x02	; 2
     634:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     638:	eb 81       	ldd	r30, Y+3	; 0x03
     63a:	fc 81       	ldd	r31, Y+4	; 0x04
     63c:	84 89       	ldd	r24, Z+20	; 0x14
     63e:	95 89       	ldd	r25, Z+21	; 0x15
     640:	00 97       	sbiw	r24, 0x00	; 0
     642:	29 f0       	breq	.+10     	; 0x64e <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     644:	8b 81       	ldd	r24, Y+3	; 0x03
     646:	9c 81       	ldd	r25, Y+4	; 0x04
     648:	0c 96       	adiw	r24, 0x0c	; 12
     64a:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     64e:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     650:	eb 81       	ldd	r30, Y+3	; 0x03
     652:	fc 81       	ldd	r31, Y+4	; 0x04
     654:	96 89       	ldd	r25, Z+22	; 0x16
     656:	80 91 84 00 	lds	r24, 0x0084
     65a:	89 17       	cp	r24, r25
     65c:	28 f4       	brcc	.+10     	; 0x668 <prvCheckDelayedList+0xec>
     65e:	eb 81       	ldd	r30, Y+3	; 0x03
     660:	fc 81       	ldd	r31, Y+4	; 0x04
     662:	86 89       	ldd	r24, Z+22	; 0x16
     664:	80 93 84 00 	sts	0x0084, r24
     668:	eb 81       	ldd	r30, Y+3	; 0x03
     66a:	fc 81       	ldd	r31, Y+4	; 0x04
     66c:	86 89       	ldd	r24, Z+22	; 0x16
     66e:	28 2f       	mov	r18, r24
     670:	30 e0       	ldi	r19, 0x00	; 0
     672:	c9 01       	movw	r24, r18
     674:	88 0f       	add	r24, r24
     676:	99 1f       	adc	r25, r25
     678:	88 0f       	add	r24, r24
     67a:	99 1f       	adc	r25, r25
     67c:	88 0f       	add	r24, r24
     67e:	99 1f       	adc	r25, r25
     680:	82 0f       	add	r24, r18
     682:	93 1f       	adc	r25, r19
     684:	ac 01       	movw	r20, r24
     686:	45 57       	subi	r20, 0x75	; 117
     688:	5f 4f       	sbci	r21, 0xFF	; 255
     68a:	8b 81       	ldd	r24, Y+3	; 0x03
     68c:	9c 81       	ldd	r25, Y+4	; 0x04
     68e:	9c 01       	movw	r18, r24
     690:	2e 5f       	subi	r18, 0xFE	; 254
     692:	3f 4f       	sbci	r19, 0xFF	; 255
     694:	ca 01       	movw	r24, r20
     696:	b9 01       	movw	r22, r18
     698:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     69c:	e0 91 af 00 	lds	r30, 0x00AF
     6a0:	f0 91 b0 00 	lds	r31, 0x00B0
     6a4:	80 81       	ld	r24, Z
     6a6:	88 23       	and	r24, r24
     6a8:	09 f0       	breq	.+2      	; 0x6ac <prvCheckDelayedList+0x130>
     6aa:	a9 cf       	rjmp	.-174    	; 0x5fe <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     6ac:	80 91 89 00 	lds	r24, 0x0089
     6b0:	90 91 8a 00 	lds	r25, 0x008A
     6b4:	00 97       	sbiw	r24, 0x00	; 0
     6b6:	09 f0       	breq	.+2      	; 0x6ba <prvCheckDelayedList+0x13e>
     6b8:	74 cf       	rjmp	.-280    	; 0x5a2 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     6ba:	80 91 85 00 	lds	r24, 0x0085
     6be:	90 91 86 00 	lds	r25, 0x0086
     6c2:	90 93 88 00 	sts	0x0088, r25
     6c6:	80 93 87 00 	sts	0x0087, r24
}
     6ca:	0f 90       	pop	r0
     6cc:	0f 90       	pop	r0
     6ce:	0f 90       	pop	r0
     6d0:	0f 90       	pop	r0
     6d2:	cf 91       	pop	r28
     6d4:	df 91       	pop	r29
     6d6:	08 95       	ret

000006d8 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     6d8:	df 93       	push	r29
     6da:	cf 93       	push	r28
     6dc:	00 d0       	rcall	.+0      	; 0x6de <vCoRoutineSchedule+0x6>
     6de:	cd b7       	in	r28, 0x3d	; 61
     6e0:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     6e2:	0e 94 74 02 	call	0x4e8	; 0x4e8 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     6e6:	0e 94 be 02 	call	0x57c	; 0x57c <prvCheckDelayedList>
     6ea:	0a c0       	rjmp	.+20     	; 0x700 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     6ec:	80 91 84 00 	lds	r24, 0x0084
     6f0:	88 23       	and	r24, r24
     6f2:	09 f4       	brne	.+2      	; 0x6f6 <vCoRoutineSchedule+0x1e>
     6f4:	66 c0       	rjmp	.+204    	; 0x7c2 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     6f6:	80 91 84 00 	lds	r24, 0x0084
     6fa:	81 50       	subi	r24, 0x01	; 1
     6fc:	80 93 84 00 	sts	0x0084, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     700:	80 91 84 00 	lds	r24, 0x0084
     704:	28 2f       	mov	r18, r24
     706:	30 e0       	ldi	r19, 0x00	; 0
     708:	c9 01       	movw	r24, r18
     70a:	88 0f       	add	r24, r24
     70c:	99 1f       	adc	r25, r25
     70e:	88 0f       	add	r24, r24
     710:	99 1f       	adc	r25, r25
     712:	88 0f       	add	r24, r24
     714:	99 1f       	adc	r25, r25
     716:	82 0f       	add	r24, r18
     718:	93 1f       	adc	r25, r19
     71a:	fc 01       	movw	r30, r24
     71c:	e5 57       	subi	r30, 0x75	; 117
     71e:	ff 4f       	sbci	r31, 0xFF	; 255
     720:	80 81       	ld	r24, Z
     722:	88 23       	and	r24, r24
     724:	19 f3       	breq	.-58     	; 0x6ec <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     726:	80 91 84 00 	lds	r24, 0x0084
     72a:	28 2f       	mov	r18, r24
     72c:	30 e0       	ldi	r19, 0x00	; 0
     72e:	c9 01       	movw	r24, r18
     730:	88 0f       	add	r24, r24
     732:	99 1f       	adc	r25, r25
     734:	88 0f       	add	r24, r24
     736:	99 1f       	adc	r25, r25
     738:	88 0f       	add	r24, r24
     73a:	99 1f       	adc	r25, r25
     73c:	82 0f       	add	r24, r18
     73e:	93 1f       	adc	r25, r19
     740:	85 57       	subi	r24, 0x75	; 117
     742:	9f 4f       	sbci	r25, 0xFF	; 255
     744:	9a 83       	std	Y+2, r25	; 0x02
     746:	89 83       	std	Y+1, r24	; 0x01
     748:	e9 81       	ldd	r30, Y+1	; 0x01
     74a:	fa 81       	ldd	r31, Y+2	; 0x02
     74c:	01 80       	ldd	r0, Z+1	; 0x01
     74e:	f2 81       	ldd	r31, Z+2	; 0x02
     750:	e0 2d       	mov	r30, r0
     752:	82 81       	ldd	r24, Z+2	; 0x02
     754:	93 81       	ldd	r25, Z+3	; 0x03
     756:	e9 81       	ldd	r30, Y+1	; 0x01
     758:	fa 81       	ldd	r31, Y+2	; 0x02
     75a:	92 83       	std	Z+2, r25	; 0x02
     75c:	81 83       	std	Z+1, r24	; 0x01
     75e:	e9 81       	ldd	r30, Y+1	; 0x01
     760:	fa 81       	ldd	r31, Y+2	; 0x02
     762:	21 81       	ldd	r18, Z+1	; 0x01
     764:	32 81       	ldd	r19, Z+2	; 0x02
     766:	89 81       	ldd	r24, Y+1	; 0x01
     768:	9a 81       	ldd	r25, Y+2	; 0x02
     76a:	03 96       	adiw	r24, 0x03	; 3
     76c:	28 17       	cp	r18, r24
     76e:	39 07       	cpc	r19, r25
     770:	59 f4       	brne	.+22     	; 0x788 <vCoRoutineSchedule+0xb0>
     772:	e9 81       	ldd	r30, Y+1	; 0x01
     774:	fa 81       	ldd	r31, Y+2	; 0x02
     776:	01 80       	ldd	r0, Z+1	; 0x01
     778:	f2 81       	ldd	r31, Z+2	; 0x02
     77a:	e0 2d       	mov	r30, r0
     77c:	82 81       	ldd	r24, Z+2	; 0x02
     77e:	93 81       	ldd	r25, Z+3	; 0x03
     780:	e9 81       	ldd	r30, Y+1	; 0x01
     782:	fa 81       	ldd	r31, Y+2	; 0x02
     784:	92 83       	std	Z+2, r25	; 0x02
     786:	81 83       	std	Z+1, r24	; 0x01
     788:	e9 81       	ldd	r30, Y+1	; 0x01
     78a:	fa 81       	ldd	r31, Y+2	; 0x02
     78c:	01 80       	ldd	r0, Z+1	; 0x01
     78e:	f2 81       	ldd	r31, Z+2	; 0x02
     790:	e0 2d       	mov	r30, r0
     792:	86 81       	ldd	r24, Z+6	; 0x06
     794:	97 81       	ldd	r25, Z+7	; 0x07
     796:	90 93 83 00 	sts	0x0083, r25
     79a:	80 93 82 00 	sts	0x0082, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     79e:	e0 91 82 00 	lds	r30, 0x0082
     7a2:	f0 91 83 00 	lds	r31, 0x0083
     7a6:	40 81       	ld	r20, Z
     7a8:	51 81       	ldd	r21, Z+1	; 0x01
     7aa:	80 91 82 00 	lds	r24, 0x0082
     7ae:	90 91 83 00 	lds	r25, 0x0083
     7b2:	e0 91 82 00 	lds	r30, 0x0082
     7b6:	f0 91 83 00 	lds	r31, 0x0083
     7ba:	27 89       	ldd	r18, Z+23	; 0x17
     7bc:	62 2f       	mov	r22, r18
     7be:	fa 01       	movw	r30, r20
     7c0:	09 95       	icall

	return;
}
     7c2:	0f 90       	pop	r0
     7c4:	0f 90       	pop	r0
     7c6:	cf 91       	pop	r28
     7c8:	df 91       	pop	r29
     7ca:	08 95       	ret

000007cc <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     7cc:	df 93       	push	r29
     7ce:	cf 93       	push	r28
     7d0:	0f 92       	push	r0
     7d2:	cd b7       	in	r28, 0x3d	; 61
     7d4:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     7d6:	19 82       	std	Y+1, r1	; 0x01
     7d8:	13 c0       	rjmp	.+38     	; 0x800 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     7da:	89 81       	ldd	r24, Y+1	; 0x01
     7dc:	28 2f       	mov	r18, r24
     7de:	30 e0       	ldi	r19, 0x00	; 0
     7e0:	c9 01       	movw	r24, r18
     7e2:	88 0f       	add	r24, r24
     7e4:	99 1f       	adc	r25, r25
     7e6:	88 0f       	add	r24, r24
     7e8:	99 1f       	adc	r25, r25
     7ea:	88 0f       	add	r24, r24
     7ec:	99 1f       	adc	r25, r25
     7ee:	82 0f       	add	r24, r18
     7f0:	93 1f       	adc	r25, r19
     7f2:	85 57       	subi	r24, 0x75	; 117
     7f4:	9f 4f       	sbci	r25, 0xFF	; 255
     7f6:	0e 94 c3 04 	call	0x986	; 0x986 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     7fa:	89 81       	ldd	r24, Y+1	; 0x01
     7fc:	8f 5f       	subi	r24, 0xFF	; 255
     7fe:	89 83       	std	Y+1, r24	; 0x01
     800:	89 81       	ldd	r24, Y+1	; 0x01
     802:	82 30       	cpi	r24, 0x02	; 2
     804:	50 f3       	brcs	.-44     	; 0x7da <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     806:	8d e9       	ldi	r24, 0x9D	; 157
     808:	90 e0       	ldi	r25, 0x00	; 0
     80a:	0e 94 c3 04 	call	0x986	; 0x986 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     80e:	86 ea       	ldi	r24, 0xA6	; 166
     810:	90 e0       	ldi	r25, 0x00	; 0
     812:	0e 94 c3 04 	call	0x986	; 0x986 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     816:	83 eb       	ldi	r24, 0xB3	; 179
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	0e 94 c3 04 	call	0x986	; 0x986 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     81e:	8d e9       	ldi	r24, 0x9D	; 157
     820:	90 e0       	ldi	r25, 0x00	; 0
     822:	90 93 b0 00 	sts	0x00B0, r25
     826:	80 93 af 00 	sts	0x00AF, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     82a:	86 ea       	ldi	r24, 0xA6	; 166
     82c:	90 e0       	ldi	r25, 0x00	; 0
     82e:	90 93 b2 00 	sts	0x00B2, r25
     832:	80 93 b1 00 	sts	0x00B1, r24
}
     836:	0f 90       	pop	r0
     838:	cf 91       	pop	r28
     83a:	df 91       	pop	r29
     83c:	08 95       	ret

0000083e <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     83e:	df 93       	push	r29
     840:	cf 93       	push	r28
     842:	00 d0       	rcall	.+0      	; 0x844 <xCoRoutineRemoveFromEventList+0x6>
     844:	00 d0       	rcall	.+0      	; 0x846 <xCoRoutineRemoveFromEventList+0x8>
     846:	0f 92       	push	r0
     848:	cd b7       	in	r28, 0x3d	; 61
     84a:	de b7       	in	r29, 0x3e	; 62
     84c:	9d 83       	std	Y+5, r25	; 0x05
     84e:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     850:	ec 81       	ldd	r30, Y+4	; 0x04
     852:	fd 81       	ldd	r31, Y+5	; 0x05
     854:	05 80       	ldd	r0, Z+5	; 0x05
     856:	f6 81       	ldd	r31, Z+6	; 0x06
     858:	e0 2d       	mov	r30, r0
     85a:	86 81       	ldd	r24, Z+6	; 0x06
     85c:	97 81       	ldd	r25, Z+7	; 0x07
     85e:	9b 83       	std	Y+3, r25	; 0x03
     860:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     862:	8a 81       	ldd	r24, Y+2	; 0x02
     864:	9b 81       	ldd	r25, Y+3	; 0x03
     866:	0c 96       	adiw	r24, 0x0c	; 12
     868:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     86c:	8a 81       	ldd	r24, Y+2	; 0x02
     86e:	9b 81       	ldd	r25, Y+3	; 0x03
     870:	9c 01       	movw	r18, r24
     872:	24 5f       	subi	r18, 0xF4	; 244
     874:	3f 4f       	sbci	r19, 0xFF	; 255
     876:	83 eb       	ldi	r24, 0xB3	; 179
     878:	90 e0       	ldi	r25, 0x00	; 0
     87a:	b9 01       	movw	r22, r18
     87c:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     880:	ea 81       	ldd	r30, Y+2	; 0x02
     882:	fb 81       	ldd	r31, Y+3	; 0x03
     884:	96 89       	ldd	r25, Z+22	; 0x16
     886:	e0 91 82 00 	lds	r30, 0x0082
     88a:	f0 91 83 00 	lds	r31, 0x0083
     88e:	86 89       	ldd	r24, Z+22	; 0x16
     890:	98 17       	cp	r25, r24
     892:	18 f0       	brcs	.+6      	; 0x89a <__stack+0x3b>
	{
		xReturn = pdTRUE;
     894:	81 e0       	ldi	r24, 0x01	; 1
     896:	89 83       	std	Y+1, r24	; 0x01
     898:	01 c0       	rjmp	.+2      	; 0x89c <__stack+0x3d>
	}
	else
	{
		xReturn = pdFALSE;
     89a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     89c:	89 81       	ldd	r24, Y+1	; 0x01
}
     89e:	0f 90       	pop	r0
     8a0:	0f 90       	pop	r0
     8a2:	0f 90       	pop	r0
     8a4:	0f 90       	pop	r0
     8a6:	0f 90       	pop	r0
     8a8:	cf 91       	pop	r28
     8aa:	df 91       	pop	r29
     8ac:	08 95       	ret

000008ae <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     8ae:	df 93       	push	r29
     8b0:	cf 93       	push	r28
     8b2:	00 d0       	rcall	.+0      	; 0x8b4 <pvPortMalloc+0x6>
     8b4:	00 d0       	rcall	.+0      	; 0x8b6 <pvPortMalloc+0x8>
     8b6:	cd b7       	in	r28, 0x3d	; 61
     8b8:	de b7       	in	r29, 0x3e	; 62
     8ba:	9c 83       	std	Y+4, r25	; 0x04
     8bc:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     8be:	1a 82       	std	Y+2, r1	; 0x02
     8c0:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     8c2:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     8c6:	80 91 bc 00 	lds	r24, 0x00BC
     8ca:	90 91 bd 00 	lds	r25, 0x00BD
     8ce:	2b 81       	ldd	r18, Y+3	; 0x03
     8d0:	3c 81       	ldd	r19, Y+4	; 0x04
     8d2:	82 0f       	add	r24, r18
     8d4:	93 1f       	adc	r25, r19
     8d6:	22 e0       	ldi	r18, 0x02	; 2
     8d8:	88 35       	cpi	r24, 0x58	; 88
     8da:	92 07       	cpc	r25, r18
     8dc:	18 f5       	brcc	.+70     	; 0x924 <pvPortMalloc+0x76>
     8de:	20 91 bc 00 	lds	r18, 0x00BC
     8e2:	30 91 bd 00 	lds	r19, 0x00BD
     8e6:	8b 81       	ldd	r24, Y+3	; 0x03
     8e8:	9c 81       	ldd	r25, Y+4	; 0x04
     8ea:	28 0f       	add	r18, r24
     8ec:	39 1f       	adc	r19, r25
     8ee:	80 91 bc 00 	lds	r24, 0x00BC
     8f2:	90 91 bd 00 	lds	r25, 0x00BD
     8f6:	82 17       	cp	r24, r18
     8f8:	93 07       	cpc	r25, r19
     8fa:	a0 f4       	brcc	.+40     	; 0x924 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     8fc:	80 91 bc 00 	lds	r24, 0x00BC
     900:	90 91 bd 00 	lds	r25, 0x00BD
     904:	82 54       	subi	r24, 0x42	; 66
     906:	9f 4f       	sbci	r25, 0xFF	; 255
     908:	9a 83       	std	Y+2, r25	; 0x02
     90a:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     90c:	20 91 bc 00 	lds	r18, 0x00BC
     910:	30 91 bd 00 	lds	r19, 0x00BD
     914:	8b 81       	ldd	r24, Y+3	; 0x03
     916:	9c 81       	ldd	r25, Y+4	; 0x04
     918:	82 0f       	add	r24, r18
     91a:	93 1f       	adc	r25, r19
     91c:	90 93 bd 00 	sts	0x00BD, r25
     920:	80 93 bc 00 	sts	0x00BC, r24
		}	
	}
	xTaskResumeAll();
     924:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     928:	89 81       	ldd	r24, Y+1	; 0x01
     92a:	9a 81       	ldd	r25, Y+2	; 0x02
}
     92c:	0f 90       	pop	r0
     92e:	0f 90       	pop	r0
     930:	0f 90       	pop	r0
     932:	0f 90       	pop	r0
     934:	cf 91       	pop	r28
     936:	df 91       	pop	r29
     938:	08 95       	ret

0000093a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     93a:	df 93       	push	r29
     93c:	cf 93       	push	r28
     93e:	00 d0       	rcall	.+0      	; 0x940 <vPortFree+0x6>
     940:	cd b7       	in	r28, 0x3d	; 61
     942:	de b7       	in	r29, 0x3e	; 62
     944:	9a 83       	std	Y+2, r25	; 0x02
     946:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     948:	0f 90       	pop	r0
     94a:	0f 90       	pop	r0
     94c:	cf 91       	pop	r28
     94e:	df 91       	pop	r29
     950:	08 95       	ret

00000952 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     952:	df 93       	push	r29
     954:	cf 93       	push	r28
     956:	cd b7       	in	r28, 0x3d	; 61
     958:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     95a:	10 92 bd 00 	sts	0x00BD, r1
     95e:	10 92 bc 00 	sts	0x00BC, r1
}
     962:	cf 91       	pop	r28
     964:	df 91       	pop	r29
     966:	08 95       	ret

00000968 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     968:	df 93       	push	r29
     96a:	cf 93       	push	r28
     96c:	cd b7       	in	r28, 0x3d	; 61
     96e:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     970:	20 91 bc 00 	lds	r18, 0x00BC
     974:	30 91 bd 00 	lds	r19, 0x00BD
     978:	88 e5       	ldi	r24, 0x58	; 88
     97a:	92 e0       	ldi	r25, 0x02	; 2
     97c:	82 1b       	sub	r24, r18
     97e:	93 0b       	sbc	r25, r19
}
     980:	cf 91       	pop	r28
     982:	df 91       	pop	r29
     984:	08 95       	ret

00000986 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     986:	df 93       	push	r29
     988:	cf 93       	push	r28
     98a:	00 d0       	rcall	.+0      	; 0x98c <vListInitialise+0x6>
     98c:	cd b7       	in	r28, 0x3d	; 61
     98e:	de b7       	in	r29, 0x3e	; 62
     990:	9a 83       	std	Y+2, r25	; 0x02
     992:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     994:	89 81       	ldd	r24, Y+1	; 0x01
     996:	9a 81       	ldd	r25, Y+2	; 0x02
     998:	03 96       	adiw	r24, 0x03	; 3
     99a:	e9 81       	ldd	r30, Y+1	; 0x01
     99c:	fa 81       	ldd	r31, Y+2	; 0x02
     99e:	92 83       	std	Z+2, r25	; 0x02
     9a0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     9a2:	e9 81       	ldd	r30, Y+1	; 0x01
     9a4:	fa 81       	ldd	r31, Y+2	; 0x02
     9a6:	8f ef       	ldi	r24, 0xFF	; 255
     9a8:	9f ef       	ldi	r25, 0xFF	; 255
     9aa:	94 83       	std	Z+4, r25	; 0x04
     9ac:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     9ae:	89 81       	ldd	r24, Y+1	; 0x01
     9b0:	9a 81       	ldd	r25, Y+2	; 0x02
     9b2:	03 96       	adiw	r24, 0x03	; 3
     9b4:	e9 81       	ldd	r30, Y+1	; 0x01
     9b6:	fa 81       	ldd	r31, Y+2	; 0x02
     9b8:	96 83       	std	Z+6, r25	; 0x06
     9ba:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     9bc:	89 81       	ldd	r24, Y+1	; 0x01
     9be:	9a 81       	ldd	r25, Y+2	; 0x02
     9c0:	03 96       	adiw	r24, 0x03	; 3
     9c2:	e9 81       	ldd	r30, Y+1	; 0x01
     9c4:	fa 81       	ldd	r31, Y+2	; 0x02
     9c6:	90 87       	std	Z+8, r25	; 0x08
     9c8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     9ca:	e9 81       	ldd	r30, Y+1	; 0x01
     9cc:	fa 81       	ldd	r31, Y+2	; 0x02
     9ce:	10 82       	st	Z, r1
}
     9d0:	0f 90       	pop	r0
     9d2:	0f 90       	pop	r0
     9d4:	cf 91       	pop	r28
     9d6:	df 91       	pop	r29
     9d8:	08 95       	ret

000009da <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     9da:	df 93       	push	r29
     9dc:	cf 93       	push	r28
     9de:	00 d0       	rcall	.+0      	; 0x9e0 <vListInitialiseItem+0x6>
     9e0:	cd b7       	in	r28, 0x3d	; 61
     9e2:	de b7       	in	r29, 0x3e	; 62
     9e4:	9a 83       	std	Y+2, r25	; 0x02
     9e6:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     9e8:	e9 81       	ldd	r30, Y+1	; 0x01
     9ea:	fa 81       	ldd	r31, Y+2	; 0x02
     9ec:	11 86       	std	Z+9, r1	; 0x09
     9ee:	10 86       	std	Z+8, r1	; 0x08
}
     9f0:	0f 90       	pop	r0
     9f2:	0f 90       	pop	r0
     9f4:	cf 91       	pop	r28
     9f6:	df 91       	pop	r29
     9f8:	08 95       	ret

000009fa <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     9fa:	df 93       	push	r29
     9fc:	cf 93       	push	r28
     9fe:	00 d0       	rcall	.+0      	; 0xa00 <vListInsertEnd+0x6>
     a00:	00 d0       	rcall	.+0      	; 0xa02 <vListInsertEnd+0x8>
     a02:	00 d0       	rcall	.+0      	; 0xa04 <vListInsertEnd+0xa>
     a04:	cd b7       	in	r28, 0x3d	; 61
     a06:	de b7       	in	r29, 0x3e	; 62
     a08:	9c 83       	std	Y+4, r25	; 0x04
     a0a:	8b 83       	std	Y+3, r24	; 0x03
     a0c:	7e 83       	std	Y+6, r23	; 0x06
     a0e:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     a10:	eb 81       	ldd	r30, Y+3	; 0x03
     a12:	fc 81       	ldd	r31, Y+4	; 0x04
     a14:	81 81       	ldd	r24, Z+1	; 0x01
     a16:	92 81       	ldd	r25, Z+2	; 0x02
     a18:	9a 83       	std	Y+2, r25	; 0x02
     a1a:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     a1c:	e9 81       	ldd	r30, Y+1	; 0x01
     a1e:	fa 81       	ldd	r31, Y+2	; 0x02
     a20:	82 81       	ldd	r24, Z+2	; 0x02
     a22:	93 81       	ldd	r25, Z+3	; 0x03
     a24:	ed 81       	ldd	r30, Y+5	; 0x05
     a26:	fe 81       	ldd	r31, Y+6	; 0x06
     a28:	93 83       	std	Z+3, r25	; 0x03
     a2a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     a2c:	eb 81       	ldd	r30, Y+3	; 0x03
     a2e:	fc 81       	ldd	r31, Y+4	; 0x04
     a30:	81 81       	ldd	r24, Z+1	; 0x01
     a32:	92 81       	ldd	r25, Z+2	; 0x02
     a34:	ed 81       	ldd	r30, Y+5	; 0x05
     a36:	fe 81       	ldd	r31, Y+6	; 0x06
     a38:	95 83       	std	Z+5, r25	; 0x05
     a3a:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     a3c:	e9 81       	ldd	r30, Y+1	; 0x01
     a3e:	fa 81       	ldd	r31, Y+2	; 0x02
     a40:	02 80       	ldd	r0, Z+2	; 0x02
     a42:	f3 81       	ldd	r31, Z+3	; 0x03
     a44:	e0 2d       	mov	r30, r0
     a46:	8d 81       	ldd	r24, Y+5	; 0x05
     a48:	9e 81       	ldd	r25, Y+6	; 0x06
     a4a:	95 83       	std	Z+5, r25	; 0x05
     a4c:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     a4e:	8d 81       	ldd	r24, Y+5	; 0x05
     a50:	9e 81       	ldd	r25, Y+6	; 0x06
     a52:	e9 81       	ldd	r30, Y+1	; 0x01
     a54:	fa 81       	ldd	r31, Y+2	; 0x02
     a56:	93 83       	std	Z+3, r25	; 0x03
     a58:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     a5a:	8d 81       	ldd	r24, Y+5	; 0x05
     a5c:	9e 81       	ldd	r25, Y+6	; 0x06
     a5e:	eb 81       	ldd	r30, Y+3	; 0x03
     a60:	fc 81       	ldd	r31, Y+4	; 0x04
     a62:	92 83       	std	Z+2, r25	; 0x02
     a64:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a66:	ed 81       	ldd	r30, Y+5	; 0x05
     a68:	fe 81       	ldd	r31, Y+6	; 0x06
     a6a:	8b 81       	ldd	r24, Y+3	; 0x03
     a6c:	9c 81       	ldd	r25, Y+4	; 0x04
     a6e:	91 87       	std	Z+9, r25	; 0x09
     a70:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     a72:	eb 81       	ldd	r30, Y+3	; 0x03
     a74:	fc 81       	ldd	r31, Y+4	; 0x04
     a76:	80 81       	ld	r24, Z
     a78:	8f 5f       	subi	r24, 0xFF	; 255
     a7a:	eb 81       	ldd	r30, Y+3	; 0x03
     a7c:	fc 81       	ldd	r31, Y+4	; 0x04
     a7e:	80 83       	st	Z, r24
}
     a80:	26 96       	adiw	r28, 0x06	; 6
     a82:	0f b6       	in	r0, 0x3f	; 63
     a84:	f8 94       	cli
     a86:	de bf       	out	0x3e, r29	; 62
     a88:	0f be       	out	0x3f, r0	; 63
     a8a:	cd bf       	out	0x3d, r28	; 61
     a8c:	cf 91       	pop	r28
     a8e:	df 91       	pop	r29
     a90:	08 95       	ret

00000a92 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     a92:	df 93       	push	r29
     a94:	cf 93       	push	r28
     a96:	cd b7       	in	r28, 0x3d	; 61
     a98:	de b7       	in	r29, 0x3e	; 62
     a9a:	28 97       	sbiw	r28, 0x08	; 8
     a9c:	0f b6       	in	r0, 0x3f	; 63
     a9e:	f8 94       	cli
     aa0:	de bf       	out	0x3e, r29	; 62
     aa2:	0f be       	out	0x3f, r0	; 63
     aa4:	cd bf       	out	0x3d, r28	; 61
     aa6:	9e 83       	std	Y+6, r25	; 0x06
     aa8:	8d 83       	std	Y+5, r24	; 0x05
     aaa:	78 87       	std	Y+8, r23	; 0x08
     aac:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     aae:	ef 81       	ldd	r30, Y+7	; 0x07
     ab0:	f8 85       	ldd	r31, Y+8	; 0x08
     ab2:	80 81       	ld	r24, Z
     ab4:	91 81       	ldd	r25, Z+1	; 0x01
     ab6:	9a 83       	std	Y+2, r25	; 0x02
     ab8:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     aba:	89 81       	ldd	r24, Y+1	; 0x01
     abc:	9a 81       	ldd	r25, Y+2	; 0x02
     abe:	2f ef       	ldi	r18, 0xFF	; 255
     ac0:	8f 3f       	cpi	r24, 0xFF	; 255
     ac2:	92 07       	cpc	r25, r18
     ac4:	39 f4       	brne	.+14     	; 0xad4 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     ac6:	ed 81       	ldd	r30, Y+5	; 0x05
     ac8:	fe 81       	ldd	r31, Y+6	; 0x06
     aca:	87 81       	ldd	r24, Z+7	; 0x07
     acc:	90 85       	ldd	r25, Z+8	; 0x08
     ace:	9c 83       	std	Y+4, r25	; 0x04
     ad0:	8b 83       	std	Y+3, r24	; 0x03
     ad2:	18 c0       	rjmp	.+48     	; 0xb04 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     ad4:	8d 81       	ldd	r24, Y+5	; 0x05
     ad6:	9e 81       	ldd	r25, Y+6	; 0x06
     ad8:	03 96       	adiw	r24, 0x03	; 3
     ada:	9c 83       	std	Y+4, r25	; 0x04
     adc:	8b 83       	std	Y+3, r24	; 0x03
     ade:	06 c0       	rjmp	.+12     	; 0xaec <vListInsert+0x5a>
     ae0:	eb 81       	ldd	r30, Y+3	; 0x03
     ae2:	fc 81       	ldd	r31, Y+4	; 0x04
     ae4:	82 81       	ldd	r24, Z+2	; 0x02
     ae6:	93 81       	ldd	r25, Z+3	; 0x03
     ae8:	9c 83       	std	Y+4, r25	; 0x04
     aea:	8b 83       	std	Y+3, r24	; 0x03
     aec:	eb 81       	ldd	r30, Y+3	; 0x03
     aee:	fc 81       	ldd	r31, Y+4	; 0x04
     af0:	02 80       	ldd	r0, Z+2	; 0x02
     af2:	f3 81       	ldd	r31, Z+3	; 0x03
     af4:	e0 2d       	mov	r30, r0
     af6:	20 81       	ld	r18, Z
     af8:	31 81       	ldd	r19, Z+1	; 0x01
     afa:	89 81       	ldd	r24, Y+1	; 0x01
     afc:	9a 81       	ldd	r25, Y+2	; 0x02
     afe:	82 17       	cp	r24, r18
     b00:	93 07       	cpc	r25, r19
     b02:	70 f7       	brcc	.-36     	; 0xae0 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     b04:	eb 81       	ldd	r30, Y+3	; 0x03
     b06:	fc 81       	ldd	r31, Y+4	; 0x04
     b08:	82 81       	ldd	r24, Z+2	; 0x02
     b0a:	93 81       	ldd	r25, Z+3	; 0x03
     b0c:	ef 81       	ldd	r30, Y+7	; 0x07
     b0e:	f8 85       	ldd	r31, Y+8	; 0x08
     b10:	93 83       	std	Z+3, r25	; 0x03
     b12:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     b14:	ef 81       	ldd	r30, Y+7	; 0x07
     b16:	f8 85       	ldd	r31, Y+8	; 0x08
     b18:	02 80       	ldd	r0, Z+2	; 0x02
     b1a:	f3 81       	ldd	r31, Z+3	; 0x03
     b1c:	e0 2d       	mov	r30, r0
     b1e:	8f 81       	ldd	r24, Y+7	; 0x07
     b20:	98 85       	ldd	r25, Y+8	; 0x08
     b22:	95 83       	std	Z+5, r25	; 0x05
     b24:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     b26:	ef 81       	ldd	r30, Y+7	; 0x07
     b28:	f8 85       	ldd	r31, Y+8	; 0x08
     b2a:	8b 81       	ldd	r24, Y+3	; 0x03
     b2c:	9c 81       	ldd	r25, Y+4	; 0x04
     b2e:	95 83       	std	Z+5, r25	; 0x05
     b30:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     b32:	8f 81       	ldd	r24, Y+7	; 0x07
     b34:	98 85       	ldd	r25, Y+8	; 0x08
     b36:	eb 81       	ldd	r30, Y+3	; 0x03
     b38:	fc 81       	ldd	r31, Y+4	; 0x04
     b3a:	93 83       	std	Z+3, r25	; 0x03
     b3c:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     b3e:	ef 81       	ldd	r30, Y+7	; 0x07
     b40:	f8 85       	ldd	r31, Y+8	; 0x08
     b42:	8d 81       	ldd	r24, Y+5	; 0x05
     b44:	9e 81       	ldd	r25, Y+6	; 0x06
     b46:	91 87       	std	Z+9, r25	; 0x09
     b48:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     b4a:	ed 81       	ldd	r30, Y+5	; 0x05
     b4c:	fe 81       	ldd	r31, Y+6	; 0x06
     b4e:	80 81       	ld	r24, Z
     b50:	8f 5f       	subi	r24, 0xFF	; 255
     b52:	ed 81       	ldd	r30, Y+5	; 0x05
     b54:	fe 81       	ldd	r31, Y+6	; 0x06
     b56:	80 83       	st	Z, r24
}
     b58:	28 96       	adiw	r28, 0x08	; 8
     b5a:	0f b6       	in	r0, 0x3f	; 63
     b5c:	f8 94       	cli
     b5e:	de bf       	out	0x3e, r29	; 62
     b60:	0f be       	out	0x3f, r0	; 63
     b62:	cd bf       	out	0x3d, r28	; 61
     b64:	cf 91       	pop	r28
     b66:	df 91       	pop	r29
     b68:	08 95       	ret

00000b6a <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     b6a:	df 93       	push	r29
     b6c:	cf 93       	push	r28
     b6e:	00 d0       	rcall	.+0      	; 0xb70 <vListRemove+0x6>
     b70:	00 d0       	rcall	.+0      	; 0xb72 <vListRemove+0x8>
     b72:	cd b7       	in	r28, 0x3d	; 61
     b74:	de b7       	in	r29, 0x3e	; 62
     b76:	9c 83       	std	Y+4, r25	; 0x04
     b78:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     b7a:	eb 81       	ldd	r30, Y+3	; 0x03
     b7c:	fc 81       	ldd	r31, Y+4	; 0x04
     b7e:	a2 81       	ldd	r26, Z+2	; 0x02
     b80:	b3 81       	ldd	r27, Z+3	; 0x03
     b82:	eb 81       	ldd	r30, Y+3	; 0x03
     b84:	fc 81       	ldd	r31, Y+4	; 0x04
     b86:	84 81       	ldd	r24, Z+4	; 0x04
     b88:	95 81       	ldd	r25, Z+5	; 0x05
     b8a:	15 96       	adiw	r26, 0x05	; 5
     b8c:	9c 93       	st	X, r25
     b8e:	8e 93       	st	-X, r24
     b90:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     b92:	eb 81       	ldd	r30, Y+3	; 0x03
     b94:	fc 81       	ldd	r31, Y+4	; 0x04
     b96:	a4 81       	ldd	r26, Z+4	; 0x04
     b98:	b5 81       	ldd	r27, Z+5	; 0x05
     b9a:	eb 81       	ldd	r30, Y+3	; 0x03
     b9c:	fc 81       	ldd	r31, Y+4	; 0x04
     b9e:	82 81       	ldd	r24, Z+2	; 0x02
     ba0:	93 81       	ldd	r25, Z+3	; 0x03
     ba2:	13 96       	adiw	r26, 0x03	; 3
     ba4:	9c 93       	st	X, r25
     ba6:	8e 93       	st	-X, r24
     ba8:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     baa:	eb 81       	ldd	r30, Y+3	; 0x03
     bac:	fc 81       	ldd	r31, Y+4	; 0x04
     bae:	80 85       	ldd	r24, Z+8	; 0x08
     bb0:	91 85       	ldd	r25, Z+9	; 0x09
     bb2:	9a 83       	std	Y+2, r25	; 0x02
     bb4:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     bb6:	e9 81       	ldd	r30, Y+1	; 0x01
     bb8:	fa 81       	ldd	r31, Y+2	; 0x02
     bba:	21 81       	ldd	r18, Z+1	; 0x01
     bbc:	32 81       	ldd	r19, Z+2	; 0x02
     bbe:	8b 81       	ldd	r24, Y+3	; 0x03
     bc0:	9c 81       	ldd	r25, Y+4	; 0x04
     bc2:	28 17       	cp	r18, r24
     bc4:	39 07       	cpc	r19, r25
     bc6:	41 f4       	brne	.+16     	; 0xbd8 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     bc8:	eb 81       	ldd	r30, Y+3	; 0x03
     bca:	fc 81       	ldd	r31, Y+4	; 0x04
     bcc:	84 81       	ldd	r24, Z+4	; 0x04
     bce:	95 81       	ldd	r25, Z+5	; 0x05
     bd0:	e9 81       	ldd	r30, Y+1	; 0x01
     bd2:	fa 81       	ldd	r31, Y+2	; 0x02
     bd4:	92 83       	std	Z+2, r25	; 0x02
     bd6:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     bd8:	eb 81       	ldd	r30, Y+3	; 0x03
     bda:	fc 81       	ldd	r31, Y+4	; 0x04
     bdc:	11 86       	std	Z+9, r1	; 0x09
     bde:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     be0:	e9 81       	ldd	r30, Y+1	; 0x01
     be2:	fa 81       	ldd	r31, Y+2	; 0x02
     be4:	80 81       	ld	r24, Z
     be6:	81 50       	subi	r24, 0x01	; 1
     be8:	e9 81       	ldd	r30, Y+1	; 0x01
     bea:	fa 81       	ldd	r31, Y+2	; 0x02
     bec:	80 83       	st	Z, r24
}
     bee:	0f 90       	pop	r0
     bf0:	0f 90       	pop	r0
     bf2:	0f 90       	pop	r0
     bf4:	0f 90       	pop	r0
     bf6:	cf 91       	pop	r28
     bf8:	df 91       	pop	r29
     bfa:	08 95       	ret

00000bfc <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
     bfc:	df 93       	push	r29
     bfe:	cf 93       	push	r28
     c00:	cd b7       	in	r28, 0x3d	; 61
     c02:	de b7       	in	r29, 0x3e	; 62
     c04:	28 97       	sbiw	r28, 0x08	; 8
     c06:	0f b6       	in	r0, 0x3f	; 63
     c08:	f8 94       	cli
     c0a:	de bf       	out	0x3e, r29	; 62
     c0c:	0f be       	out	0x3f, r0	; 63
     c0e:	cd bf       	out	0x3d, r28	; 61
     c10:	9c 83       	std	Y+4, r25	; 0x04
     c12:	8b 83       	std	Y+3, r24	; 0x03
     c14:	7e 83       	std	Y+6, r23	; 0x06
     c16:	6d 83       	std	Y+5, r22	; 0x05
     c18:	58 87       	std	Y+8, r21	; 0x08
     c1a:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     c1c:	eb 81       	ldd	r30, Y+3	; 0x03
     c1e:	fc 81       	ldd	r31, Y+4	; 0x04
     c20:	81 e1       	ldi	r24, 0x11	; 17
     c22:	80 83       	st	Z, r24
	pxTopOfStack--;
     c24:	8b 81       	ldd	r24, Y+3	; 0x03
     c26:	9c 81       	ldd	r25, Y+4	; 0x04
     c28:	01 97       	sbiw	r24, 0x01	; 1
     c2a:	9c 83       	std	Y+4, r25	; 0x04
     c2c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     c2e:	eb 81       	ldd	r30, Y+3	; 0x03
     c30:	fc 81       	ldd	r31, Y+4	; 0x04
     c32:	82 e2       	ldi	r24, 0x22	; 34
     c34:	80 83       	st	Z, r24
	pxTopOfStack--;
     c36:	8b 81       	ldd	r24, Y+3	; 0x03
     c38:	9c 81       	ldd	r25, Y+4	; 0x04
     c3a:	01 97       	sbiw	r24, 0x01	; 1
     c3c:	9c 83       	std	Y+4, r25	; 0x04
     c3e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     c40:	eb 81       	ldd	r30, Y+3	; 0x03
     c42:	fc 81       	ldd	r31, Y+4	; 0x04
     c44:	83 e3       	ldi	r24, 0x33	; 51
     c46:	80 83       	st	Z, r24
	pxTopOfStack--;
     c48:	8b 81       	ldd	r24, Y+3	; 0x03
     c4a:	9c 81       	ldd	r25, Y+4	; 0x04
     c4c:	01 97       	sbiw	r24, 0x01	; 1
     c4e:	9c 83       	std	Y+4, r25	; 0x04
     c50:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
     c52:	8d 81       	ldd	r24, Y+5	; 0x05
     c54:	9e 81       	ldd	r25, Y+6	; 0x06
     c56:	9a 83       	std	Y+2, r25	; 0x02
     c58:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     c5a:	89 81       	ldd	r24, Y+1	; 0x01
     c5c:	eb 81       	ldd	r30, Y+3	; 0x03
     c5e:	fc 81       	ldd	r31, Y+4	; 0x04
     c60:	80 83       	st	Z, r24
	pxTopOfStack--;
     c62:	8b 81       	ldd	r24, Y+3	; 0x03
     c64:	9c 81       	ldd	r25, Y+4	; 0x04
     c66:	01 97       	sbiw	r24, 0x01	; 1
     c68:	9c 83       	std	Y+4, r25	; 0x04
     c6a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     c6c:	89 81       	ldd	r24, Y+1	; 0x01
     c6e:	9a 81       	ldd	r25, Y+2	; 0x02
     c70:	89 2f       	mov	r24, r25
     c72:	99 27       	eor	r25, r25
     c74:	9a 83       	std	Y+2, r25	; 0x02
     c76:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     c78:	89 81       	ldd	r24, Y+1	; 0x01
     c7a:	eb 81       	ldd	r30, Y+3	; 0x03
     c7c:	fc 81       	ldd	r31, Y+4	; 0x04
     c7e:	80 83       	st	Z, r24
	pxTopOfStack--;
     c80:	8b 81       	ldd	r24, Y+3	; 0x03
     c82:	9c 81       	ldd	r25, Y+4	; 0x04
     c84:	01 97       	sbiw	r24, 0x01	; 1
     c86:	9c 83       	std	Y+4, r25	; 0x04
     c88:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     c8a:	eb 81       	ldd	r30, Y+3	; 0x03
     c8c:	fc 81       	ldd	r31, Y+4	; 0x04
     c8e:	10 82       	st	Z, r1
	pxTopOfStack--;
     c90:	8b 81       	ldd	r24, Y+3	; 0x03
     c92:	9c 81       	ldd	r25, Y+4	; 0x04
     c94:	01 97       	sbiw	r24, 0x01	; 1
     c96:	9c 83       	std	Y+4, r25	; 0x04
     c98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     c9a:	eb 81       	ldd	r30, Y+3	; 0x03
     c9c:	fc 81       	ldd	r31, Y+4	; 0x04
     c9e:	80 e8       	ldi	r24, 0x80	; 128
     ca0:	80 83       	st	Z, r24
	pxTopOfStack--;
     ca2:	8b 81       	ldd	r24, Y+3	; 0x03
     ca4:	9c 81       	ldd	r25, Y+4	; 0x04
     ca6:	01 97       	sbiw	r24, 0x01	; 1
     ca8:	9c 83       	std	Y+4, r25	; 0x04
     caa:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     cac:	eb 81       	ldd	r30, Y+3	; 0x03
     cae:	fc 81       	ldd	r31, Y+4	; 0x04
     cb0:	10 82       	st	Z, r1
	pxTopOfStack--;
     cb2:	8b 81       	ldd	r24, Y+3	; 0x03
     cb4:	9c 81       	ldd	r25, Y+4	; 0x04
     cb6:	01 97       	sbiw	r24, 0x01	; 1
     cb8:	9c 83       	std	Y+4, r25	; 0x04
     cba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     cbc:	eb 81       	ldd	r30, Y+3	; 0x03
     cbe:	fc 81       	ldd	r31, Y+4	; 0x04
     cc0:	82 e0       	ldi	r24, 0x02	; 2
     cc2:	80 83       	st	Z, r24
	pxTopOfStack--;
     cc4:	8b 81       	ldd	r24, Y+3	; 0x03
     cc6:	9c 81       	ldd	r25, Y+4	; 0x04
     cc8:	01 97       	sbiw	r24, 0x01	; 1
     cca:	9c 83       	std	Y+4, r25	; 0x04
     ccc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     cce:	eb 81       	ldd	r30, Y+3	; 0x03
     cd0:	fc 81       	ldd	r31, Y+4	; 0x04
     cd2:	83 e0       	ldi	r24, 0x03	; 3
     cd4:	80 83       	st	Z, r24
	pxTopOfStack--;
     cd6:	8b 81       	ldd	r24, Y+3	; 0x03
     cd8:	9c 81       	ldd	r25, Y+4	; 0x04
     cda:	01 97       	sbiw	r24, 0x01	; 1
     cdc:	9c 83       	std	Y+4, r25	; 0x04
     cde:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     ce0:	eb 81       	ldd	r30, Y+3	; 0x03
     ce2:	fc 81       	ldd	r31, Y+4	; 0x04
     ce4:	84 e0       	ldi	r24, 0x04	; 4
     ce6:	80 83       	st	Z, r24
	pxTopOfStack--;
     ce8:	8b 81       	ldd	r24, Y+3	; 0x03
     cea:	9c 81       	ldd	r25, Y+4	; 0x04
     cec:	01 97       	sbiw	r24, 0x01	; 1
     cee:	9c 83       	std	Y+4, r25	; 0x04
     cf0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     cf2:	eb 81       	ldd	r30, Y+3	; 0x03
     cf4:	fc 81       	ldd	r31, Y+4	; 0x04
     cf6:	85 e0       	ldi	r24, 0x05	; 5
     cf8:	80 83       	st	Z, r24
	pxTopOfStack--;
     cfa:	8b 81       	ldd	r24, Y+3	; 0x03
     cfc:	9c 81       	ldd	r25, Y+4	; 0x04
     cfe:	01 97       	sbiw	r24, 0x01	; 1
     d00:	9c 83       	std	Y+4, r25	; 0x04
     d02:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     d04:	eb 81       	ldd	r30, Y+3	; 0x03
     d06:	fc 81       	ldd	r31, Y+4	; 0x04
     d08:	86 e0       	ldi	r24, 0x06	; 6
     d0a:	80 83       	st	Z, r24
	pxTopOfStack--;
     d0c:	8b 81       	ldd	r24, Y+3	; 0x03
     d0e:	9c 81       	ldd	r25, Y+4	; 0x04
     d10:	01 97       	sbiw	r24, 0x01	; 1
     d12:	9c 83       	std	Y+4, r25	; 0x04
     d14:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     d16:	eb 81       	ldd	r30, Y+3	; 0x03
     d18:	fc 81       	ldd	r31, Y+4	; 0x04
     d1a:	87 e0       	ldi	r24, 0x07	; 7
     d1c:	80 83       	st	Z, r24
	pxTopOfStack--;
     d1e:	8b 81       	ldd	r24, Y+3	; 0x03
     d20:	9c 81       	ldd	r25, Y+4	; 0x04
     d22:	01 97       	sbiw	r24, 0x01	; 1
     d24:	9c 83       	std	Y+4, r25	; 0x04
     d26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     d28:	eb 81       	ldd	r30, Y+3	; 0x03
     d2a:	fc 81       	ldd	r31, Y+4	; 0x04
     d2c:	88 e0       	ldi	r24, 0x08	; 8
     d2e:	80 83       	st	Z, r24
	pxTopOfStack--;
     d30:	8b 81       	ldd	r24, Y+3	; 0x03
     d32:	9c 81       	ldd	r25, Y+4	; 0x04
     d34:	01 97       	sbiw	r24, 0x01	; 1
     d36:	9c 83       	std	Y+4, r25	; 0x04
     d38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     d3a:	eb 81       	ldd	r30, Y+3	; 0x03
     d3c:	fc 81       	ldd	r31, Y+4	; 0x04
     d3e:	89 e0       	ldi	r24, 0x09	; 9
     d40:	80 83       	st	Z, r24
	pxTopOfStack--;
     d42:	8b 81       	ldd	r24, Y+3	; 0x03
     d44:	9c 81       	ldd	r25, Y+4	; 0x04
     d46:	01 97       	sbiw	r24, 0x01	; 1
     d48:	9c 83       	std	Y+4, r25	; 0x04
     d4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     d4c:	eb 81       	ldd	r30, Y+3	; 0x03
     d4e:	fc 81       	ldd	r31, Y+4	; 0x04
     d50:	80 e1       	ldi	r24, 0x10	; 16
     d52:	80 83       	st	Z, r24
	pxTopOfStack--;
     d54:	8b 81       	ldd	r24, Y+3	; 0x03
     d56:	9c 81       	ldd	r25, Y+4	; 0x04
     d58:	01 97       	sbiw	r24, 0x01	; 1
     d5a:	9c 83       	std	Y+4, r25	; 0x04
     d5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     d5e:	eb 81       	ldd	r30, Y+3	; 0x03
     d60:	fc 81       	ldd	r31, Y+4	; 0x04
     d62:	81 e1       	ldi	r24, 0x11	; 17
     d64:	80 83       	st	Z, r24
	pxTopOfStack--;
     d66:	8b 81       	ldd	r24, Y+3	; 0x03
     d68:	9c 81       	ldd	r25, Y+4	; 0x04
     d6a:	01 97       	sbiw	r24, 0x01	; 1
     d6c:	9c 83       	std	Y+4, r25	; 0x04
     d6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     d70:	eb 81       	ldd	r30, Y+3	; 0x03
     d72:	fc 81       	ldd	r31, Y+4	; 0x04
     d74:	82 e1       	ldi	r24, 0x12	; 18
     d76:	80 83       	st	Z, r24
	pxTopOfStack--;
     d78:	8b 81       	ldd	r24, Y+3	; 0x03
     d7a:	9c 81       	ldd	r25, Y+4	; 0x04
     d7c:	01 97       	sbiw	r24, 0x01	; 1
     d7e:	9c 83       	std	Y+4, r25	; 0x04
     d80:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     d82:	eb 81       	ldd	r30, Y+3	; 0x03
     d84:	fc 81       	ldd	r31, Y+4	; 0x04
     d86:	83 e1       	ldi	r24, 0x13	; 19
     d88:	80 83       	st	Z, r24
	pxTopOfStack--;
     d8a:	8b 81       	ldd	r24, Y+3	; 0x03
     d8c:	9c 81       	ldd	r25, Y+4	; 0x04
     d8e:	01 97       	sbiw	r24, 0x01	; 1
     d90:	9c 83       	std	Y+4, r25	; 0x04
     d92:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     d94:	eb 81       	ldd	r30, Y+3	; 0x03
     d96:	fc 81       	ldd	r31, Y+4	; 0x04
     d98:	84 e1       	ldi	r24, 0x14	; 20
     d9a:	80 83       	st	Z, r24
	pxTopOfStack--;
     d9c:	8b 81       	ldd	r24, Y+3	; 0x03
     d9e:	9c 81       	ldd	r25, Y+4	; 0x04
     da0:	01 97       	sbiw	r24, 0x01	; 1
     da2:	9c 83       	std	Y+4, r25	; 0x04
     da4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     da6:	eb 81       	ldd	r30, Y+3	; 0x03
     da8:	fc 81       	ldd	r31, Y+4	; 0x04
     daa:	85 e1       	ldi	r24, 0x15	; 21
     dac:	80 83       	st	Z, r24
	pxTopOfStack--;
     dae:	8b 81       	ldd	r24, Y+3	; 0x03
     db0:	9c 81       	ldd	r25, Y+4	; 0x04
     db2:	01 97       	sbiw	r24, 0x01	; 1
     db4:	9c 83       	std	Y+4, r25	; 0x04
     db6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     db8:	eb 81       	ldd	r30, Y+3	; 0x03
     dba:	fc 81       	ldd	r31, Y+4	; 0x04
     dbc:	86 e1       	ldi	r24, 0x16	; 22
     dbe:	80 83       	st	Z, r24
	pxTopOfStack--;
     dc0:	8b 81       	ldd	r24, Y+3	; 0x03
     dc2:	9c 81       	ldd	r25, Y+4	; 0x04
     dc4:	01 97       	sbiw	r24, 0x01	; 1
     dc6:	9c 83       	std	Y+4, r25	; 0x04
     dc8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     dca:	eb 81       	ldd	r30, Y+3	; 0x03
     dcc:	fc 81       	ldd	r31, Y+4	; 0x04
     dce:	87 e1       	ldi	r24, 0x17	; 23
     dd0:	80 83       	st	Z, r24
	pxTopOfStack--;
     dd2:	8b 81       	ldd	r24, Y+3	; 0x03
     dd4:	9c 81       	ldd	r25, Y+4	; 0x04
     dd6:	01 97       	sbiw	r24, 0x01	; 1
     dd8:	9c 83       	std	Y+4, r25	; 0x04
     dda:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     ddc:	eb 81       	ldd	r30, Y+3	; 0x03
     dde:	fc 81       	ldd	r31, Y+4	; 0x04
     de0:	88 e1       	ldi	r24, 0x18	; 24
     de2:	80 83       	st	Z, r24
	pxTopOfStack--;
     de4:	8b 81       	ldd	r24, Y+3	; 0x03
     de6:	9c 81       	ldd	r25, Y+4	; 0x04
     de8:	01 97       	sbiw	r24, 0x01	; 1
     dea:	9c 83       	std	Y+4, r25	; 0x04
     dec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     dee:	eb 81       	ldd	r30, Y+3	; 0x03
     df0:	fc 81       	ldd	r31, Y+4	; 0x04
     df2:	89 e1       	ldi	r24, 0x19	; 25
     df4:	80 83       	st	Z, r24
	pxTopOfStack--;
     df6:	8b 81       	ldd	r24, Y+3	; 0x03
     df8:	9c 81       	ldd	r25, Y+4	; 0x04
     dfa:	01 97       	sbiw	r24, 0x01	; 1
     dfc:	9c 83       	std	Y+4, r25	; 0x04
     dfe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     e00:	eb 81       	ldd	r30, Y+3	; 0x03
     e02:	fc 81       	ldd	r31, Y+4	; 0x04
     e04:	80 e2       	ldi	r24, 0x20	; 32
     e06:	80 83       	st	Z, r24
	pxTopOfStack--;
     e08:	8b 81       	ldd	r24, Y+3	; 0x03
     e0a:	9c 81       	ldd	r25, Y+4	; 0x04
     e0c:	01 97       	sbiw	r24, 0x01	; 1
     e0e:	9c 83       	std	Y+4, r25	; 0x04
     e10:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     e12:	eb 81       	ldd	r30, Y+3	; 0x03
     e14:	fc 81       	ldd	r31, Y+4	; 0x04
     e16:	81 e2       	ldi	r24, 0x21	; 33
     e18:	80 83       	st	Z, r24
	pxTopOfStack--;
     e1a:	8b 81       	ldd	r24, Y+3	; 0x03
     e1c:	9c 81       	ldd	r25, Y+4	; 0x04
     e1e:	01 97       	sbiw	r24, 0x01	; 1
     e20:	9c 83       	std	Y+4, r25	; 0x04
     e22:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     e24:	eb 81       	ldd	r30, Y+3	; 0x03
     e26:	fc 81       	ldd	r31, Y+4	; 0x04
     e28:	82 e2       	ldi	r24, 0x22	; 34
     e2a:	80 83       	st	Z, r24
	pxTopOfStack--;
     e2c:	8b 81       	ldd	r24, Y+3	; 0x03
     e2e:	9c 81       	ldd	r25, Y+4	; 0x04
     e30:	01 97       	sbiw	r24, 0x01	; 1
     e32:	9c 83       	std	Y+4, r25	; 0x04
     e34:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     e36:	eb 81       	ldd	r30, Y+3	; 0x03
     e38:	fc 81       	ldd	r31, Y+4	; 0x04
     e3a:	83 e2       	ldi	r24, 0x23	; 35
     e3c:	80 83       	st	Z, r24
	pxTopOfStack--;
     e3e:	8b 81       	ldd	r24, Y+3	; 0x03
     e40:	9c 81       	ldd	r25, Y+4	; 0x04
     e42:	01 97       	sbiw	r24, 0x01	; 1
     e44:	9c 83       	std	Y+4, r25	; 0x04
     e46:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
     e48:	8f 81       	ldd	r24, Y+7	; 0x07
     e4a:	98 85       	ldd	r25, Y+8	; 0x08
     e4c:	9a 83       	std	Y+2, r25	; 0x02
     e4e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     e50:	89 81       	ldd	r24, Y+1	; 0x01
     e52:	eb 81       	ldd	r30, Y+3	; 0x03
     e54:	fc 81       	ldd	r31, Y+4	; 0x04
     e56:	80 83       	st	Z, r24
	pxTopOfStack--;
     e58:	8b 81       	ldd	r24, Y+3	; 0x03
     e5a:	9c 81       	ldd	r25, Y+4	; 0x04
     e5c:	01 97       	sbiw	r24, 0x01	; 1
     e5e:	9c 83       	std	Y+4, r25	; 0x04
     e60:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     e62:	89 81       	ldd	r24, Y+1	; 0x01
     e64:	9a 81       	ldd	r25, Y+2	; 0x02
     e66:	89 2f       	mov	r24, r25
     e68:	99 27       	eor	r25, r25
     e6a:	9a 83       	std	Y+2, r25	; 0x02
     e6c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     e6e:	89 81       	ldd	r24, Y+1	; 0x01
     e70:	eb 81       	ldd	r30, Y+3	; 0x03
     e72:	fc 81       	ldd	r31, Y+4	; 0x04
     e74:	80 83       	st	Z, r24
	pxTopOfStack--;
     e76:	8b 81       	ldd	r24, Y+3	; 0x03
     e78:	9c 81       	ldd	r25, Y+4	; 0x04
     e7a:	01 97       	sbiw	r24, 0x01	; 1
     e7c:	9c 83       	std	Y+4, r25	; 0x04
     e7e:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     e80:	eb 81       	ldd	r30, Y+3	; 0x03
     e82:	fc 81       	ldd	r31, Y+4	; 0x04
     e84:	86 e2       	ldi	r24, 0x26	; 38
     e86:	80 83       	st	Z, r24
	pxTopOfStack--;
     e88:	8b 81       	ldd	r24, Y+3	; 0x03
     e8a:	9c 81       	ldd	r25, Y+4	; 0x04
     e8c:	01 97       	sbiw	r24, 0x01	; 1
     e8e:	9c 83       	std	Y+4, r25	; 0x04
     e90:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     e92:	eb 81       	ldd	r30, Y+3	; 0x03
     e94:	fc 81       	ldd	r31, Y+4	; 0x04
     e96:	87 e2       	ldi	r24, 0x27	; 39
     e98:	80 83       	st	Z, r24
	pxTopOfStack--;
     e9a:	8b 81       	ldd	r24, Y+3	; 0x03
     e9c:	9c 81       	ldd	r25, Y+4	; 0x04
     e9e:	01 97       	sbiw	r24, 0x01	; 1
     ea0:	9c 83       	std	Y+4, r25	; 0x04
     ea2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     ea4:	eb 81       	ldd	r30, Y+3	; 0x03
     ea6:	fc 81       	ldd	r31, Y+4	; 0x04
     ea8:	88 e2       	ldi	r24, 0x28	; 40
     eaa:	80 83       	st	Z, r24
	pxTopOfStack--;
     eac:	8b 81       	ldd	r24, Y+3	; 0x03
     eae:	9c 81       	ldd	r25, Y+4	; 0x04
     eb0:	01 97       	sbiw	r24, 0x01	; 1
     eb2:	9c 83       	std	Y+4, r25	; 0x04
     eb4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     eb6:	eb 81       	ldd	r30, Y+3	; 0x03
     eb8:	fc 81       	ldd	r31, Y+4	; 0x04
     eba:	89 e2       	ldi	r24, 0x29	; 41
     ebc:	80 83       	st	Z, r24
	pxTopOfStack--;
     ebe:	8b 81       	ldd	r24, Y+3	; 0x03
     ec0:	9c 81       	ldd	r25, Y+4	; 0x04
     ec2:	01 97       	sbiw	r24, 0x01	; 1
     ec4:	9c 83       	std	Y+4, r25	; 0x04
     ec6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     ec8:	eb 81       	ldd	r30, Y+3	; 0x03
     eca:	fc 81       	ldd	r31, Y+4	; 0x04
     ecc:	80 e3       	ldi	r24, 0x30	; 48
     ece:	80 83       	st	Z, r24
	pxTopOfStack--;
     ed0:	8b 81       	ldd	r24, Y+3	; 0x03
     ed2:	9c 81       	ldd	r25, Y+4	; 0x04
     ed4:	01 97       	sbiw	r24, 0x01	; 1
     ed6:	9c 83       	std	Y+4, r25	; 0x04
     ed8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     eda:	eb 81       	ldd	r30, Y+3	; 0x03
     edc:	fc 81       	ldd	r31, Y+4	; 0x04
     ede:	81 e3       	ldi	r24, 0x31	; 49
     ee0:	80 83       	st	Z, r24
	pxTopOfStack--;
     ee2:	8b 81       	ldd	r24, Y+3	; 0x03
     ee4:	9c 81       	ldd	r25, Y+4	; 0x04
     ee6:	01 97       	sbiw	r24, 0x01	; 1
     ee8:	9c 83       	std	Y+4, r25	; 0x04
     eea:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     eec:	8b 81       	ldd	r24, Y+3	; 0x03
     eee:	9c 81       	ldd	r25, Y+4	; 0x04
}
     ef0:	28 96       	adiw	r28, 0x08	; 8
     ef2:	0f b6       	in	r0, 0x3f	; 63
     ef4:	f8 94       	cli
     ef6:	de bf       	out	0x3e, r29	; 62
     ef8:	0f be       	out	0x3f, r0	; 63
     efa:	cd bf       	out	0x3d, r28	; 61
     efc:	cf 91       	pop	r28
     efe:	df 91       	pop	r29
     f00:	08 95       	ret

00000f02 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
     f02:	df 93       	push	r29
     f04:	cf 93       	push	r28
     f06:	cd b7       	in	r28, 0x3d	; 61
     f08:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     f0a:	0e 94 71 08 	call	0x10e2	; 0x10e2 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     f0e:	a0 91 16 03 	lds	r26, 0x0316
     f12:	b0 91 17 03 	lds	r27, 0x0317
     f16:	cd 91       	ld	r28, X+
     f18:	cd bf       	out	0x3d, r28	; 61
     f1a:	dd 91       	ld	r29, X+
     f1c:	de bf       	out	0x3e, r29	; 62
     f1e:	ff 91       	pop	r31
     f20:	ef 91       	pop	r30
     f22:	df 91       	pop	r29
     f24:	cf 91       	pop	r28
     f26:	bf 91       	pop	r27
     f28:	af 91       	pop	r26
     f2a:	9f 91       	pop	r25
     f2c:	8f 91       	pop	r24
     f2e:	7f 91       	pop	r23
     f30:	6f 91       	pop	r22
     f32:	5f 91       	pop	r21
     f34:	4f 91       	pop	r20
     f36:	3f 91       	pop	r19
     f38:	2f 91       	pop	r18
     f3a:	1f 91       	pop	r17
     f3c:	0f 91       	pop	r16
     f3e:	ff 90       	pop	r15
     f40:	ef 90       	pop	r14
     f42:	df 90       	pop	r13
     f44:	cf 90       	pop	r12
     f46:	bf 90       	pop	r11
     f48:	af 90       	pop	r10
     f4a:	9f 90       	pop	r9
     f4c:	8f 90       	pop	r8
     f4e:	7f 90       	pop	r7
     f50:	6f 90       	pop	r6
     f52:	5f 90       	pop	r5
     f54:	4f 90       	pop	r4
     f56:	3f 90       	pop	r3
     f58:	2f 90       	pop	r2
     f5a:	1f 90       	pop	r1
     f5c:	0f 90       	pop	r0
     f5e:	0f be       	out	0x3f, r0	; 63
     f60:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     f62:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     f64:	81 e0       	ldi	r24, 0x01	; 1
}
     f66:	cf 91       	pop	r28
     f68:	df 91       	pop	r29
     f6a:	08 95       	ret

00000f6c <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     f6c:	df 93       	push	r29
     f6e:	cf 93       	push	r28
     f70:	cd b7       	in	r28, 0x3d	; 61
     f72:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     f74:	cf 91       	pop	r28
     f76:	df 91       	pop	r29
     f78:	08 95       	ret

00000f7a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     f7a:	0f 92       	push	r0
     f7c:	0f b6       	in	r0, 0x3f	; 63
     f7e:	f8 94       	cli
     f80:	0f 92       	push	r0
     f82:	1f 92       	push	r1
     f84:	11 24       	eor	r1, r1
     f86:	2f 92       	push	r2
     f88:	3f 92       	push	r3
     f8a:	4f 92       	push	r4
     f8c:	5f 92       	push	r5
     f8e:	6f 92       	push	r6
     f90:	7f 92       	push	r7
     f92:	8f 92       	push	r8
     f94:	9f 92       	push	r9
     f96:	af 92       	push	r10
     f98:	bf 92       	push	r11
     f9a:	cf 92       	push	r12
     f9c:	df 92       	push	r13
     f9e:	ef 92       	push	r14
     fa0:	ff 92       	push	r15
     fa2:	0f 93       	push	r16
     fa4:	1f 93       	push	r17
     fa6:	2f 93       	push	r18
     fa8:	3f 93       	push	r19
     faa:	4f 93       	push	r20
     fac:	5f 93       	push	r21
     fae:	6f 93       	push	r22
     fb0:	7f 93       	push	r23
     fb2:	8f 93       	push	r24
     fb4:	9f 93       	push	r25
     fb6:	af 93       	push	r26
     fb8:	bf 93       	push	r27
     fba:	cf 93       	push	r28
     fbc:	df 93       	push	r29
     fbe:	ef 93       	push	r30
     fc0:	ff 93       	push	r31
     fc2:	a0 91 16 03 	lds	r26, 0x0316
     fc6:	b0 91 17 03 	lds	r27, 0x0317
     fca:	0d b6       	in	r0, 0x3d	; 61
     fcc:	0d 92       	st	X+, r0
     fce:	0e b6       	in	r0, 0x3e	; 62
     fd0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     fd2:	0e 94 2d 11 	call	0x225a	; 0x225a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     fd6:	a0 91 16 03 	lds	r26, 0x0316
     fda:	b0 91 17 03 	lds	r27, 0x0317
     fde:	cd 91       	ld	r28, X+
     fe0:	cd bf       	out	0x3d, r28	; 61
     fe2:	dd 91       	ld	r29, X+
     fe4:	de bf       	out	0x3e, r29	; 62
     fe6:	ff 91       	pop	r31
     fe8:	ef 91       	pop	r30
     fea:	df 91       	pop	r29
     fec:	cf 91       	pop	r28
     fee:	bf 91       	pop	r27
     ff0:	af 91       	pop	r26
     ff2:	9f 91       	pop	r25
     ff4:	8f 91       	pop	r24
     ff6:	7f 91       	pop	r23
     ff8:	6f 91       	pop	r22
     ffa:	5f 91       	pop	r21
     ffc:	4f 91       	pop	r20
     ffe:	3f 91       	pop	r19
    1000:	2f 91       	pop	r18
    1002:	1f 91       	pop	r17
    1004:	0f 91       	pop	r16
    1006:	ff 90       	pop	r15
    1008:	ef 90       	pop	r14
    100a:	df 90       	pop	r13
    100c:	cf 90       	pop	r12
    100e:	bf 90       	pop	r11
    1010:	af 90       	pop	r10
    1012:	9f 90       	pop	r9
    1014:	8f 90       	pop	r8
    1016:	7f 90       	pop	r7
    1018:	6f 90       	pop	r6
    101a:	5f 90       	pop	r5
    101c:	4f 90       	pop	r4
    101e:	3f 90       	pop	r3
    1020:	2f 90       	pop	r2
    1022:	1f 90       	pop	r1
    1024:	0f 90       	pop	r0
    1026:	0f be       	out	0x3f, r0	; 63
    1028:	0f 90       	pop	r0

	asm volatile ( "ret" );
    102a:	08 95       	ret

0000102c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    102c:	0f 92       	push	r0
    102e:	0f b6       	in	r0, 0x3f	; 63
    1030:	f8 94       	cli
    1032:	0f 92       	push	r0
    1034:	1f 92       	push	r1
    1036:	11 24       	eor	r1, r1
    1038:	2f 92       	push	r2
    103a:	3f 92       	push	r3
    103c:	4f 92       	push	r4
    103e:	5f 92       	push	r5
    1040:	6f 92       	push	r6
    1042:	7f 92       	push	r7
    1044:	8f 92       	push	r8
    1046:	9f 92       	push	r9
    1048:	af 92       	push	r10
    104a:	bf 92       	push	r11
    104c:	cf 92       	push	r12
    104e:	df 92       	push	r13
    1050:	ef 92       	push	r14
    1052:	ff 92       	push	r15
    1054:	0f 93       	push	r16
    1056:	1f 93       	push	r17
    1058:	2f 93       	push	r18
    105a:	3f 93       	push	r19
    105c:	4f 93       	push	r20
    105e:	5f 93       	push	r21
    1060:	6f 93       	push	r22
    1062:	7f 93       	push	r23
    1064:	8f 93       	push	r24
    1066:	9f 93       	push	r25
    1068:	af 93       	push	r26
    106a:	bf 93       	push	r27
    106c:	cf 93       	push	r28
    106e:	df 93       	push	r29
    1070:	ef 93       	push	r30
    1072:	ff 93       	push	r31
    1074:	a0 91 16 03 	lds	r26, 0x0316
    1078:	b0 91 17 03 	lds	r27, 0x0317
    107c:	0d b6       	in	r0, 0x3d	; 61
    107e:	0d 92       	st	X+, r0
    1080:	0e b6       	in	r0, 0x3e	; 62
    1082:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1084:	0e 94 58 10 	call	0x20b0	; 0x20b0 <vTaskIncrementTick>
	vTaskSwitchContext();
    1088:	0e 94 2d 11 	call	0x225a	; 0x225a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    108c:	a0 91 16 03 	lds	r26, 0x0316
    1090:	b0 91 17 03 	lds	r27, 0x0317
    1094:	cd 91       	ld	r28, X+
    1096:	cd bf       	out	0x3d, r28	; 61
    1098:	dd 91       	ld	r29, X+
    109a:	de bf       	out	0x3e, r29	; 62
    109c:	ff 91       	pop	r31
    109e:	ef 91       	pop	r30
    10a0:	df 91       	pop	r29
    10a2:	cf 91       	pop	r28
    10a4:	bf 91       	pop	r27
    10a6:	af 91       	pop	r26
    10a8:	9f 91       	pop	r25
    10aa:	8f 91       	pop	r24
    10ac:	7f 91       	pop	r23
    10ae:	6f 91       	pop	r22
    10b0:	5f 91       	pop	r21
    10b2:	4f 91       	pop	r20
    10b4:	3f 91       	pop	r19
    10b6:	2f 91       	pop	r18
    10b8:	1f 91       	pop	r17
    10ba:	0f 91       	pop	r16
    10bc:	ff 90       	pop	r15
    10be:	ef 90       	pop	r14
    10c0:	df 90       	pop	r13
    10c2:	cf 90       	pop	r12
    10c4:	bf 90       	pop	r11
    10c6:	af 90       	pop	r10
    10c8:	9f 90       	pop	r9
    10ca:	8f 90       	pop	r8
    10cc:	7f 90       	pop	r7
    10ce:	6f 90       	pop	r6
    10d0:	5f 90       	pop	r5
    10d2:	4f 90       	pop	r4
    10d4:	3f 90       	pop	r3
    10d6:	2f 90       	pop	r2
    10d8:	1f 90       	pop	r1
    10da:	0f 90       	pop	r0
    10dc:	0f be       	out	0x3f, r0	; 63
    10de:	0f 90       	pop	r0

	asm volatile ( "ret" );
    10e0:	08 95       	ret

000010e2 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    10e2:	df 93       	push	r29
    10e4:	cf 93       	push	r28
    10e6:	00 d0       	rcall	.+0      	; 0x10e8 <prvSetupTimerInterrupt+0x6>
    10e8:	00 d0       	rcall	.+0      	; 0x10ea <prvSetupTimerInterrupt+0x8>
    10ea:	00 d0       	rcall	.+0      	; 0x10ec <prvSetupTimerInterrupt+0xa>
    10ec:	cd b7       	in	r28, 0x3d	; 61
    10ee:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    10f0:	80 e4       	ldi	r24, 0x40	; 64
    10f2:	9f e1       	ldi	r25, 0x1F	; 31
    10f4:	a0 e0       	ldi	r26, 0x00	; 0
    10f6:	b0 e0       	ldi	r27, 0x00	; 0
    10f8:	8b 83       	std	Y+3, r24	; 0x03
    10fa:	9c 83       	std	Y+4, r25	; 0x04
    10fc:	ad 83       	std	Y+5, r26	; 0x05
    10fe:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1100:	8b 81       	ldd	r24, Y+3	; 0x03
    1102:	9c 81       	ldd	r25, Y+4	; 0x04
    1104:	ad 81       	ldd	r26, Y+5	; 0x05
    1106:	be 81       	ldd	r27, Y+6	; 0x06
    1108:	68 94       	set
    110a:	15 f8       	bld	r1, 5
    110c:	b6 95       	lsr	r27
    110e:	a7 95       	ror	r26
    1110:	97 95       	ror	r25
    1112:	87 95       	ror	r24
    1114:	16 94       	lsr	r1
    1116:	d1 f7       	brne	.-12     	; 0x110c <prvSetupTimerInterrupt+0x2a>
    1118:	8b 83       	std	Y+3, r24	; 0x03
    111a:	9c 83       	std	Y+4, r25	; 0x04
    111c:	ad 83       	std	Y+5, r26	; 0x05
    111e:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    1120:	8b 81       	ldd	r24, Y+3	; 0x03
    1122:	9c 81       	ldd	r25, Y+4	; 0x04
    1124:	ad 81       	ldd	r26, Y+5	; 0x05
    1126:	be 81       	ldd	r27, Y+6	; 0x06
    1128:	01 97       	sbiw	r24, 0x01	; 1
    112a:	a1 09       	sbc	r26, r1
    112c:	b1 09       	sbc	r27, r1
    112e:	8b 83       	std	Y+3, r24	; 0x03
    1130:	9c 83       	std	Y+4, r25	; 0x04
    1132:	ad 83       	std	Y+5, r26	; 0x05
    1134:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1136:	8b 81       	ldd	r24, Y+3	; 0x03
    1138:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    113a:	8b 81       	ldd	r24, Y+3	; 0x03
    113c:	9c 81       	ldd	r25, Y+4	; 0x04
    113e:	ad 81       	ldd	r26, Y+5	; 0x05
    1140:	be 81       	ldd	r27, Y+6	; 0x06
    1142:	89 2f       	mov	r24, r25
    1144:	9a 2f       	mov	r25, r26
    1146:	ab 2f       	mov	r26, r27
    1148:	bb 27       	eor	r27, r27
    114a:	8b 83       	std	Y+3, r24	; 0x03
    114c:	9c 83       	std	Y+4, r25	; 0x04
    114e:	ad 83       	std	Y+5, r26	; 0x05
    1150:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1152:	8b 81       	ldd	r24, Y+3	; 0x03
    1154:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1156:	eb e4       	ldi	r30, 0x4B	; 75
    1158:	f0 e0       	ldi	r31, 0x00	; 0
    115a:	8a 81       	ldd	r24, Y+2	; 0x02
    115c:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    115e:	ea e4       	ldi	r30, 0x4A	; 74
    1160:	f0 e0       	ldi	r31, 0x00	; 0
    1162:	89 81       	ldd	r24, Y+1	; 0x01
    1164:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1166:	8b e0       	ldi	r24, 0x0B	; 11
    1168:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    116a:	ee e4       	ldi	r30, 0x4E	; 78
    116c:	f0 e0       	ldi	r31, 0x00	; 0
    116e:	89 81       	ldd	r24, Y+1	; 0x01
    1170:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1172:	e9 e5       	ldi	r30, 0x59	; 89
    1174:	f0 e0       	ldi	r31, 0x00	; 0
    1176:	80 81       	ld	r24, Z
    1178:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    117a:	89 81       	ldd	r24, Y+1	; 0x01
    117c:	80 61       	ori	r24, 0x10	; 16
    117e:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1180:	e9 e5       	ldi	r30, 0x59	; 89
    1182:	f0 e0       	ldi	r31, 0x00	; 0
    1184:	89 81       	ldd	r24, Y+1	; 0x01
    1186:	80 83       	st	Z, r24
}
    1188:	26 96       	adiw	r28, 0x06	; 6
    118a:	0f b6       	in	r0, 0x3f	; 63
    118c:	f8 94       	cli
    118e:	de bf       	out	0x3e, r29	; 62
    1190:	0f be       	out	0x3f, r0	; 63
    1192:	cd bf       	out	0x3d, r28	; 61
    1194:	cf 91       	pop	r28
    1196:	df 91       	pop	r29
    1198:	08 95       	ret

0000119a <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    119a:	0e 94 16 08 	call	0x102c	; 0x102c <vPortYieldFromTick>
		asm volatile ( "reti" );
    119e:	18 95       	reti

000011a0 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    11a0:	df 93       	push	r29
    11a2:	cf 93       	push	r28
    11a4:	cd b7       	in	r28, 0x3d	; 61
    11a6:	de b7       	in	r29, 0x3e	; 62
    11a8:	28 97       	sbiw	r28, 0x08	; 8
    11aa:	0f b6       	in	r0, 0x3f	; 63
    11ac:	f8 94       	cli
    11ae:	de bf       	out	0x3e, r29	; 62
    11b0:	0f be       	out	0x3f, r0	; 63
    11b2:	cd bf       	out	0x3d, r28	; 61
    11b4:	8f 83       	std	Y+7, r24	; 0x07
    11b6:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    11b8:	1a 82       	std	Y+2, r1	; 0x02
    11ba:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    11bc:	8f 81       	ldd	r24, Y+7	; 0x07
    11be:	88 23       	and	r24, r24
    11c0:	09 f4       	brne	.+2      	; 0x11c4 <xQueueCreate+0x24>
    11c2:	8c c0       	rjmp	.+280    	; 0x12dc <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    11c4:	8f e1       	ldi	r24, 0x1F	; 31
    11c6:	90 e0       	ldi	r25, 0x00	; 0
    11c8:	0e 94 57 04 	call	0x8ae	; 0x8ae <pvPortMalloc>
    11cc:	9e 83       	std	Y+6, r25	; 0x06
    11ce:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    11d0:	8d 81       	ldd	r24, Y+5	; 0x05
    11d2:	9e 81       	ldd	r25, Y+6	; 0x06
    11d4:	00 97       	sbiw	r24, 0x00	; 0
    11d6:	09 f4       	brne	.+2      	; 0x11da <xQueueCreate+0x3a>
    11d8:	81 c0       	rjmp	.+258    	; 0x12dc <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    11da:	8f 81       	ldd	r24, Y+7	; 0x07
    11dc:	28 2f       	mov	r18, r24
    11de:	30 e0       	ldi	r19, 0x00	; 0
    11e0:	88 85       	ldd	r24, Y+8	; 0x08
    11e2:	88 2f       	mov	r24, r24
    11e4:	90 e0       	ldi	r25, 0x00	; 0
    11e6:	ac 01       	movw	r20, r24
    11e8:	24 9f       	mul	r18, r20
    11ea:	c0 01       	movw	r24, r0
    11ec:	25 9f       	mul	r18, r21
    11ee:	90 0d       	add	r25, r0
    11f0:	34 9f       	mul	r19, r20
    11f2:	90 0d       	add	r25, r0
    11f4:	11 24       	eor	r1, r1
    11f6:	01 96       	adiw	r24, 0x01	; 1
    11f8:	9c 83       	std	Y+4, r25	; 0x04
    11fa:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    11fc:	8b 81       	ldd	r24, Y+3	; 0x03
    11fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1200:	0e 94 57 04 	call	0x8ae	; 0x8ae <pvPortMalloc>
    1204:	ed 81       	ldd	r30, Y+5	; 0x05
    1206:	fe 81       	ldd	r31, Y+6	; 0x06
    1208:	91 83       	std	Z+1, r25	; 0x01
    120a:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    120c:	ed 81       	ldd	r30, Y+5	; 0x05
    120e:	fe 81       	ldd	r31, Y+6	; 0x06
    1210:	80 81       	ld	r24, Z
    1212:	91 81       	ldd	r25, Z+1	; 0x01
    1214:	00 97       	sbiw	r24, 0x00	; 0
    1216:	09 f4       	brne	.+2      	; 0x121a <xQueueCreate+0x7a>
    1218:	5d c0       	rjmp	.+186    	; 0x12d4 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    121a:	ed 81       	ldd	r30, Y+5	; 0x05
    121c:	fe 81       	ldd	r31, Y+6	; 0x06
    121e:	40 81       	ld	r20, Z
    1220:	51 81       	ldd	r21, Z+1	; 0x01
    1222:	8f 81       	ldd	r24, Y+7	; 0x07
    1224:	28 2f       	mov	r18, r24
    1226:	30 e0       	ldi	r19, 0x00	; 0
    1228:	88 85       	ldd	r24, Y+8	; 0x08
    122a:	88 2f       	mov	r24, r24
    122c:	90 e0       	ldi	r25, 0x00	; 0
    122e:	bc 01       	movw	r22, r24
    1230:	26 9f       	mul	r18, r22
    1232:	c0 01       	movw	r24, r0
    1234:	27 9f       	mul	r18, r23
    1236:	90 0d       	add	r25, r0
    1238:	36 9f       	mul	r19, r22
    123a:	90 0d       	add	r25, r0
    123c:	11 24       	eor	r1, r1
    123e:	84 0f       	add	r24, r20
    1240:	95 1f       	adc	r25, r21
    1242:	ed 81       	ldd	r30, Y+5	; 0x05
    1244:	fe 81       	ldd	r31, Y+6	; 0x06
    1246:	93 83       	std	Z+3, r25	; 0x03
    1248:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    124a:	ed 81       	ldd	r30, Y+5	; 0x05
    124c:	fe 81       	ldd	r31, Y+6	; 0x06
    124e:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1250:	ed 81       	ldd	r30, Y+5	; 0x05
    1252:	fe 81       	ldd	r31, Y+6	; 0x06
    1254:	80 81       	ld	r24, Z
    1256:	91 81       	ldd	r25, Z+1	; 0x01
    1258:	ed 81       	ldd	r30, Y+5	; 0x05
    125a:	fe 81       	ldd	r31, Y+6	; 0x06
    125c:	95 83       	std	Z+5, r25	; 0x05
    125e:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    1260:	ed 81       	ldd	r30, Y+5	; 0x05
    1262:	fe 81       	ldd	r31, Y+6	; 0x06
    1264:	40 81       	ld	r20, Z
    1266:	51 81       	ldd	r21, Z+1	; 0x01
    1268:	8f 81       	ldd	r24, Y+7	; 0x07
    126a:	88 2f       	mov	r24, r24
    126c:	90 e0       	ldi	r25, 0x00	; 0
    126e:	9c 01       	movw	r18, r24
    1270:	21 50       	subi	r18, 0x01	; 1
    1272:	30 40       	sbci	r19, 0x00	; 0
    1274:	88 85       	ldd	r24, Y+8	; 0x08
    1276:	88 2f       	mov	r24, r24
    1278:	90 e0       	ldi	r25, 0x00	; 0
    127a:	bc 01       	movw	r22, r24
    127c:	26 9f       	mul	r18, r22
    127e:	c0 01       	movw	r24, r0
    1280:	27 9f       	mul	r18, r23
    1282:	90 0d       	add	r25, r0
    1284:	36 9f       	mul	r19, r22
    1286:	90 0d       	add	r25, r0
    1288:	11 24       	eor	r1, r1
    128a:	84 0f       	add	r24, r20
    128c:	95 1f       	adc	r25, r21
    128e:	ed 81       	ldd	r30, Y+5	; 0x05
    1290:	fe 81       	ldd	r31, Y+6	; 0x06
    1292:	97 83       	std	Z+7, r25	; 0x07
    1294:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    1296:	ed 81       	ldd	r30, Y+5	; 0x05
    1298:	fe 81       	ldd	r31, Y+6	; 0x06
    129a:	8f 81       	ldd	r24, Y+7	; 0x07
    129c:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    129e:	ed 81       	ldd	r30, Y+5	; 0x05
    12a0:	fe 81       	ldd	r31, Y+6	; 0x06
    12a2:	88 85       	ldd	r24, Y+8	; 0x08
    12a4:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    12a6:	ed 81       	ldd	r30, Y+5	; 0x05
    12a8:	fe 81       	ldd	r31, Y+6	; 0x06
    12aa:	8f ef       	ldi	r24, 0xFF	; 255
    12ac:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    12ae:	ed 81       	ldd	r30, Y+5	; 0x05
    12b0:	fe 81       	ldd	r31, Y+6	; 0x06
    12b2:	8f ef       	ldi	r24, 0xFF	; 255
    12b4:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    12b6:	8d 81       	ldd	r24, Y+5	; 0x05
    12b8:	9e 81       	ldd	r25, Y+6	; 0x06
    12ba:	08 96       	adiw	r24, 0x08	; 8
    12bc:	0e 94 c3 04 	call	0x986	; 0x986 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    12c0:	8d 81       	ldd	r24, Y+5	; 0x05
    12c2:	9e 81       	ldd	r25, Y+6	; 0x06
    12c4:	41 96       	adiw	r24, 0x11	; 17
    12c6:	0e 94 c3 04 	call	0x986	; 0x986 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    12ca:	8d 81       	ldd	r24, Y+5	; 0x05
    12cc:	9e 81       	ldd	r25, Y+6	; 0x06
    12ce:	9a 83       	std	Y+2, r25	; 0x02
    12d0:	89 83       	std	Y+1, r24	; 0x01
    12d2:	04 c0       	rjmp	.+8      	; 0x12dc <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    12d4:	8d 81       	ldd	r24, Y+5	; 0x05
    12d6:	9e 81       	ldd	r25, Y+6	; 0x06
    12d8:	0e 94 9d 04 	call	0x93a	; 0x93a <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    12dc:	89 81       	ldd	r24, Y+1	; 0x01
    12de:	9a 81       	ldd	r25, Y+2	; 0x02
}
    12e0:	28 96       	adiw	r28, 0x08	; 8
    12e2:	0f b6       	in	r0, 0x3f	; 63
    12e4:	f8 94       	cli
    12e6:	de bf       	out	0x3e, r29	; 62
    12e8:	0f be       	out	0x3f, r0	; 63
    12ea:	cd bf       	out	0x3d, r28	; 61
    12ec:	cf 91       	pop	r28
    12ee:	df 91       	pop	r29
    12f0:	08 95       	ret

000012f2 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    12f2:	df 93       	push	r29
    12f4:	cf 93       	push	r28
    12f6:	cd b7       	in	r28, 0x3d	; 61
    12f8:	de b7       	in	r29, 0x3e	; 62
    12fa:	2c 97       	sbiw	r28, 0x0c	; 12
    12fc:	0f b6       	in	r0, 0x3f	; 63
    12fe:	f8 94       	cli
    1300:	de bf       	out	0x3e, r29	; 62
    1302:	0f be       	out	0x3f, r0	; 63
    1304:	cd bf       	out	0x3d, r28	; 61
    1306:	9e 83       	std	Y+6, r25	; 0x06
    1308:	8d 83       	std	Y+5, r24	; 0x05
    130a:	78 87       	std	Y+8, r23	; 0x08
    130c:	6f 83       	std	Y+7, r22	; 0x07
    130e:	5a 87       	std	Y+10, r21	; 0x0a
    1310:	49 87       	std	Y+9, r20	; 0x09
    1312:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1314:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1316:	0f b6       	in	r0, 0x3f	; 63
    1318:	f8 94       	cli
    131a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    131c:	ed 81       	ldd	r30, Y+5	; 0x05
    131e:	fe 81       	ldd	r31, Y+6	; 0x06
    1320:	92 8d       	ldd	r25, Z+26	; 0x1a
    1322:	ed 81       	ldd	r30, Y+5	; 0x05
    1324:	fe 81       	ldd	r31, Y+6	; 0x06
    1326:	83 8d       	ldd	r24, Z+27	; 0x1b
    1328:	98 17       	cp	r25, r24
    132a:	d8 f4       	brcc	.+54     	; 0x1362 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    132c:	8d 81       	ldd	r24, Y+5	; 0x05
    132e:	9e 81       	ldd	r25, Y+6	; 0x06
    1330:	2f 81       	ldd	r18, Y+7	; 0x07
    1332:	38 85       	ldd	r19, Y+8	; 0x08
    1334:	b9 01       	movw	r22, r18
    1336:	4b 85       	ldd	r20, Y+11	; 0x0b
    1338:	0e 94 b4 0b 	call	0x1768	; 0x1768 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    133c:	ed 81       	ldd	r30, Y+5	; 0x05
    133e:	fe 81       	ldd	r31, Y+6	; 0x06
    1340:	81 89       	ldd	r24, Z+17	; 0x11
    1342:	88 23       	and	r24, r24
    1344:	49 f0       	breq	.+18     	; 0x1358 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1346:	8d 81       	ldd	r24, Y+5	; 0x05
    1348:	9e 81       	ldd	r25, Y+6	; 0x06
    134a:	41 96       	adiw	r24, 0x11	; 17
    134c:	0e 94 c9 11 	call	0x2392	; 0x2392 <xTaskRemoveFromEventList>
    1350:	81 30       	cpi	r24, 0x01	; 1
    1352:	11 f4       	brne	.+4      	; 0x1358 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1354:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1358:	0f 90       	pop	r0
    135a:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    135c:	81 e0       	ldi	r24, 0x01	; 1
    135e:	8c 87       	std	Y+12, r24	; 0x0c
    1360:	5c c0       	rjmp	.+184    	; 0x141a <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1362:	89 85       	ldd	r24, Y+9	; 0x09
    1364:	9a 85       	ldd	r25, Y+10	; 0x0a
    1366:	00 97       	sbiw	r24, 0x00	; 0
    1368:	21 f4       	brne	.+8      	; 0x1372 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    136a:	0f 90       	pop	r0
    136c:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    136e:	1c 86       	std	Y+12, r1	; 0x0c
    1370:	54 c0       	rjmp	.+168    	; 0x141a <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    1372:	89 81       	ldd	r24, Y+1	; 0x01
    1374:	88 23       	and	r24, r24
    1376:	31 f4       	brne	.+12     	; 0x1384 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1378:	ce 01       	movw	r24, r28
    137a:	02 96       	adiw	r24, 0x02	; 2
    137c:	0e 94 31 12 	call	0x2462	; 0x2462 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1380:	81 e0       	ldi	r24, 0x01	; 1
    1382:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1384:	0f 90       	pop	r0
    1386:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1388:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    138c:	0f b6       	in	r0, 0x3f	; 63
    138e:	f8 94       	cli
    1390:	0f 92       	push	r0
    1392:	ed 81       	ldd	r30, Y+5	; 0x05
    1394:	fe 81       	ldd	r31, Y+6	; 0x06
    1396:	85 8d       	ldd	r24, Z+29	; 0x1d
    1398:	8f 3f       	cpi	r24, 0xFF	; 255
    139a:	19 f4       	brne	.+6      	; 0x13a2 <xQueueGenericSend+0xb0>
    139c:	ed 81       	ldd	r30, Y+5	; 0x05
    139e:	fe 81       	ldd	r31, Y+6	; 0x06
    13a0:	15 8e       	std	Z+29, r1	; 0x1d
    13a2:	ed 81       	ldd	r30, Y+5	; 0x05
    13a4:	fe 81       	ldd	r31, Y+6	; 0x06
    13a6:	86 8d       	ldd	r24, Z+30	; 0x1e
    13a8:	8f 3f       	cpi	r24, 0xFF	; 255
    13aa:	19 f4       	brne	.+6      	; 0x13b2 <xQueueGenericSend+0xc0>
    13ac:	ed 81       	ldd	r30, Y+5	; 0x05
    13ae:	fe 81       	ldd	r31, Y+6	; 0x06
    13b0:	16 8e       	std	Z+30, r1	; 0x1e
    13b2:	0f 90       	pop	r0
    13b4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    13b6:	ce 01       	movw	r24, r28
    13b8:	02 96       	adiw	r24, 0x02	; 2
    13ba:	9e 01       	movw	r18, r28
    13bc:	27 5f       	subi	r18, 0xF7	; 247
    13be:	3f 4f       	sbci	r19, 0xFF	; 255
    13c0:	b9 01       	movw	r22, r18
    13c2:	0e 94 4a 12 	call	0x2494	; 0x2494 <xTaskCheckForTimeOut>
    13c6:	88 23       	and	r24, r24
    13c8:	09 f5       	brne	.+66     	; 0x140c <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    13ca:	8d 81       	ldd	r24, Y+5	; 0x05
    13cc:	9e 81       	ldd	r25, Y+6	; 0x06
    13ce:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <prvIsQueueFull>
    13d2:	88 23       	and	r24, r24
    13d4:	a1 f0       	breq	.+40     	; 0x13fe <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    13d6:	8d 81       	ldd	r24, Y+5	; 0x05
    13d8:	9e 81       	ldd	r25, Y+6	; 0x06
    13da:	08 96       	adiw	r24, 0x08	; 8
    13dc:	29 85       	ldd	r18, Y+9	; 0x09
    13de:	3a 85       	ldd	r19, Y+10	; 0x0a
    13e0:	b9 01       	movw	r22, r18
    13e2:	0e 94 93 11 	call	0x2326	; 0x2326 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    13e6:	8d 81       	ldd	r24, Y+5	; 0x05
    13e8:	9e 81       	ldd	r25, Y+6	; 0x06
    13ea:	0e 94 91 0c 	call	0x1922	; 0x1922 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    13ee:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <xTaskResumeAll>
    13f2:	88 23       	and	r24, r24
    13f4:	09 f0       	breq	.+2      	; 0x13f8 <xQueueGenericSend+0x106>
    13f6:	8f cf       	rjmp	.-226    	; 0x1316 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    13f8:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vPortYield>
    13fc:	8c cf       	rjmp	.-232    	; 0x1316 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    13fe:	8d 81       	ldd	r24, Y+5	; 0x05
    1400:	9e 81       	ldd	r25, Y+6	; 0x06
    1402:	0e 94 91 0c 	call	0x1922	; 0x1922 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1406:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <xTaskResumeAll>
    140a:	85 cf       	rjmp	.-246    	; 0x1316 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    140c:	8d 81       	ldd	r24, Y+5	; 0x05
    140e:	9e 81       	ldd	r25, Y+6	; 0x06
    1410:	0e 94 91 0c 	call	0x1922	; 0x1922 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1414:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1418:	1c 86       	std	Y+12, r1	; 0x0c
    141a:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    141c:	2c 96       	adiw	r28, 0x0c	; 12
    141e:	0f b6       	in	r0, 0x3f	; 63
    1420:	f8 94       	cli
    1422:	de bf       	out	0x3e, r29	; 62
    1424:	0f be       	out	0x3f, r0	; 63
    1426:	cd bf       	out	0x3d, r28	; 61
    1428:	cf 91       	pop	r28
    142a:	df 91       	pop	r29
    142c:	08 95       	ret

0000142e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    142e:	df 93       	push	r29
    1430:	cf 93       	push	r28
    1432:	cd b7       	in	r28, 0x3d	; 61
    1434:	de b7       	in	r29, 0x3e	; 62
    1436:	29 97       	sbiw	r28, 0x09	; 9
    1438:	0f b6       	in	r0, 0x3f	; 63
    143a:	f8 94       	cli
    143c:	de bf       	out	0x3e, r29	; 62
    143e:	0f be       	out	0x3f, r0	; 63
    1440:	cd bf       	out	0x3d, r28	; 61
    1442:	9c 83       	std	Y+4, r25	; 0x04
    1444:	8b 83       	std	Y+3, r24	; 0x03
    1446:	7e 83       	std	Y+6, r23	; 0x06
    1448:	6d 83       	std	Y+5, r22	; 0x05
    144a:	58 87       	std	Y+8, r21	; 0x08
    144c:	4f 83       	std	Y+7, r20	; 0x07
    144e:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1450:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1452:	eb 81       	ldd	r30, Y+3	; 0x03
    1454:	fc 81       	ldd	r31, Y+4	; 0x04
    1456:	92 8d       	ldd	r25, Z+26	; 0x1a
    1458:	eb 81       	ldd	r30, Y+3	; 0x03
    145a:	fc 81       	ldd	r31, Y+4	; 0x04
    145c:	83 8d       	ldd	r24, Z+27	; 0x1b
    145e:	98 17       	cp	r25, r24
    1460:	40 f5       	brcc	.+80     	; 0x14b2 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1462:	8b 81       	ldd	r24, Y+3	; 0x03
    1464:	9c 81       	ldd	r25, Y+4	; 0x04
    1466:	2d 81       	ldd	r18, Y+5	; 0x05
    1468:	3e 81       	ldd	r19, Y+6	; 0x06
    146a:	b9 01       	movw	r22, r18
    146c:	49 85       	ldd	r20, Y+9	; 0x09
    146e:	0e 94 b4 0b 	call	0x1768	; 0x1768 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1472:	eb 81       	ldd	r30, Y+3	; 0x03
    1474:	fc 81       	ldd	r31, Y+4	; 0x04
    1476:	86 8d       	ldd	r24, Z+30	; 0x1e
    1478:	8f 3f       	cpi	r24, 0xFF	; 255
    147a:	89 f4       	brne	.+34     	; 0x149e <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    147c:	eb 81       	ldd	r30, Y+3	; 0x03
    147e:	fc 81       	ldd	r31, Y+4	; 0x04
    1480:	81 89       	ldd	r24, Z+17	; 0x11
    1482:	88 23       	and	r24, r24
    1484:	99 f0       	breq	.+38     	; 0x14ac <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1486:	8b 81       	ldd	r24, Y+3	; 0x03
    1488:	9c 81       	ldd	r25, Y+4	; 0x04
    148a:	41 96       	adiw	r24, 0x11	; 17
    148c:	0e 94 c9 11 	call	0x2392	; 0x2392 <xTaskRemoveFromEventList>
    1490:	88 23       	and	r24, r24
    1492:	61 f0       	breq	.+24     	; 0x14ac <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1494:	ef 81       	ldd	r30, Y+7	; 0x07
    1496:	f8 85       	ldd	r31, Y+8	; 0x08
    1498:	81 e0       	ldi	r24, 0x01	; 1
    149a:	80 83       	st	Z, r24
    149c:	07 c0       	rjmp	.+14     	; 0x14ac <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    149e:	eb 81       	ldd	r30, Y+3	; 0x03
    14a0:	fc 81       	ldd	r31, Y+4	; 0x04
    14a2:	86 8d       	ldd	r24, Z+30	; 0x1e
    14a4:	8f 5f       	subi	r24, 0xFF	; 255
    14a6:	eb 81       	ldd	r30, Y+3	; 0x03
    14a8:	fc 81       	ldd	r31, Y+4	; 0x04
    14aa:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    14ac:	81 e0       	ldi	r24, 0x01	; 1
    14ae:	8a 83       	std	Y+2, r24	; 0x02
    14b0:	01 c0       	rjmp	.+2      	; 0x14b4 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    14b2:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    14b4:	8a 81       	ldd	r24, Y+2	; 0x02
}
    14b6:	29 96       	adiw	r28, 0x09	; 9
    14b8:	0f b6       	in	r0, 0x3f	; 63
    14ba:	f8 94       	cli
    14bc:	de bf       	out	0x3e, r29	; 62
    14be:	0f be       	out	0x3f, r0	; 63
    14c0:	cd bf       	out	0x3d, r28	; 61
    14c2:	cf 91       	pop	r28
    14c4:	df 91       	pop	r29
    14c6:	08 95       	ret

000014c8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    14c8:	df 93       	push	r29
    14ca:	cf 93       	push	r28
    14cc:	cd b7       	in	r28, 0x3d	; 61
    14ce:	de b7       	in	r29, 0x3e	; 62
    14d0:	2e 97       	sbiw	r28, 0x0e	; 14
    14d2:	0f b6       	in	r0, 0x3f	; 63
    14d4:	f8 94       	cli
    14d6:	de bf       	out	0x3e, r29	; 62
    14d8:	0f be       	out	0x3f, r0	; 63
    14da:	cd bf       	out	0x3d, r28	; 61
    14dc:	98 87       	std	Y+8, r25	; 0x08
    14de:	8f 83       	std	Y+7, r24	; 0x07
    14e0:	7a 87       	std	Y+10, r23	; 0x0a
    14e2:	69 87       	std	Y+9, r22	; 0x09
    14e4:	5c 87       	std	Y+12, r21	; 0x0c
    14e6:	4b 87       	std	Y+11, r20	; 0x0b
    14e8:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    14ea:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    14ec:	0f b6       	in	r0, 0x3f	; 63
    14ee:	f8 94       	cli
    14f0:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    14f2:	ef 81       	ldd	r30, Y+7	; 0x07
    14f4:	f8 85       	ldd	r31, Y+8	; 0x08
    14f6:	82 8d       	ldd	r24, Z+26	; 0x1a
    14f8:	88 23       	and	r24, r24
    14fa:	09 f4       	brne	.+2      	; 0x14fe <xQueueGenericReceive+0x36>
    14fc:	3f c0       	rjmp	.+126    	; 0x157c <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    14fe:	ef 81       	ldd	r30, Y+7	; 0x07
    1500:	f8 85       	ldd	r31, Y+8	; 0x08
    1502:	86 81       	ldd	r24, Z+6	; 0x06
    1504:	97 81       	ldd	r25, Z+7	; 0x07
    1506:	9a 83       	std	Y+2, r25	; 0x02
    1508:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    150a:	8f 81       	ldd	r24, Y+7	; 0x07
    150c:	98 85       	ldd	r25, Y+8	; 0x08
    150e:	29 85       	ldd	r18, Y+9	; 0x09
    1510:	3a 85       	ldd	r19, Y+10	; 0x0a
    1512:	b9 01       	movw	r22, r18
    1514:	0e 94 49 0c 	call	0x1892	; 0x1892 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1518:	8d 85       	ldd	r24, Y+13	; 0x0d
    151a:	88 23       	and	r24, r24
    151c:	b1 f4       	brne	.+44     	; 0x154a <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    151e:	ef 81       	ldd	r30, Y+7	; 0x07
    1520:	f8 85       	ldd	r31, Y+8	; 0x08
    1522:	82 8d       	ldd	r24, Z+26	; 0x1a
    1524:	81 50       	subi	r24, 0x01	; 1
    1526:	ef 81       	ldd	r30, Y+7	; 0x07
    1528:	f8 85       	ldd	r31, Y+8	; 0x08
    152a:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    152c:	ef 81       	ldd	r30, Y+7	; 0x07
    152e:	f8 85       	ldd	r31, Y+8	; 0x08
    1530:	80 85       	ldd	r24, Z+8	; 0x08
    1532:	88 23       	and	r24, r24
    1534:	f1 f0       	breq	.+60     	; 0x1572 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1536:	8f 81       	ldd	r24, Y+7	; 0x07
    1538:	98 85       	ldd	r25, Y+8	; 0x08
    153a:	08 96       	adiw	r24, 0x08	; 8
    153c:	0e 94 c9 11 	call	0x2392	; 0x2392 <xTaskRemoveFromEventList>
    1540:	81 30       	cpi	r24, 0x01	; 1
    1542:	b9 f4       	brne	.+46     	; 0x1572 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    1544:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vPortYield>
    1548:	14 c0       	rjmp	.+40     	; 0x1572 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    154a:	ef 81       	ldd	r30, Y+7	; 0x07
    154c:	f8 85       	ldd	r31, Y+8	; 0x08
    154e:	89 81       	ldd	r24, Y+1	; 0x01
    1550:	9a 81       	ldd	r25, Y+2	; 0x02
    1552:	97 83       	std	Z+7, r25	; 0x07
    1554:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1556:	ef 81       	ldd	r30, Y+7	; 0x07
    1558:	f8 85       	ldd	r31, Y+8	; 0x08
    155a:	81 89       	ldd	r24, Z+17	; 0x11
    155c:	88 23       	and	r24, r24
    155e:	49 f0       	breq	.+18     	; 0x1572 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1560:	8f 81       	ldd	r24, Y+7	; 0x07
    1562:	98 85       	ldd	r25, Y+8	; 0x08
    1564:	41 96       	adiw	r24, 0x11	; 17
    1566:	0e 94 c9 11 	call	0x2392	; 0x2392 <xTaskRemoveFromEventList>
    156a:	88 23       	and	r24, r24
    156c:	11 f0       	breq	.+4      	; 0x1572 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    156e:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1572:	0f 90       	pop	r0
    1574:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1576:	81 e0       	ldi	r24, 0x01	; 1
    1578:	8e 87       	std	Y+14, r24	; 0x0e
    157a:	5c c0       	rjmp	.+184    	; 0x1634 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    157c:	8b 85       	ldd	r24, Y+11	; 0x0b
    157e:	9c 85       	ldd	r25, Y+12	; 0x0c
    1580:	00 97       	sbiw	r24, 0x00	; 0
    1582:	21 f4       	brne	.+8      	; 0x158c <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1584:	0f 90       	pop	r0
    1586:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1588:	1e 86       	std	Y+14, r1	; 0x0e
    158a:	54 c0       	rjmp	.+168    	; 0x1634 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    158c:	8b 81       	ldd	r24, Y+3	; 0x03
    158e:	88 23       	and	r24, r24
    1590:	31 f4       	brne	.+12     	; 0x159e <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1592:	ce 01       	movw	r24, r28
    1594:	04 96       	adiw	r24, 0x04	; 4
    1596:	0e 94 31 12 	call	0x2462	; 0x2462 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    159a:	81 e0       	ldi	r24, 0x01	; 1
    159c:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    159e:	0f 90       	pop	r0
    15a0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    15a2:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    15a6:	0f b6       	in	r0, 0x3f	; 63
    15a8:	f8 94       	cli
    15aa:	0f 92       	push	r0
    15ac:	ef 81       	ldd	r30, Y+7	; 0x07
    15ae:	f8 85       	ldd	r31, Y+8	; 0x08
    15b0:	85 8d       	ldd	r24, Z+29	; 0x1d
    15b2:	8f 3f       	cpi	r24, 0xFF	; 255
    15b4:	19 f4       	brne	.+6      	; 0x15bc <xQueueGenericReceive+0xf4>
    15b6:	ef 81       	ldd	r30, Y+7	; 0x07
    15b8:	f8 85       	ldd	r31, Y+8	; 0x08
    15ba:	15 8e       	std	Z+29, r1	; 0x1d
    15bc:	ef 81       	ldd	r30, Y+7	; 0x07
    15be:	f8 85       	ldd	r31, Y+8	; 0x08
    15c0:	86 8d       	ldd	r24, Z+30	; 0x1e
    15c2:	8f 3f       	cpi	r24, 0xFF	; 255
    15c4:	19 f4       	brne	.+6      	; 0x15cc <xQueueGenericReceive+0x104>
    15c6:	ef 81       	ldd	r30, Y+7	; 0x07
    15c8:	f8 85       	ldd	r31, Y+8	; 0x08
    15ca:	16 8e       	std	Z+30, r1	; 0x1e
    15cc:	0f 90       	pop	r0
    15ce:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    15d0:	ce 01       	movw	r24, r28
    15d2:	04 96       	adiw	r24, 0x04	; 4
    15d4:	9e 01       	movw	r18, r28
    15d6:	25 5f       	subi	r18, 0xF5	; 245
    15d8:	3f 4f       	sbci	r19, 0xFF	; 255
    15da:	b9 01       	movw	r22, r18
    15dc:	0e 94 4a 12 	call	0x2494	; 0x2494 <xTaskCheckForTimeOut>
    15e0:	88 23       	and	r24, r24
    15e2:	09 f5       	brne	.+66     	; 0x1626 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    15e4:	8f 81       	ldd	r24, Y+7	; 0x07
    15e6:	98 85       	ldd	r25, Y+8	; 0x08
    15e8:	0e 94 e5 0c 	call	0x19ca	; 0x19ca <prvIsQueueEmpty>
    15ec:	88 23       	and	r24, r24
    15ee:	a1 f0       	breq	.+40     	; 0x1618 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    15f0:	8f 81       	ldd	r24, Y+7	; 0x07
    15f2:	98 85       	ldd	r25, Y+8	; 0x08
    15f4:	41 96       	adiw	r24, 0x11	; 17
    15f6:	2b 85       	ldd	r18, Y+11	; 0x0b
    15f8:	3c 85       	ldd	r19, Y+12	; 0x0c
    15fa:	b9 01       	movw	r22, r18
    15fc:	0e 94 93 11 	call	0x2326	; 0x2326 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1600:	8f 81       	ldd	r24, Y+7	; 0x07
    1602:	98 85       	ldd	r25, Y+8	; 0x08
    1604:	0e 94 91 0c 	call	0x1922	; 0x1922 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1608:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <xTaskResumeAll>
    160c:	88 23       	and	r24, r24
    160e:	09 f0       	breq	.+2      	; 0x1612 <xQueueGenericReceive+0x14a>
    1610:	6d cf       	rjmp	.-294    	; 0x14ec <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1612:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vPortYield>
    1616:	6a cf       	rjmp	.-300    	; 0x14ec <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1618:	8f 81       	ldd	r24, Y+7	; 0x07
    161a:	98 85       	ldd	r25, Y+8	; 0x08
    161c:	0e 94 91 0c 	call	0x1922	; 0x1922 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1620:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <xTaskResumeAll>
    1624:	63 cf       	rjmp	.-314    	; 0x14ec <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1626:	8f 81       	ldd	r24, Y+7	; 0x07
    1628:	98 85       	ldd	r25, Y+8	; 0x08
    162a:	0e 94 91 0c 	call	0x1922	; 0x1922 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    162e:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1632:	1e 86       	std	Y+14, r1	; 0x0e
    1634:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    1636:	2e 96       	adiw	r28, 0x0e	; 14
    1638:	0f b6       	in	r0, 0x3f	; 63
    163a:	f8 94       	cli
    163c:	de bf       	out	0x3e, r29	; 62
    163e:	0f be       	out	0x3f, r0	; 63
    1640:	cd bf       	out	0x3d, r28	; 61
    1642:	cf 91       	pop	r28
    1644:	df 91       	pop	r29
    1646:	08 95       	ret

00001648 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1648:	df 93       	push	r29
    164a:	cf 93       	push	r28
    164c:	cd b7       	in	r28, 0x3d	; 61
    164e:	de b7       	in	r29, 0x3e	; 62
    1650:	28 97       	sbiw	r28, 0x08	; 8
    1652:	0f b6       	in	r0, 0x3f	; 63
    1654:	f8 94       	cli
    1656:	de bf       	out	0x3e, r29	; 62
    1658:	0f be       	out	0x3f, r0	; 63
    165a:	cd bf       	out	0x3d, r28	; 61
    165c:	9c 83       	std	Y+4, r25	; 0x04
    165e:	8b 83       	std	Y+3, r24	; 0x03
    1660:	7e 83       	std	Y+6, r23	; 0x06
    1662:	6d 83       	std	Y+5, r22	; 0x05
    1664:	58 87       	std	Y+8, r21	; 0x08
    1666:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1668:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    166a:	eb 81       	ldd	r30, Y+3	; 0x03
    166c:	fc 81       	ldd	r31, Y+4	; 0x04
    166e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1670:	88 23       	and	r24, r24
    1672:	71 f1       	breq	.+92     	; 0x16d0 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1674:	8b 81       	ldd	r24, Y+3	; 0x03
    1676:	9c 81       	ldd	r25, Y+4	; 0x04
    1678:	2d 81       	ldd	r18, Y+5	; 0x05
    167a:	3e 81       	ldd	r19, Y+6	; 0x06
    167c:	b9 01       	movw	r22, r18
    167e:	0e 94 49 0c 	call	0x1892	; 0x1892 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1682:	eb 81       	ldd	r30, Y+3	; 0x03
    1684:	fc 81       	ldd	r31, Y+4	; 0x04
    1686:	82 8d       	ldd	r24, Z+26	; 0x1a
    1688:	81 50       	subi	r24, 0x01	; 1
    168a:	eb 81       	ldd	r30, Y+3	; 0x03
    168c:	fc 81       	ldd	r31, Y+4	; 0x04
    168e:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1690:	eb 81       	ldd	r30, Y+3	; 0x03
    1692:	fc 81       	ldd	r31, Y+4	; 0x04
    1694:	85 8d       	ldd	r24, Z+29	; 0x1d
    1696:	8f 3f       	cpi	r24, 0xFF	; 255
    1698:	89 f4       	brne	.+34     	; 0x16bc <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    169a:	eb 81       	ldd	r30, Y+3	; 0x03
    169c:	fc 81       	ldd	r31, Y+4	; 0x04
    169e:	80 85       	ldd	r24, Z+8	; 0x08
    16a0:	88 23       	and	r24, r24
    16a2:	99 f0       	breq	.+38     	; 0x16ca <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16a4:	8b 81       	ldd	r24, Y+3	; 0x03
    16a6:	9c 81       	ldd	r25, Y+4	; 0x04
    16a8:	08 96       	adiw	r24, 0x08	; 8
    16aa:	0e 94 c9 11 	call	0x2392	; 0x2392 <xTaskRemoveFromEventList>
    16ae:	88 23       	and	r24, r24
    16b0:	61 f0       	breq	.+24     	; 0x16ca <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    16b2:	ef 81       	ldd	r30, Y+7	; 0x07
    16b4:	f8 85       	ldd	r31, Y+8	; 0x08
    16b6:	81 e0       	ldi	r24, 0x01	; 1
    16b8:	80 83       	st	Z, r24
    16ba:	07 c0       	rjmp	.+14     	; 0x16ca <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    16bc:	eb 81       	ldd	r30, Y+3	; 0x03
    16be:	fc 81       	ldd	r31, Y+4	; 0x04
    16c0:	85 8d       	ldd	r24, Z+29	; 0x1d
    16c2:	8f 5f       	subi	r24, 0xFF	; 255
    16c4:	eb 81       	ldd	r30, Y+3	; 0x03
    16c6:	fc 81       	ldd	r31, Y+4	; 0x04
    16c8:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    16ca:	81 e0       	ldi	r24, 0x01	; 1
    16cc:	8a 83       	std	Y+2, r24	; 0x02
    16ce:	01 c0       	rjmp	.+2      	; 0x16d2 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    16d0:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    16d2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    16d4:	28 96       	adiw	r28, 0x08	; 8
    16d6:	0f b6       	in	r0, 0x3f	; 63
    16d8:	f8 94       	cli
    16da:	de bf       	out	0x3e, r29	; 62
    16dc:	0f be       	out	0x3f, r0	; 63
    16de:	cd bf       	out	0x3d, r28	; 61
    16e0:	cf 91       	pop	r28
    16e2:	df 91       	pop	r29
    16e4:	08 95       	ret

000016e6 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    16e6:	df 93       	push	r29
    16e8:	cf 93       	push	r28
    16ea:	00 d0       	rcall	.+0      	; 0x16ec <uxQueueMessagesWaiting+0x6>
    16ec:	0f 92       	push	r0
    16ee:	cd b7       	in	r28, 0x3d	; 61
    16f0:	de b7       	in	r29, 0x3e	; 62
    16f2:	9b 83       	std	Y+3, r25	; 0x03
    16f4:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    16f6:	0f b6       	in	r0, 0x3f	; 63
    16f8:	f8 94       	cli
    16fa:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    16fc:	ea 81       	ldd	r30, Y+2	; 0x02
    16fe:	fb 81       	ldd	r31, Y+3	; 0x03
    1700:	82 8d       	ldd	r24, Z+26	; 0x1a
    1702:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1704:	0f 90       	pop	r0
    1706:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1708:	89 81       	ldd	r24, Y+1	; 0x01
}
    170a:	0f 90       	pop	r0
    170c:	0f 90       	pop	r0
    170e:	0f 90       	pop	r0
    1710:	cf 91       	pop	r28
    1712:	df 91       	pop	r29
    1714:	08 95       	ret

00001716 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1716:	df 93       	push	r29
    1718:	cf 93       	push	r28
    171a:	00 d0       	rcall	.+0      	; 0x171c <uxQueueMessagesWaitingFromISR+0x6>
    171c:	0f 92       	push	r0
    171e:	cd b7       	in	r28, 0x3d	; 61
    1720:	de b7       	in	r29, 0x3e	; 62
    1722:	9b 83       	std	Y+3, r25	; 0x03
    1724:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1726:	ea 81       	ldd	r30, Y+2	; 0x02
    1728:	fb 81       	ldd	r31, Y+3	; 0x03
    172a:	82 8d       	ldd	r24, Z+26	; 0x1a
    172c:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    172e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1730:	0f 90       	pop	r0
    1732:	0f 90       	pop	r0
    1734:	0f 90       	pop	r0
    1736:	cf 91       	pop	r28
    1738:	df 91       	pop	r29
    173a:	08 95       	ret

0000173c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    173c:	df 93       	push	r29
    173e:	cf 93       	push	r28
    1740:	00 d0       	rcall	.+0      	; 0x1742 <vQueueDelete+0x6>
    1742:	cd b7       	in	r28, 0x3d	; 61
    1744:	de b7       	in	r29, 0x3e	; 62
    1746:	9a 83       	std	Y+2, r25	; 0x02
    1748:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    174a:	e9 81       	ldd	r30, Y+1	; 0x01
    174c:	fa 81       	ldd	r31, Y+2	; 0x02
    174e:	80 81       	ld	r24, Z
    1750:	91 81       	ldd	r25, Z+1	; 0x01
    1752:	0e 94 9d 04 	call	0x93a	; 0x93a <vPortFree>
	vPortFree( pxQueue );
    1756:	89 81       	ldd	r24, Y+1	; 0x01
    1758:	9a 81       	ldd	r25, Y+2	; 0x02
    175a:	0e 94 9d 04 	call	0x93a	; 0x93a <vPortFree>
}
    175e:	0f 90       	pop	r0
    1760:	0f 90       	pop	r0
    1762:	cf 91       	pop	r28
    1764:	df 91       	pop	r29
    1766:	08 95       	ret

00001768 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1768:	df 93       	push	r29
    176a:	cf 93       	push	r28
    176c:	00 d0       	rcall	.+0      	; 0x176e <prvCopyDataToQueue+0x6>
    176e:	00 d0       	rcall	.+0      	; 0x1770 <prvCopyDataToQueue+0x8>
    1770:	0f 92       	push	r0
    1772:	cd b7       	in	r28, 0x3d	; 61
    1774:	de b7       	in	r29, 0x3e	; 62
    1776:	9a 83       	std	Y+2, r25	; 0x02
    1778:	89 83       	std	Y+1, r24	; 0x01
    177a:	7c 83       	std	Y+4, r23	; 0x04
    177c:	6b 83       	std	Y+3, r22	; 0x03
    177e:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1780:	e9 81       	ldd	r30, Y+1	; 0x01
    1782:	fa 81       	ldd	r31, Y+2	; 0x02
    1784:	84 8d       	ldd	r24, Z+28	; 0x1c
    1786:	88 23       	and	r24, r24
    1788:	09 f4       	brne	.+2      	; 0x178c <prvCopyDataToQueue+0x24>
    178a:	74 c0       	rjmp	.+232    	; 0x1874 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    178c:	8d 81       	ldd	r24, Y+5	; 0x05
    178e:	88 23       	and	r24, r24
    1790:	99 f5       	brne	.+102    	; 0x17f8 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1792:	e9 81       	ldd	r30, Y+1	; 0x01
    1794:	fa 81       	ldd	r31, Y+2	; 0x02
    1796:	64 81       	ldd	r22, Z+4	; 0x04
    1798:	75 81       	ldd	r23, Z+5	; 0x05
    179a:	e9 81       	ldd	r30, Y+1	; 0x01
    179c:	fa 81       	ldd	r31, Y+2	; 0x02
    179e:	84 8d       	ldd	r24, Z+28	; 0x1c
    17a0:	48 2f       	mov	r20, r24
    17a2:	50 e0       	ldi	r21, 0x00	; 0
    17a4:	2b 81       	ldd	r18, Y+3	; 0x03
    17a6:	3c 81       	ldd	r19, Y+4	; 0x04
    17a8:	cb 01       	movw	r24, r22
    17aa:	b9 01       	movw	r22, r18
    17ac:	0e 94 3c 14 	call	0x2878	; 0x2878 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    17b0:	e9 81       	ldd	r30, Y+1	; 0x01
    17b2:	fa 81       	ldd	r31, Y+2	; 0x02
    17b4:	24 81       	ldd	r18, Z+4	; 0x04
    17b6:	35 81       	ldd	r19, Z+5	; 0x05
    17b8:	e9 81       	ldd	r30, Y+1	; 0x01
    17ba:	fa 81       	ldd	r31, Y+2	; 0x02
    17bc:	84 8d       	ldd	r24, Z+28	; 0x1c
    17be:	88 2f       	mov	r24, r24
    17c0:	90 e0       	ldi	r25, 0x00	; 0
    17c2:	82 0f       	add	r24, r18
    17c4:	93 1f       	adc	r25, r19
    17c6:	e9 81       	ldd	r30, Y+1	; 0x01
    17c8:	fa 81       	ldd	r31, Y+2	; 0x02
    17ca:	95 83       	std	Z+5, r25	; 0x05
    17cc:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    17ce:	e9 81       	ldd	r30, Y+1	; 0x01
    17d0:	fa 81       	ldd	r31, Y+2	; 0x02
    17d2:	24 81       	ldd	r18, Z+4	; 0x04
    17d4:	35 81       	ldd	r19, Z+5	; 0x05
    17d6:	e9 81       	ldd	r30, Y+1	; 0x01
    17d8:	fa 81       	ldd	r31, Y+2	; 0x02
    17da:	82 81       	ldd	r24, Z+2	; 0x02
    17dc:	93 81       	ldd	r25, Z+3	; 0x03
    17de:	28 17       	cp	r18, r24
    17e0:	39 07       	cpc	r19, r25
    17e2:	08 f4       	brcc	.+2      	; 0x17e6 <prvCopyDataToQueue+0x7e>
    17e4:	47 c0       	rjmp	.+142    	; 0x1874 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    17e6:	e9 81       	ldd	r30, Y+1	; 0x01
    17e8:	fa 81       	ldd	r31, Y+2	; 0x02
    17ea:	80 81       	ld	r24, Z
    17ec:	91 81       	ldd	r25, Z+1	; 0x01
    17ee:	e9 81       	ldd	r30, Y+1	; 0x01
    17f0:	fa 81       	ldd	r31, Y+2	; 0x02
    17f2:	95 83       	std	Z+5, r25	; 0x05
    17f4:	84 83       	std	Z+4, r24	; 0x04
    17f6:	3e c0       	rjmp	.+124    	; 0x1874 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    17f8:	e9 81       	ldd	r30, Y+1	; 0x01
    17fa:	fa 81       	ldd	r31, Y+2	; 0x02
    17fc:	66 81       	ldd	r22, Z+6	; 0x06
    17fe:	77 81       	ldd	r23, Z+7	; 0x07
    1800:	e9 81       	ldd	r30, Y+1	; 0x01
    1802:	fa 81       	ldd	r31, Y+2	; 0x02
    1804:	84 8d       	ldd	r24, Z+28	; 0x1c
    1806:	48 2f       	mov	r20, r24
    1808:	50 e0       	ldi	r21, 0x00	; 0
    180a:	2b 81       	ldd	r18, Y+3	; 0x03
    180c:	3c 81       	ldd	r19, Y+4	; 0x04
    180e:	cb 01       	movw	r24, r22
    1810:	b9 01       	movw	r22, r18
    1812:	0e 94 3c 14 	call	0x2878	; 0x2878 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1816:	e9 81       	ldd	r30, Y+1	; 0x01
    1818:	fa 81       	ldd	r31, Y+2	; 0x02
    181a:	26 81       	ldd	r18, Z+6	; 0x06
    181c:	37 81       	ldd	r19, Z+7	; 0x07
    181e:	e9 81       	ldd	r30, Y+1	; 0x01
    1820:	fa 81       	ldd	r31, Y+2	; 0x02
    1822:	84 8d       	ldd	r24, Z+28	; 0x1c
    1824:	88 2f       	mov	r24, r24
    1826:	90 e0       	ldi	r25, 0x00	; 0
    1828:	90 95       	com	r25
    182a:	81 95       	neg	r24
    182c:	9f 4f       	sbci	r25, 0xFF	; 255
    182e:	82 0f       	add	r24, r18
    1830:	93 1f       	adc	r25, r19
    1832:	e9 81       	ldd	r30, Y+1	; 0x01
    1834:	fa 81       	ldd	r31, Y+2	; 0x02
    1836:	97 83       	std	Z+7, r25	; 0x07
    1838:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    183a:	e9 81       	ldd	r30, Y+1	; 0x01
    183c:	fa 81       	ldd	r31, Y+2	; 0x02
    183e:	26 81       	ldd	r18, Z+6	; 0x06
    1840:	37 81       	ldd	r19, Z+7	; 0x07
    1842:	e9 81       	ldd	r30, Y+1	; 0x01
    1844:	fa 81       	ldd	r31, Y+2	; 0x02
    1846:	80 81       	ld	r24, Z
    1848:	91 81       	ldd	r25, Z+1	; 0x01
    184a:	28 17       	cp	r18, r24
    184c:	39 07       	cpc	r19, r25
    184e:	90 f4       	brcc	.+36     	; 0x1874 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1850:	e9 81       	ldd	r30, Y+1	; 0x01
    1852:	fa 81       	ldd	r31, Y+2	; 0x02
    1854:	22 81       	ldd	r18, Z+2	; 0x02
    1856:	33 81       	ldd	r19, Z+3	; 0x03
    1858:	e9 81       	ldd	r30, Y+1	; 0x01
    185a:	fa 81       	ldd	r31, Y+2	; 0x02
    185c:	84 8d       	ldd	r24, Z+28	; 0x1c
    185e:	88 2f       	mov	r24, r24
    1860:	90 e0       	ldi	r25, 0x00	; 0
    1862:	90 95       	com	r25
    1864:	81 95       	neg	r24
    1866:	9f 4f       	sbci	r25, 0xFF	; 255
    1868:	82 0f       	add	r24, r18
    186a:	93 1f       	adc	r25, r19
    186c:	e9 81       	ldd	r30, Y+1	; 0x01
    186e:	fa 81       	ldd	r31, Y+2	; 0x02
    1870:	97 83       	std	Z+7, r25	; 0x07
    1872:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1874:	e9 81       	ldd	r30, Y+1	; 0x01
    1876:	fa 81       	ldd	r31, Y+2	; 0x02
    1878:	82 8d       	ldd	r24, Z+26	; 0x1a
    187a:	8f 5f       	subi	r24, 0xFF	; 255
    187c:	e9 81       	ldd	r30, Y+1	; 0x01
    187e:	fa 81       	ldd	r31, Y+2	; 0x02
    1880:	82 8f       	std	Z+26, r24	; 0x1a
}
    1882:	0f 90       	pop	r0
    1884:	0f 90       	pop	r0
    1886:	0f 90       	pop	r0
    1888:	0f 90       	pop	r0
    188a:	0f 90       	pop	r0
    188c:	cf 91       	pop	r28
    188e:	df 91       	pop	r29
    1890:	08 95       	ret

00001892 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1892:	df 93       	push	r29
    1894:	cf 93       	push	r28
    1896:	00 d0       	rcall	.+0      	; 0x1898 <prvCopyDataFromQueue+0x6>
    1898:	00 d0       	rcall	.+0      	; 0x189a <prvCopyDataFromQueue+0x8>
    189a:	cd b7       	in	r28, 0x3d	; 61
    189c:	de b7       	in	r29, 0x3e	; 62
    189e:	9a 83       	std	Y+2, r25	; 0x02
    18a0:	89 83       	std	Y+1, r24	; 0x01
    18a2:	7c 83       	std	Y+4, r23	; 0x04
    18a4:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    18a6:	e9 81       	ldd	r30, Y+1	; 0x01
    18a8:	fa 81       	ldd	r31, Y+2	; 0x02
    18aa:	80 81       	ld	r24, Z
    18ac:	91 81       	ldd	r25, Z+1	; 0x01
    18ae:	00 97       	sbiw	r24, 0x00	; 0
    18b0:	89 f1       	breq	.+98     	; 0x1914 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    18b2:	e9 81       	ldd	r30, Y+1	; 0x01
    18b4:	fa 81       	ldd	r31, Y+2	; 0x02
    18b6:	26 81       	ldd	r18, Z+6	; 0x06
    18b8:	37 81       	ldd	r19, Z+7	; 0x07
    18ba:	e9 81       	ldd	r30, Y+1	; 0x01
    18bc:	fa 81       	ldd	r31, Y+2	; 0x02
    18be:	84 8d       	ldd	r24, Z+28	; 0x1c
    18c0:	88 2f       	mov	r24, r24
    18c2:	90 e0       	ldi	r25, 0x00	; 0
    18c4:	82 0f       	add	r24, r18
    18c6:	93 1f       	adc	r25, r19
    18c8:	e9 81       	ldd	r30, Y+1	; 0x01
    18ca:	fa 81       	ldd	r31, Y+2	; 0x02
    18cc:	97 83       	std	Z+7, r25	; 0x07
    18ce:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    18d0:	e9 81       	ldd	r30, Y+1	; 0x01
    18d2:	fa 81       	ldd	r31, Y+2	; 0x02
    18d4:	26 81       	ldd	r18, Z+6	; 0x06
    18d6:	37 81       	ldd	r19, Z+7	; 0x07
    18d8:	e9 81       	ldd	r30, Y+1	; 0x01
    18da:	fa 81       	ldd	r31, Y+2	; 0x02
    18dc:	82 81       	ldd	r24, Z+2	; 0x02
    18de:	93 81       	ldd	r25, Z+3	; 0x03
    18e0:	28 17       	cp	r18, r24
    18e2:	39 07       	cpc	r19, r25
    18e4:	40 f0       	brcs	.+16     	; 0x18f6 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    18e6:	e9 81       	ldd	r30, Y+1	; 0x01
    18e8:	fa 81       	ldd	r31, Y+2	; 0x02
    18ea:	80 81       	ld	r24, Z
    18ec:	91 81       	ldd	r25, Z+1	; 0x01
    18ee:	e9 81       	ldd	r30, Y+1	; 0x01
    18f0:	fa 81       	ldd	r31, Y+2	; 0x02
    18f2:	97 83       	std	Z+7, r25	; 0x07
    18f4:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    18f6:	e9 81       	ldd	r30, Y+1	; 0x01
    18f8:	fa 81       	ldd	r31, Y+2	; 0x02
    18fa:	46 81       	ldd	r20, Z+6	; 0x06
    18fc:	57 81       	ldd	r21, Z+7	; 0x07
    18fe:	e9 81       	ldd	r30, Y+1	; 0x01
    1900:	fa 81       	ldd	r31, Y+2	; 0x02
    1902:	84 8d       	ldd	r24, Z+28	; 0x1c
    1904:	28 2f       	mov	r18, r24
    1906:	30 e0       	ldi	r19, 0x00	; 0
    1908:	8b 81       	ldd	r24, Y+3	; 0x03
    190a:	9c 81       	ldd	r25, Y+4	; 0x04
    190c:	ba 01       	movw	r22, r20
    190e:	a9 01       	movw	r20, r18
    1910:	0e 94 3c 14 	call	0x2878	; 0x2878 <memcpy>
	}
}
    1914:	0f 90       	pop	r0
    1916:	0f 90       	pop	r0
    1918:	0f 90       	pop	r0
    191a:	0f 90       	pop	r0
    191c:	cf 91       	pop	r28
    191e:	df 91       	pop	r29
    1920:	08 95       	ret

00001922 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1922:	df 93       	push	r29
    1924:	cf 93       	push	r28
    1926:	00 d0       	rcall	.+0      	; 0x1928 <prvUnlockQueue+0x6>
    1928:	cd b7       	in	r28, 0x3d	; 61
    192a:	de b7       	in	r29, 0x3e	; 62
    192c:	9a 83       	std	Y+2, r25	; 0x02
    192e:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1930:	0f b6       	in	r0, 0x3f	; 63
    1932:	f8 94       	cli
    1934:	0f 92       	push	r0
    1936:	15 c0       	rjmp	.+42     	; 0x1962 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1938:	e9 81       	ldd	r30, Y+1	; 0x01
    193a:	fa 81       	ldd	r31, Y+2	; 0x02
    193c:	81 89       	ldd	r24, Z+17	; 0x11
    193e:	88 23       	and	r24, r24
    1940:	a9 f0       	breq	.+42     	; 0x196c <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1942:	89 81       	ldd	r24, Y+1	; 0x01
    1944:	9a 81       	ldd	r25, Y+2	; 0x02
    1946:	41 96       	adiw	r24, 0x11	; 17
    1948:	0e 94 c9 11 	call	0x2392	; 0x2392 <xTaskRemoveFromEventList>
    194c:	88 23       	and	r24, r24
    194e:	11 f0       	breq	.+4      	; 0x1954 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1950:	0e 94 a7 12 	call	0x254e	; 0x254e <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1954:	e9 81       	ldd	r30, Y+1	; 0x01
    1956:	fa 81       	ldd	r31, Y+2	; 0x02
    1958:	86 8d       	ldd	r24, Z+30	; 0x1e
    195a:	81 50       	subi	r24, 0x01	; 1
    195c:	e9 81       	ldd	r30, Y+1	; 0x01
    195e:	fa 81       	ldd	r31, Y+2	; 0x02
    1960:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1962:	e9 81       	ldd	r30, Y+1	; 0x01
    1964:	fa 81       	ldd	r31, Y+2	; 0x02
    1966:	86 8d       	ldd	r24, Z+30	; 0x1e
    1968:	18 16       	cp	r1, r24
    196a:	34 f3       	brlt	.-52     	; 0x1938 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    196c:	e9 81       	ldd	r30, Y+1	; 0x01
    196e:	fa 81       	ldd	r31, Y+2	; 0x02
    1970:	8f ef       	ldi	r24, 0xFF	; 255
    1972:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1974:	0f 90       	pop	r0
    1976:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1978:	0f b6       	in	r0, 0x3f	; 63
    197a:	f8 94       	cli
    197c:	0f 92       	push	r0
    197e:	15 c0       	rjmp	.+42     	; 0x19aa <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1980:	e9 81       	ldd	r30, Y+1	; 0x01
    1982:	fa 81       	ldd	r31, Y+2	; 0x02
    1984:	80 85       	ldd	r24, Z+8	; 0x08
    1986:	88 23       	and	r24, r24
    1988:	a9 f0       	breq	.+42     	; 0x19b4 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    198a:	89 81       	ldd	r24, Y+1	; 0x01
    198c:	9a 81       	ldd	r25, Y+2	; 0x02
    198e:	08 96       	adiw	r24, 0x08	; 8
    1990:	0e 94 c9 11 	call	0x2392	; 0x2392 <xTaskRemoveFromEventList>
    1994:	88 23       	and	r24, r24
    1996:	11 f0       	breq	.+4      	; 0x199c <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    1998:	0e 94 a7 12 	call	0x254e	; 0x254e <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    199c:	e9 81       	ldd	r30, Y+1	; 0x01
    199e:	fa 81       	ldd	r31, Y+2	; 0x02
    19a0:	85 8d       	ldd	r24, Z+29	; 0x1d
    19a2:	81 50       	subi	r24, 0x01	; 1
    19a4:	e9 81       	ldd	r30, Y+1	; 0x01
    19a6:	fa 81       	ldd	r31, Y+2	; 0x02
    19a8:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    19aa:	e9 81       	ldd	r30, Y+1	; 0x01
    19ac:	fa 81       	ldd	r31, Y+2	; 0x02
    19ae:	85 8d       	ldd	r24, Z+29	; 0x1d
    19b0:	18 16       	cp	r1, r24
    19b2:	34 f3       	brlt	.-52     	; 0x1980 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    19b4:	e9 81       	ldd	r30, Y+1	; 0x01
    19b6:	fa 81       	ldd	r31, Y+2	; 0x02
    19b8:	8f ef       	ldi	r24, 0xFF	; 255
    19ba:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    19bc:	0f 90       	pop	r0
    19be:	0f be       	out	0x3f, r0	; 63
}
    19c0:	0f 90       	pop	r0
    19c2:	0f 90       	pop	r0
    19c4:	cf 91       	pop	r28
    19c6:	df 91       	pop	r29
    19c8:	08 95       	ret

000019ca <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    19ca:	df 93       	push	r29
    19cc:	cf 93       	push	r28
    19ce:	00 d0       	rcall	.+0      	; 0x19d0 <prvIsQueueEmpty+0x6>
    19d0:	0f 92       	push	r0
    19d2:	cd b7       	in	r28, 0x3d	; 61
    19d4:	de b7       	in	r29, 0x3e	; 62
    19d6:	9b 83       	std	Y+3, r25	; 0x03
    19d8:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    19da:	0f b6       	in	r0, 0x3f	; 63
    19dc:	f8 94       	cli
    19de:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    19e0:	ea 81       	ldd	r30, Y+2	; 0x02
    19e2:	fb 81       	ldd	r31, Y+3	; 0x03
    19e4:	82 8d       	ldd	r24, Z+26	; 0x1a
    19e6:	19 82       	std	Y+1, r1	; 0x01
    19e8:	88 23       	and	r24, r24
    19ea:	11 f4       	brne	.+4      	; 0x19f0 <prvIsQueueEmpty+0x26>
    19ec:	81 e0       	ldi	r24, 0x01	; 1
    19ee:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    19f0:	0f 90       	pop	r0
    19f2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    19f4:	89 81       	ldd	r24, Y+1	; 0x01
}
    19f6:	0f 90       	pop	r0
    19f8:	0f 90       	pop	r0
    19fa:	0f 90       	pop	r0
    19fc:	cf 91       	pop	r28
    19fe:	df 91       	pop	r29
    1a00:	08 95       	ret

00001a02 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1a02:	df 93       	push	r29
    1a04:	cf 93       	push	r28
    1a06:	00 d0       	rcall	.+0      	; 0x1a08 <xQueueIsQueueEmptyFromISR+0x6>
    1a08:	0f 92       	push	r0
    1a0a:	cd b7       	in	r28, 0x3d	; 61
    1a0c:	de b7       	in	r29, 0x3e	; 62
    1a0e:	9b 83       	std	Y+3, r25	; 0x03
    1a10:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1a12:	ea 81       	ldd	r30, Y+2	; 0x02
    1a14:	fb 81       	ldd	r31, Y+3	; 0x03
    1a16:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a18:	19 82       	std	Y+1, r1	; 0x01
    1a1a:	88 23       	and	r24, r24
    1a1c:	11 f4       	brne	.+4      	; 0x1a22 <xQueueIsQueueEmptyFromISR+0x20>
    1a1e:	81 e0       	ldi	r24, 0x01	; 1
    1a20:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1a22:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a24:	0f 90       	pop	r0
    1a26:	0f 90       	pop	r0
    1a28:	0f 90       	pop	r0
    1a2a:	cf 91       	pop	r28
    1a2c:	df 91       	pop	r29
    1a2e:	08 95       	ret

00001a30 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    1a30:	df 93       	push	r29
    1a32:	cf 93       	push	r28
    1a34:	00 d0       	rcall	.+0      	; 0x1a36 <prvIsQueueFull+0x6>
    1a36:	0f 92       	push	r0
    1a38:	cd b7       	in	r28, 0x3d	; 61
    1a3a:	de b7       	in	r29, 0x3e	; 62
    1a3c:	9b 83       	std	Y+3, r25	; 0x03
    1a3e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1a40:	0f b6       	in	r0, 0x3f	; 63
    1a42:	f8 94       	cli
    1a44:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1a46:	ea 81       	ldd	r30, Y+2	; 0x02
    1a48:	fb 81       	ldd	r31, Y+3	; 0x03
    1a4a:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a4c:	ea 81       	ldd	r30, Y+2	; 0x02
    1a4e:	fb 81       	ldd	r31, Y+3	; 0x03
    1a50:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a52:	19 82       	std	Y+1, r1	; 0x01
    1a54:	98 17       	cp	r25, r24
    1a56:	11 f4       	brne	.+4      	; 0x1a5c <prvIsQueueFull+0x2c>
    1a58:	81 e0       	ldi	r24, 0x01	; 1
    1a5a:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1a5c:	0f 90       	pop	r0
    1a5e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1a60:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a62:	0f 90       	pop	r0
    1a64:	0f 90       	pop	r0
    1a66:	0f 90       	pop	r0
    1a68:	cf 91       	pop	r28
    1a6a:	df 91       	pop	r29
    1a6c:	08 95       	ret

00001a6e <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1a6e:	df 93       	push	r29
    1a70:	cf 93       	push	r28
    1a72:	00 d0       	rcall	.+0      	; 0x1a74 <xQueueIsQueueFullFromISR+0x6>
    1a74:	0f 92       	push	r0
    1a76:	cd b7       	in	r28, 0x3d	; 61
    1a78:	de b7       	in	r29, 0x3e	; 62
    1a7a:	9b 83       	std	Y+3, r25	; 0x03
    1a7c:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1a7e:	ea 81       	ldd	r30, Y+2	; 0x02
    1a80:	fb 81       	ldd	r31, Y+3	; 0x03
    1a82:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a84:	ea 81       	ldd	r30, Y+2	; 0x02
    1a86:	fb 81       	ldd	r31, Y+3	; 0x03
    1a88:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a8a:	19 82       	std	Y+1, r1	; 0x01
    1a8c:	98 17       	cp	r25, r24
    1a8e:	11 f4       	brne	.+4      	; 0x1a94 <xQueueIsQueueFullFromISR+0x26>
    1a90:	81 e0       	ldi	r24, 0x01	; 1
    1a92:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1a94:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a96:	0f 90       	pop	r0
    1a98:	0f 90       	pop	r0
    1a9a:	0f 90       	pop	r0
    1a9c:	cf 91       	pop	r28
    1a9e:	df 91       	pop	r29
    1aa0:	08 95       	ret

00001aa2 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1aa2:	af 92       	push	r10
    1aa4:	bf 92       	push	r11
    1aa6:	cf 92       	push	r12
    1aa8:	df 92       	push	r13
    1aaa:	ef 92       	push	r14
    1aac:	ff 92       	push	r15
    1aae:	0f 93       	push	r16
    1ab0:	1f 93       	push	r17
    1ab2:	df 93       	push	r29
    1ab4:	cf 93       	push	r28
    1ab6:	cd b7       	in	r28, 0x3d	; 61
    1ab8:	de b7       	in	r29, 0x3e	; 62
    1aba:	64 97       	sbiw	r28, 0x14	; 20
    1abc:	0f b6       	in	r0, 0x3f	; 63
    1abe:	f8 94       	cli
    1ac0:	de bf       	out	0x3e, r29	; 62
    1ac2:	0f be       	out	0x3f, r0	; 63
    1ac4:	cd bf       	out	0x3d, r28	; 61
    1ac6:	9f 83       	std	Y+7, r25	; 0x07
    1ac8:	8e 83       	std	Y+6, r24	; 0x06
    1aca:	79 87       	std	Y+9, r23	; 0x09
    1acc:	68 87       	std	Y+8, r22	; 0x08
    1ace:	5b 87       	std	Y+11, r21	; 0x0b
    1ad0:	4a 87       	std	Y+10, r20	; 0x0a
    1ad2:	3d 87       	std	Y+13, r19	; 0x0d
    1ad4:	2c 87       	std	Y+12, r18	; 0x0c
    1ad6:	0e 87       	std	Y+14, r16	; 0x0e
    1ad8:	f8 8a       	std	Y+16, r15	; 0x10
    1ada:	ef 86       	std	Y+15, r14	; 0x0f
    1adc:	da 8a       	std	Y+18, r13	; 0x12
    1ade:	c9 8a       	std	Y+17, r12	; 0x11
    1ae0:	bc 8a       	std	Y+20, r11	; 0x14
    1ae2:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    1ae4:	8a 85       	ldd	r24, Y+10	; 0x0a
    1ae6:	9b 85       	ldd	r25, Y+11	; 0x0b
    1ae8:	29 89       	ldd	r18, Y+17	; 0x11
    1aea:	3a 89       	ldd	r19, Y+18	; 0x12
    1aec:	b9 01       	movw	r22, r18
    1aee:	0e 94 d6 13 	call	0x27ac	; 0x27ac <prvAllocateTCBAndStack>
    1af2:	9c 83       	std	Y+4, r25	; 0x04
    1af4:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    1af6:	8b 81       	ldd	r24, Y+3	; 0x03
    1af8:	9c 81       	ldd	r25, Y+4	; 0x04
    1afa:	00 97       	sbiw	r24, 0x00	; 0
    1afc:	09 f4       	brne	.+2      	; 0x1b00 <xTaskGenericCreate+0x5e>
    1afe:	99 c0       	rjmp	.+306    	; 0x1c32 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1b00:	eb 81       	ldd	r30, Y+3	; 0x03
    1b02:	fc 81       	ldd	r31, Y+4	; 0x04
    1b04:	27 89       	ldd	r18, Z+23	; 0x17
    1b06:	30 8d       	ldd	r19, Z+24	; 0x18
    1b08:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b0a:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b0c:	01 97       	sbiw	r24, 0x01	; 1
    1b0e:	82 0f       	add	r24, r18
    1b10:	93 1f       	adc	r25, r19
    1b12:	9a 83       	std	Y+2, r25	; 0x02
    1b14:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    1b16:	8b 81       	ldd	r24, Y+3	; 0x03
    1b18:	9c 81       	ldd	r25, Y+4	; 0x04
    1b1a:	28 85       	ldd	r18, Y+8	; 0x08
    1b1c:	39 85       	ldd	r19, Y+9	; 0x09
    1b1e:	eb 89       	ldd	r30, Y+19	; 0x13
    1b20:	fc 89       	ldd	r31, Y+20	; 0x14
    1b22:	aa 85       	ldd	r26, Y+10	; 0x0a
    1b24:	bb 85       	ldd	r27, Y+11	; 0x0b
    1b26:	b9 01       	movw	r22, r18
    1b28:	4e 85       	ldd	r20, Y+14	; 0x0e
    1b2a:	9f 01       	movw	r18, r30
    1b2c:	8d 01       	movw	r16, r26
    1b2e:	0e 94 bb 12 	call	0x2576	; 0x2576 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1b32:	89 81       	ldd	r24, Y+1	; 0x01
    1b34:	9a 81       	ldd	r25, Y+2	; 0x02
    1b36:	2e 81       	ldd	r18, Y+6	; 0x06
    1b38:	3f 81       	ldd	r19, Y+7	; 0x07
    1b3a:	4c 85       	ldd	r20, Y+12	; 0x0c
    1b3c:	5d 85       	ldd	r21, Y+13	; 0x0d
    1b3e:	b9 01       	movw	r22, r18
    1b40:	0e 94 fe 05 	call	0xbfc	; 0xbfc <pxPortInitialiseStack>
    1b44:	eb 81       	ldd	r30, Y+3	; 0x03
    1b46:	fc 81       	ldd	r31, Y+4	; 0x04
    1b48:	91 83       	std	Z+1, r25	; 0x01
    1b4a:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    1b4c:	8f 85       	ldd	r24, Y+15	; 0x0f
    1b4e:	98 89       	ldd	r25, Y+16	; 0x10
    1b50:	00 97       	sbiw	r24, 0x00	; 0
    1b52:	31 f0       	breq	.+12     	; 0x1b60 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1b54:	ef 85       	ldd	r30, Y+15	; 0x0f
    1b56:	f8 89       	ldd	r31, Y+16	; 0x10
    1b58:	8b 81       	ldd	r24, Y+3	; 0x03
    1b5a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b5c:	91 83       	std	Z+1, r25	; 0x01
    1b5e:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1b60:	0f b6       	in	r0, 0x3f	; 63
    1b62:	f8 94       	cli
    1b64:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1b66:	80 91 19 03 	lds	r24, 0x0319
    1b6a:	8f 5f       	subi	r24, 0xFF	; 255
    1b6c:	80 93 19 03 	sts	0x0319, r24
			if( pxCurrentTCB == NULL )
    1b70:	80 91 16 03 	lds	r24, 0x0316
    1b74:	90 91 17 03 	lds	r25, 0x0317
    1b78:	00 97       	sbiw	r24, 0x00	; 0
    1b7a:	69 f4       	brne	.+26     	; 0x1b96 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1b7c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b7e:	9c 81       	ldd	r25, Y+4	; 0x04
    1b80:	90 93 17 03 	sts	0x0317, r25
    1b84:	80 93 16 03 	sts	0x0316, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1b88:	80 91 19 03 	lds	r24, 0x0319
    1b8c:	81 30       	cpi	r24, 0x01	; 1
    1b8e:	a9 f4       	brne	.+42     	; 0x1bba <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    1b90:	0e 94 12 13 	call	0x2624	; 0x2624 <prvInitialiseTaskLists>
    1b94:	12 c0       	rjmp	.+36     	; 0x1bba <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1b96:	80 91 1e 03 	lds	r24, 0x031E
    1b9a:	88 23       	and	r24, r24
    1b9c:	71 f4       	brne	.+28     	; 0x1bba <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1b9e:	e0 91 16 03 	lds	r30, 0x0316
    1ba2:	f0 91 17 03 	lds	r31, 0x0317
    1ba6:	96 89       	ldd	r25, Z+22	; 0x16
    1ba8:	8e 85       	ldd	r24, Y+14	; 0x0e
    1baa:	89 17       	cp	r24, r25
    1bac:	30 f0       	brcs	.+12     	; 0x1bba <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    1bae:	8b 81       	ldd	r24, Y+3	; 0x03
    1bb0:	9c 81       	ldd	r25, Y+4	; 0x04
    1bb2:	90 93 17 03 	sts	0x0317, r25
    1bb6:	80 93 16 03 	sts	0x0316, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1bba:	eb 81       	ldd	r30, Y+3	; 0x03
    1bbc:	fc 81       	ldd	r31, Y+4	; 0x04
    1bbe:	96 89       	ldd	r25, Z+22	; 0x16
    1bc0:	80 91 1c 03 	lds	r24, 0x031C
    1bc4:	89 17       	cp	r24, r25
    1bc6:	28 f4       	brcc	.+10     	; 0x1bd2 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1bc8:	eb 81       	ldd	r30, Y+3	; 0x03
    1bca:	fc 81       	ldd	r31, Y+4	; 0x04
    1bcc:	86 89       	ldd	r24, Z+22	; 0x16
    1bce:	80 93 1c 03 	sts	0x031C, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1bd2:	80 91 23 03 	lds	r24, 0x0323
    1bd6:	8f 5f       	subi	r24, 0xFF	; 255
    1bd8:	80 93 23 03 	sts	0x0323, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1bdc:	eb 81       	ldd	r30, Y+3	; 0x03
    1bde:	fc 81       	ldd	r31, Y+4	; 0x04
    1be0:	96 89       	ldd	r25, Z+22	; 0x16
    1be2:	80 91 1d 03 	lds	r24, 0x031D
    1be6:	89 17       	cp	r24, r25
    1be8:	28 f4       	brcc	.+10     	; 0x1bf4 <xTaskGenericCreate+0x152>
    1bea:	eb 81       	ldd	r30, Y+3	; 0x03
    1bec:	fc 81       	ldd	r31, Y+4	; 0x04
    1bee:	86 89       	ldd	r24, Z+22	; 0x16
    1bf0:	80 93 1d 03 	sts	0x031D, r24
    1bf4:	eb 81       	ldd	r30, Y+3	; 0x03
    1bf6:	fc 81       	ldd	r31, Y+4	; 0x04
    1bf8:	86 89       	ldd	r24, Z+22	; 0x16
    1bfa:	28 2f       	mov	r18, r24
    1bfc:	30 e0       	ldi	r19, 0x00	; 0
    1bfe:	c9 01       	movw	r24, r18
    1c00:	88 0f       	add	r24, r24
    1c02:	99 1f       	adc	r25, r25
    1c04:	88 0f       	add	r24, r24
    1c06:	99 1f       	adc	r25, r25
    1c08:	88 0f       	add	r24, r24
    1c0a:	99 1f       	adc	r25, r25
    1c0c:	82 0f       	add	r24, r18
    1c0e:	93 1f       	adc	r25, r19
    1c10:	ac 01       	movw	r20, r24
    1c12:	4c 5d       	subi	r20, 0xDC	; 220
    1c14:	5c 4f       	sbci	r21, 0xFC	; 252
    1c16:	8b 81       	ldd	r24, Y+3	; 0x03
    1c18:	9c 81       	ldd	r25, Y+4	; 0x04
    1c1a:	9c 01       	movw	r18, r24
    1c1c:	2e 5f       	subi	r18, 0xFE	; 254
    1c1e:	3f 4f       	sbci	r19, 0xFF	; 255
    1c20:	ca 01       	movw	r24, r20
    1c22:	b9 01       	movw	r22, r18
    1c24:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInsertEnd>

			xReturn = pdPASS;
    1c28:	81 e0       	ldi	r24, 0x01	; 1
    1c2a:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1c2c:	0f 90       	pop	r0
    1c2e:	0f be       	out	0x3f, r0	; 63
    1c30:	02 c0       	rjmp	.+4      	; 0x1c36 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1c32:	8f ef       	ldi	r24, 0xFF	; 255
    1c34:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    1c36:	8d 81       	ldd	r24, Y+5	; 0x05
    1c38:	81 30       	cpi	r24, 0x01	; 1
    1c3a:	71 f4       	brne	.+28     	; 0x1c58 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    1c3c:	80 91 1e 03 	lds	r24, 0x031E
    1c40:	88 23       	and	r24, r24
    1c42:	51 f0       	breq	.+20     	; 0x1c58 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1c44:	e0 91 16 03 	lds	r30, 0x0316
    1c48:	f0 91 17 03 	lds	r31, 0x0317
    1c4c:	96 89       	ldd	r25, Z+22	; 0x16
    1c4e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1c50:	98 17       	cp	r25, r24
    1c52:	10 f4       	brcc	.+4      	; 0x1c58 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    1c54:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vPortYield>
			}
		}
	}

	return xReturn;
    1c58:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1c5a:	64 96       	adiw	r28, 0x14	; 20
    1c5c:	0f b6       	in	r0, 0x3f	; 63
    1c5e:	f8 94       	cli
    1c60:	de bf       	out	0x3e, r29	; 62
    1c62:	0f be       	out	0x3f, r0	; 63
    1c64:	cd bf       	out	0x3d, r28	; 61
    1c66:	cf 91       	pop	r28
    1c68:	df 91       	pop	r29
    1c6a:	1f 91       	pop	r17
    1c6c:	0f 91       	pop	r16
    1c6e:	ff 90       	pop	r15
    1c70:	ef 90       	pop	r14
    1c72:	df 90       	pop	r13
    1c74:	cf 90       	pop	r12
    1c76:	bf 90       	pop	r11
    1c78:	af 90       	pop	r10
    1c7a:	08 95       	ret

00001c7c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1c7c:	df 93       	push	r29
    1c7e:	cf 93       	push	r28
    1c80:	00 d0       	rcall	.+0      	; 0x1c82 <vTaskDelete+0x6>
    1c82:	00 d0       	rcall	.+0      	; 0x1c84 <vTaskDelete+0x8>
    1c84:	00 d0       	rcall	.+0      	; 0x1c86 <vTaskDelete+0xa>
    1c86:	cd b7       	in	r28, 0x3d	; 61
    1c88:	de b7       	in	r29, 0x3e	; 62
    1c8a:	9c 83       	std	Y+4, r25	; 0x04
    1c8c:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1c8e:	0f b6       	in	r0, 0x3f	; 63
    1c90:	f8 94       	cli
    1c92:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1c94:	20 91 16 03 	lds	r18, 0x0316
    1c98:	30 91 17 03 	lds	r19, 0x0317
    1c9c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c9e:	9c 81       	ldd	r25, Y+4	; 0x04
    1ca0:	82 17       	cp	r24, r18
    1ca2:	93 07       	cpc	r25, r19
    1ca4:	11 f4       	brne	.+4      	; 0x1caa <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    1ca6:	1c 82       	std	Y+4, r1	; 0x04
    1ca8:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1caa:	8b 81       	ldd	r24, Y+3	; 0x03
    1cac:	9c 81       	ldd	r25, Y+4	; 0x04
    1cae:	00 97       	sbiw	r24, 0x00	; 0
    1cb0:	39 f4       	brne	.+14     	; 0x1cc0 <vTaskDelete+0x44>
    1cb2:	80 91 16 03 	lds	r24, 0x0316
    1cb6:	90 91 17 03 	lds	r25, 0x0317
    1cba:	9e 83       	std	Y+6, r25	; 0x06
    1cbc:	8d 83       	std	Y+5, r24	; 0x05
    1cbe:	04 c0       	rjmp	.+8      	; 0x1cc8 <vTaskDelete+0x4c>
    1cc0:	8b 81       	ldd	r24, Y+3	; 0x03
    1cc2:	9c 81       	ldd	r25, Y+4	; 0x04
    1cc4:	9e 83       	std	Y+6, r25	; 0x06
    1cc6:	8d 83       	std	Y+5, r24	; 0x05
    1cc8:	8d 81       	ldd	r24, Y+5	; 0x05
    1cca:	9e 81       	ldd	r25, Y+6	; 0x06
    1ccc:	9a 83       	std	Y+2, r25	; 0x02
    1cce:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1cd0:	89 81       	ldd	r24, Y+1	; 0x01
    1cd2:	9a 81       	ldd	r25, Y+2	; 0x02
    1cd4:	02 96       	adiw	r24, 0x02	; 2
    1cd6:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1cda:	e9 81       	ldd	r30, Y+1	; 0x01
    1cdc:	fa 81       	ldd	r31, Y+2	; 0x02
    1cde:	84 89       	ldd	r24, Z+20	; 0x14
    1ce0:	95 89       	ldd	r25, Z+21	; 0x15
    1ce2:	00 97       	sbiw	r24, 0x00	; 0
    1ce4:	29 f0       	breq	.+10     	; 0x1cf0 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1ce6:	89 81       	ldd	r24, Y+1	; 0x01
    1ce8:	9a 81       	ldd	r25, Y+2	; 0x02
    1cea:	0c 96       	adiw	r24, 0x0c	; 12
    1cec:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1cf0:	89 81       	ldd	r24, Y+1	; 0x01
    1cf2:	9a 81       	ldd	r25, Y+2	; 0x02
    1cf4:	9c 01       	movw	r18, r24
    1cf6:	2e 5f       	subi	r18, 0xFE	; 254
    1cf8:	3f 4f       	sbci	r19, 0xFF	; 255
    1cfa:	80 e7       	ldi	r24, 0x70	; 112
    1cfc:	93 e0       	ldi	r25, 0x03	; 3
    1cfe:	b9 01       	movw	r22, r18
    1d00:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1d04:	80 91 18 03 	lds	r24, 0x0318
    1d08:	8f 5f       	subi	r24, 0xFF	; 255
    1d0a:	80 93 18 03 	sts	0x0318, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1d0e:	80 91 23 03 	lds	r24, 0x0323
    1d12:	8f 5f       	subi	r24, 0xFF	; 255
    1d14:	80 93 23 03 	sts	0x0323, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1d18:	0f 90       	pop	r0
    1d1a:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1d1c:	80 91 1e 03 	lds	r24, 0x031E
    1d20:	88 23       	and	r24, r24
    1d22:	31 f0       	breq	.+12     	; 0x1d30 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1d24:	8b 81       	ldd	r24, Y+3	; 0x03
    1d26:	9c 81       	ldd	r25, Y+4	; 0x04
    1d28:	00 97       	sbiw	r24, 0x00	; 0
    1d2a:	11 f4       	brne	.+4      	; 0x1d30 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    1d2c:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vPortYield>
			}
		}
	}
    1d30:	26 96       	adiw	r28, 0x06	; 6
    1d32:	0f b6       	in	r0, 0x3f	; 63
    1d34:	f8 94       	cli
    1d36:	de bf       	out	0x3e, r29	; 62
    1d38:	0f be       	out	0x3f, r0	; 63
    1d3a:	cd bf       	out	0x3d, r28	; 61
    1d3c:	cf 91       	pop	r28
    1d3e:	df 91       	pop	r29
    1d40:	08 95       	ret

00001d42 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1d42:	df 93       	push	r29
    1d44:	cf 93       	push	r28
    1d46:	cd b7       	in	r28, 0x3d	; 61
    1d48:	de b7       	in	r29, 0x3e	; 62
    1d4a:	28 97       	sbiw	r28, 0x08	; 8
    1d4c:	0f b6       	in	r0, 0x3f	; 63
    1d4e:	f8 94       	cli
    1d50:	de bf       	out	0x3e, r29	; 62
    1d52:	0f be       	out	0x3f, r0	; 63
    1d54:	cd bf       	out	0x3d, r28	; 61
    1d56:	9e 83       	std	Y+6, r25	; 0x06
    1d58:	8d 83       	std	Y+5, r24	; 0x05
    1d5a:	78 87       	std	Y+8, r23	; 0x08
    1d5c:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    1d5e:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1d60:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1d64:	ed 81       	ldd	r30, Y+5	; 0x05
    1d66:	fe 81       	ldd	r31, Y+6	; 0x06
    1d68:	20 81       	ld	r18, Z
    1d6a:	31 81       	ldd	r19, Z+1	; 0x01
    1d6c:	8f 81       	ldd	r24, Y+7	; 0x07
    1d6e:	98 85       	ldd	r25, Y+8	; 0x08
    1d70:	82 0f       	add	r24, r18
    1d72:	93 1f       	adc	r25, r19
    1d74:	9c 83       	std	Y+4, r25	; 0x04
    1d76:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    1d78:	ed 81       	ldd	r30, Y+5	; 0x05
    1d7a:	fe 81       	ldd	r31, Y+6	; 0x06
    1d7c:	20 81       	ld	r18, Z
    1d7e:	31 81       	ldd	r19, Z+1	; 0x01
    1d80:	80 91 1a 03 	lds	r24, 0x031A
    1d84:	90 91 1b 03 	lds	r25, 0x031B
    1d88:	82 17       	cp	r24, r18
    1d8a:	93 07       	cpc	r25, r19
    1d8c:	a8 f4       	brcc	.+42     	; 0x1db8 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1d8e:	ed 81       	ldd	r30, Y+5	; 0x05
    1d90:	fe 81       	ldd	r31, Y+6	; 0x06
    1d92:	20 81       	ld	r18, Z
    1d94:	31 81       	ldd	r19, Z+1	; 0x01
    1d96:	8b 81       	ldd	r24, Y+3	; 0x03
    1d98:	9c 81       	ldd	r25, Y+4	; 0x04
    1d9a:	82 17       	cp	r24, r18
    1d9c:	93 07       	cpc	r25, r19
    1d9e:	00 f5       	brcc	.+64     	; 0x1de0 <vTaskDelayUntil+0x9e>
    1da0:	20 91 1a 03 	lds	r18, 0x031A
    1da4:	30 91 1b 03 	lds	r19, 0x031B
    1da8:	8b 81       	ldd	r24, Y+3	; 0x03
    1daa:	9c 81       	ldd	r25, Y+4	; 0x04
    1dac:	28 17       	cp	r18, r24
    1dae:	39 07       	cpc	r19, r25
    1db0:	b8 f4       	brcc	.+46     	; 0x1de0 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1db2:	81 e0       	ldi	r24, 0x01	; 1
    1db4:	89 83       	std	Y+1, r24	; 0x01
    1db6:	14 c0       	rjmp	.+40     	; 0x1de0 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1db8:	ed 81       	ldd	r30, Y+5	; 0x05
    1dba:	fe 81       	ldd	r31, Y+6	; 0x06
    1dbc:	20 81       	ld	r18, Z
    1dbe:	31 81       	ldd	r19, Z+1	; 0x01
    1dc0:	8b 81       	ldd	r24, Y+3	; 0x03
    1dc2:	9c 81       	ldd	r25, Y+4	; 0x04
    1dc4:	82 17       	cp	r24, r18
    1dc6:	93 07       	cpc	r25, r19
    1dc8:	48 f0       	brcs	.+18     	; 0x1ddc <vTaskDelayUntil+0x9a>
    1dca:	20 91 1a 03 	lds	r18, 0x031A
    1dce:	30 91 1b 03 	lds	r19, 0x031B
    1dd2:	8b 81       	ldd	r24, Y+3	; 0x03
    1dd4:	9c 81       	ldd	r25, Y+4	; 0x04
    1dd6:	28 17       	cp	r18, r24
    1dd8:	39 07       	cpc	r19, r25
    1dda:	10 f4       	brcc	.+4      	; 0x1de0 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1ddc:	81 e0       	ldi	r24, 0x01	; 1
    1dde:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1de0:	ed 81       	ldd	r30, Y+5	; 0x05
    1de2:	fe 81       	ldd	r31, Y+6	; 0x06
    1de4:	8b 81       	ldd	r24, Y+3	; 0x03
    1de6:	9c 81       	ldd	r25, Y+4	; 0x04
    1de8:	91 83       	std	Z+1, r25	; 0x01
    1dea:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1dec:	89 81       	ldd	r24, Y+1	; 0x01
    1dee:	88 23       	and	r24, r24
    1df0:	59 f0       	breq	.+22     	; 0x1e08 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1df2:	80 91 16 03 	lds	r24, 0x0316
    1df6:	90 91 17 03 	lds	r25, 0x0317
    1dfa:	02 96       	adiw	r24, 0x02	; 2
    1dfc:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1e00:	8b 81       	ldd	r24, Y+3	; 0x03
    1e02:	9c 81       	ldd	r25, Y+4	; 0x04
    1e04:	0e 94 8d 13 	call	0x271a	; 0x271a <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1e08:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <xTaskResumeAll>
    1e0c:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1e0e:	8a 81       	ldd	r24, Y+2	; 0x02
    1e10:	88 23       	and	r24, r24
    1e12:	11 f4       	brne	.+4      	; 0x1e18 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    1e14:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vPortYield>
		}
	}
    1e18:	28 96       	adiw	r28, 0x08	; 8
    1e1a:	0f b6       	in	r0, 0x3f	; 63
    1e1c:	f8 94       	cli
    1e1e:	de bf       	out	0x3e, r29	; 62
    1e20:	0f be       	out	0x3f, r0	; 63
    1e22:	cd bf       	out	0x3d, r28	; 61
    1e24:	cf 91       	pop	r28
    1e26:	df 91       	pop	r29
    1e28:	08 95       	ret

00001e2a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1e2a:	df 93       	push	r29
    1e2c:	cf 93       	push	r28
    1e2e:	00 d0       	rcall	.+0      	; 0x1e30 <vTaskDelay+0x6>
    1e30:	00 d0       	rcall	.+0      	; 0x1e32 <vTaskDelay+0x8>
    1e32:	0f 92       	push	r0
    1e34:	cd b7       	in	r28, 0x3d	; 61
    1e36:	de b7       	in	r29, 0x3e	; 62
    1e38:	9d 83       	std	Y+5, r25	; 0x05
    1e3a:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1e3c:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1e3e:	8c 81       	ldd	r24, Y+4	; 0x04
    1e40:	9d 81       	ldd	r25, Y+5	; 0x05
    1e42:	00 97       	sbiw	r24, 0x00	; 0
    1e44:	d1 f0       	breq	.+52     	; 0x1e7a <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    1e46:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1e4a:	20 91 1a 03 	lds	r18, 0x031A
    1e4e:	30 91 1b 03 	lds	r19, 0x031B
    1e52:	8c 81       	ldd	r24, Y+4	; 0x04
    1e54:	9d 81       	ldd	r25, Y+5	; 0x05
    1e56:	82 0f       	add	r24, r18
    1e58:	93 1f       	adc	r25, r19
    1e5a:	9b 83       	std	Y+3, r25	; 0x03
    1e5c:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1e5e:	80 91 16 03 	lds	r24, 0x0316
    1e62:	90 91 17 03 	lds	r25, 0x0317
    1e66:	02 96       	adiw	r24, 0x02	; 2
    1e68:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1e6c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e6e:	9b 81       	ldd	r25, Y+3	; 0x03
    1e70:	0e 94 8d 13 	call	0x271a	; 0x271a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1e74:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <xTaskResumeAll>
    1e78:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1e7a:	89 81       	ldd	r24, Y+1	; 0x01
    1e7c:	88 23       	and	r24, r24
    1e7e:	11 f4       	brne	.+4      	; 0x1e84 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    1e80:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vPortYield>
		}
	}
    1e84:	0f 90       	pop	r0
    1e86:	0f 90       	pop	r0
    1e88:	0f 90       	pop	r0
    1e8a:	0f 90       	pop	r0
    1e8c:	0f 90       	pop	r0
    1e8e:	cf 91       	pop	r28
    1e90:	df 91       	pop	r29
    1e92:	08 95       	ret

00001e94 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1e94:	af 92       	push	r10
    1e96:	bf 92       	push	r11
    1e98:	cf 92       	push	r12
    1e9a:	df 92       	push	r13
    1e9c:	ef 92       	push	r14
    1e9e:	ff 92       	push	r15
    1ea0:	0f 93       	push	r16
    1ea2:	df 93       	push	r29
    1ea4:	cf 93       	push	r28
    1ea6:	0f 92       	push	r0
    1ea8:	cd b7       	in	r28, 0x3d	; 61
    1eaa:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1eac:	29 e7       	ldi	r18, 0x79	; 121
    1eae:	30 e0       	ldi	r19, 0x00	; 0
    1eb0:	81 eb       	ldi	r24, 0xB1	; 177
    1eb2:	92 e1       	ldi	r25, 0x12	; 18
    1eb4:	b9 01       	movw	r22, r18
    1eb6:	45 e5       	ldi	r20, 0x55	; 85
    1eb8:	50 e0       	ldi	r21, 0x00	; 0
    1eba:	20 e0       	ldi	r18, 0x00	; 0
    1ebc:	30 e0       	ldi	r19, 0x00	; 0
    1ebe:	00 e0       	ldi	r16, 0x00	; 0
    1ec0:	ee 24       	eor	r14, r14
    1ec2:	ff 24       	eor	r15, r15
    1ec4:	cc 24       	eor	r12, r12
    1ec6:	dd 24       	eor	r13, r13
    1ec8:	aa 24       	eor	r10, r10
    1eca:	bb 24       	eor	r11, r11
    1ecc:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <xTaskGenericCreate>
    1ed0:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1ed2:	89 81       	ldd	r24, Y+1	; 0x01
    1ed4:	81 30       	cpi	r24, 0x01	; 1
    1ed6:	51 f4       	brne	.+20     	; 0x1eec <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1ed8:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1eda:	81 e0       	ldi	r24, 0x01	; 1
    1edc:	80 93 1e 03 	sts	0x031E, r24
		xTickCount = ( portTickType ) 0U;
    1ee0:	10 92 1b 03 	sts	0x031B, r1
    1ee4:	10 92 1a 03 	sts	0x031A, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1ee8:	0e 94 81 07 	call	0xf02	; 0xf02 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1eec:	0f 90       	pop	r0
    1eee:	cf 91       	pop	r28
    1ef0:	df 91       	pop	r29
    1ef2:	0f 91       	pop	r16
    1ef4:	ff 90       	pop	r15
    1ef6:	ef 90       	pop	r14
    1ef8:	df 90       	pop	r13
    1efa:	cf 90       	pop	r12
    1efc:	bf 90       	pop	r11
    1efe:	af 90       	pop	r10
    1f00:	08 95       	ret

00001f02 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    1f02:	df 93       	push	r29
    1f04:	cf 93       	push	r28
    1f06:	cd b7       	in	r28, 0x3d	; 61
    1f08:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1f0a:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1f0c:	10 92 1e 03 	sts	0x031E, r1
	vPortEndScheduler();
    1f10:	0e 94 b6 07 	call	0xf6c	; 0xf6c <vPortEndScheduler>
}
    1f14:	cf 91       	pop	r28
    1f16:	df 91       	pop	r29
    1f18:	08 95       	ret

00001f1a <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    1f1a:	df 93       	push	r29
    1f1c:	cf 93       	push	r28
    1f1e:	cd b7       	in	r28, 0x3d	; 61
    1f20:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1f22:	80 91 1f 03 	lds	r24, 0x031F
    1f26:	8f 5f       	subi	r24, 0xFF	; 255
    1f28:	80 93 1f 03 	sts	0x031F, r24
}
    1f2c:	cf 91       	pop	r28
    1f2e:	df 91       	pop	r29
    1f30:	08 95       	ret

00001f32 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1f32:	df 93       	push	r29
    1f34:	cf 93       	push	r28
    1f36:	00 d0       	rcall	.+0      	; 0x1f38 <xTaskResumeAll+0x6>
    1f38:	00 d0       	rcall	.+0      	; 0x1f3a <xTaskResumeAll+0x8>
    1f3a:	cd b7       	in	r28, 0x3d	; 61
    1f3c:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1f3e:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1f40:	0f b6       	in	r0, 0x3f	; 63
    1f42:	f8 94       	cli
    1f44:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1f46:	80 91 1f 03 	lds	r24, 0x031F
    1f4a:	81 50       	subi	r24, 0x01	; 1
    1f4c:	80 93 1f 03 	sts	0x031F, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1f50:	80 91 1f 03 	lds	r24, 0x031F
    1f54:	88 23       	and	r24, r24
    1f56:	09 f0       	breq	.+2      	; 0x1f5a <xTaskResumeAll+0x28>
    1f58:	6c c0       	rjmp	.+216    	; 0x2032 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1f5a:	80 91 19 03 	lds	r24, 0x0319
    1f5e:	88 23       	and	r24, r24
    1f60:	09 f4       	brne	.+2      	; 0x1f64 <xTaskResumeAll+0x32>
    1f62:	67 c0       	rjmp	.+206    	; 0x2032 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    1f64:	19 82       	std	Y+1, r1	; 0x01
    1f66:	41 c0       	rjmp	.+130    	; 0x1fea <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1f68:	e0 91 6c 03 	lds	r30, 0x036C
    1f6c:	f0 91 6d 03 	lds	r31, 0x036D
    1f70:	86 81       	ldd	r24, Z+6	; 0x06
    1f72:	97 81       	ldd	r25, Z+7	; 0x07
    1f74:	9c 83       	std	Y+4, r25	; 0x04
    1f76:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    1f78:	8b 81       	ldd	r24, Y+3	; 0x03
    1f7a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f7c:	0c 96       	adiw	r24, 0x0c	; 12
    1f7e:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1f82:	8b 81       	ldd	r24, Y+3	; 0x03
    1f84:	9c 81       	ldd	r25, Y+4	; 0x04
    1f86:	02 96       	adiw	r24, 0x02	; 2
    1f88:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1f8c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f8e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f90:	96 89       	ldd	r25, Z+22	; 0x16
    1f92:	80 91 1d 03 	lds	r24, 0x031D
    1f96:	89 17       	cp	r24, r25
    1f98:	28 f4       	brcc	.+10     	; 0x1fa4 <xTaskResumeAll+0x72>
    1f9a:	eb 81       	ldd	r30, Y+3	; 0x03
    1f9c:	fc 81       	ldd	r31, Y+4	; 0x04
    1f9e:	86 89       	ldd	r24, Z+22	; 0x16
    1fa0:	80 93 1d 03 	sts	0x031D, r24
    1fa4:	eb 81       	ldd	r30, Y+3	; 0x03
    1fa6:	fc 81       	ldd	r31, Y+4	; 0x04
    1fa8:	86 89       	ldd	r24, Z+22	; 0x16
    1faa:	28 2f       	mov	r18, r24
    1fac:	30 e0       	ldi	r19, 0x00	; 0
    1fae:	c9 01       	movw	r24, r18
    1fb0:	88 0f       	add	r24, r24
    1fb2:	99 1f       	adc	r25, r25
    1fb4:	88 0f       	add	r24, r24
    1fb6:	99 1f       	adc	r25, r25
    1fb8:	88 0f       	add	r24, r24
    1fba:	99 1f       	adc	r25, r25
    1fbc:	82 0f       	add	r24, r18
    1fbe:	93 1f       	adc	r25, r19
    1fc0:	8c 5d       	subi	r24, 0xDC	; 220
    1fc2:	9c 4f       	sbci	r25, 0xFC	; 252
    1fc4:	2b 81       	ldd	r18, Y+3	; 0x03
    1fc6:	3c 81       	ldd	r19, Y+4	; 0x04
    1fc8:	2e 5f       	subi	r18, 0xFE	; 254
    1fca:	3f 4f       	sbci	r19, 0xFF	; 255
    1fcc:	b9 01       	movw	r22, r18
    1fce:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1fd2:	eb 81       	ldd	r30, Y+3	; 0x03
    1fd4:	fc 81       	ldd	r31, Y+4	; 0x04
    1fd6:	96 89       	ldd	r25, Z+22	; 0x16
    1fd8:	e0 91 16 03 	lds	r30, 0x0316
    1fdc:	f0 91 17 03 	lds	r31, 0x0317
    1fe0:	86 89       	ldd	r24, Z+22	; 0x16
    1fe2:	98 17       	cp	r25, r24
    1fe4:	10 f0       	brcs	.+4      	; 0x1fea <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    1fe6:	81 e0       	ldi	r24, 0x01	; 1
    1fe8:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1fea:	80 91 67 03 	lds	r24, 0x0367
    1fee:	88 23       	and	r24, r24
    1ff0:	09 f0       	breq	.+2      	; 0x1ff4 <xTaskResumeAll+0xc2>
    1ff2:	ba cf       	rjmp	.-140    	; 0x1f68 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1ff4:	80 91 20 03 	lds	r24, 0x0320
    1ff8:	88 23       	and	r24, r24
    1ffa:	71 f0       	breq	.+28     	; 0x2018 <xTaskResumeAll+0xe6>
    1ffc:	07 c0       	rjmp	.+14     	; 0x200c <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    1ffe:	0e 94 58 10 	call	0x20b0	; 0x20b0 <vTaskIncrementTick>
						--uxMissedTicks;
    2002:	80 91 20 03 	lds	r24, 0x0320
    2006:	81 50       	subi	r24, 0x01	; 1
    2008:	80 93 20 03 	sts	0x0320, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    200c:	80 91 20 03 	lds	r24, 0x0320
    2010:	88 23       	and	r24, r24
    2012:	a9 f7       	brne	.-22     	; 0x1ffe <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    2014:	81 e0       	ldi	r24, 0x01	; 1
    2016:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2018:	89 81       	ldd	r24, Y+1	; 0x01
    201a:	81 30       	cpi	r24, 0x01	; 1
    201c:	21 f0       	breq	.+8      	; 0x2026 <xTaskResumeAll+0xf4>
    201e:	80 91 21 03 	lds	r24, 0x0321
    2022:	81 30       	cpi	r24, 0x01	; 1
    2024:	31 f4       	brne	.+12     	; 0x2032 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    2026:	81 e0       	ldi	r24, 0x01	; 1
    2028:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    202a:	10 92 21 03 	sts	0x0321, r1
					portYIELD_WITHIN_API();
    202e:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2032:	0f 90       	pop	r0
    2034:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2036:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2038:	0f 90       	pop	r0
    203a:	0f 90       	pop	r0
    203c:	0f 90       	pop	r0
    203e:	0f 90       	pop	r0
    2040:	cf 91       	pop	r28
    2042:	df 91       	pop	r29
    2044:	08 95       	ret

00002046 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    2046:	df 93       	push	r29
    2048:	cf 93       	push	r28
    204a:	00 d0       	rcall	.+0      	; 0x204c <xTaskGetTickCount+0x6>
    204c:	cd b7       	in	r28, 0x3d	; 61
    204e:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2050:	0f b6       	in	r0, 0x3f	; 63
    2052:	f8 94       	cli
    2054:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2056:	80 91 1a 03 	lds	r24, 0x031A
    205a:	90 91 1b 03 	lds	r25, 0x031B
    205e:	9a 83       	std	Y+2, r25	; 0x02
    2060:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2062:	0f 90       	pop	r0
    2064:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2066:	89 81       	ldd	r24, Y+1	; 0x01
    2068:	9a 81       	ldd	r25, Y+2	; 0x02
}
    206a:	0f 90       	pop	r0
    206c:	0f 90       	pop	r0
    206e:	cf 91       	pop	r28
    2070:	df 91       	pop	r29
    2072:	08 95       	ret

00002074 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    2074:	df 93       	push	r29
    2076:	cf 93       	push	r28
    2078:	00 d0       	rcall	.+0      	; 0x207a <xTaskGetTickCountFromISR+0x6>
    207a:	0f 92       	push	r0
    207c:	cd b7       	in	r28, 0x3d	; 61
    207e:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2080:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    2082:	80 91 1a 03 	lds	r24, 0x031A
    2086:	90 91 1b 03 	lds	r25, 0x031B
    208a:	9b 83       	std	Y+3, r25	; 0x03
    208c:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    208e:	8a 81       	ldd	r24, Y+2	; 0x02
    2090:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2092:	0f 90       	pop	r0
    2094:	0f 90       	pop	r0
    2096:	0f 90       	pop	r0
    2098:	cf 91       	pop	r28
    209a:	df 91       	pop	r29
    209c:	08 95       	ret

0000209e <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    209e:	df 93       	push	r29
    20a0:	cf 93       	push	r28
    20a2:	cd b7       	in	r28, 0x3d	; 61
    20a4:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    20a6:	80 91 19 03 	lds	r24, 0x0319
}
    20aa:	cf 91       	pop	r28
    20ac:	df 91       	pop	r29
    20ae:	08 95       	ret

000020b0 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    20b0:	df 93       	push	r29
    20b2:	cf 93       	push	r28
    20b4:	00 d0       	rcall	.+0      	; 0x20b6 <vTaskIncrementTick+0x6>
    20b6:	00 d0       	rcall	.+0      	; 0x20b8 <vTaskIncrementTick+0x8>
    20b8:	00 d0       	rcall	.+0      	; 0x20ba <vTaskIncrementTick+0xa>
    20ba:	cd b7       	in	r28, 0x3d	; 61
    20bc:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    20be:	80 91 1f 03 	lds	r24, 0x031F
    20c2:	88 23       	and	r24, r24
    20c4:	09 f0       	breq	.+2      	; 0x20c8 <vTaskIncrementTick+0x18>
    20c6:	bb c0       	rjmp	.+374    	; 0x223e <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    20c8:	80 91 1a 03 	lds	r24, 0x031A
    20cc:	90 91 1b 03 	lds	r25, 0x031B
    20d0:	01 96       	adiw	r24, 0x01	; 1
    20d2:	90 93 1b 03 	sts	0x031B, r25
    20d6:	80 93 1a 03 	sts	0x031A, r24
		if( xTickCount == ( portTickType ) 0U )
    20da:	80 91 1a 03 	lds	r24, 0x031A
    20de:	90 91 1b 03 	lds	r25, 0x031B
    20e2:	00 97       	sbiw	r24, 0x00	; 0
    20e4:	d1 f5       	brne	.+116    	; 0x215a <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    20e6:	80 91 63 03 	lds	r24, 0x0363
    20ea:	90 91 64 03 	lds	r25, 0x0364
    20ee:	9c 83       	std	Y+4, r25	; 0x04
    20f0:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    20f2:	80 91 65 03 	lds	r24, 0x0365
    20f6:	90 91 66 03 	lds	r25, 0x0366
    20fa:	90 93 64 03 	sts	0x0364, r25
    20fe:	80 93 63 03 	sts	0x0363, r24
			pxOverflowDelayedTaskList = pxTemp;
    2102:	8b 81       	ldd	r24, Y+3	; 0x03
    2104:	9c 81       	ldd	r25, Y+4	; 0x04
    2106:	90 93 66 03 	sts	0x0366, r25
    210a:	80 93 65 03 	sts	0x0365, r24
			xNumOfOverflows++;
    210e:	80 91 22 03 	lds	r24, 0x0322
    2112:	8f 5f       	subi	r24, 0xFF	; 255
    2114:	80 93 22 03 	sts	0x0322, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2118:	e0 91 63 03 	lds	r30, 0x0363
    211c:	f0 91 64 03 	lds	r31, 0x0364
    2120:	80 81       	ld	r24, Z
    2122:	88 23       	and	r24, r24
    2124:	39 f4       	brne	.+14     	; 0x2134 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2126:	8f ef       	ldi	r24, 0xFF	; 255
    2128:	9f ef       	ldi	r25, 0xFF	; 255
    212a:	90 93 7f 00 	sts	0x007F, r25
    212e:	80 93 7e 00 	sts	0x007E, r24
    2132:	13 c0       	rjmp	.+38     	; 0x215a <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2134:	e0 91 63 03 	lds	r30, 0x0363
    2138:	f0 91 64 03 	lds	r31, 0x0364
    213c:	05 80       	ldd	r0, Z+5	; 0x05
    213e:	f6 81       	ldd	r31, Z+6	; 0x06
    2140:	e0 2d       	mov	r30, r0
    2142:	86 81       	ldd	r24, Z+6	; 0x06
    2144:	97 81       	ldd	r25, Z+7	; 0x07
    2146:	9e 83       	std	Y+6, r25	; 0x06
    2148:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    214a:	ed 81       	ldd	r30, Y+5	; 0x05
    214c:	fe 81       	ldd	r31, Y+6	; 0x06
    214e:	82 81       	ldd	r24, Z+2	; 0x02
    2150:	93 81       	ldd	r25, Z+3	; 0x03
    2152:	90 93 7f 00 	sts	0x007F, r25
    2156:	80 93 7e 00 	sts	0x007E, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    215a:	20 91 1a 03 	lds	r18, 0x031A
    215e:	30 91 1b 03 	lds	r19, 0x031B
    2162:	80 91 7e 00 	lds	r24, 0x007E
    2166:	90 91 7f 00 	lds	r25, 0x007F
    216a:	28 17       	cp	r18, r24
    216c:	39 07       	cpc	r19, r25
    216e:	08 f4       	brcc	.+2      	; 0x2172 <vTaskIncrementTick+0xc2>
    2170:	6b c0       	rjmp	.+214    	; 0x2248 <vTaskIncrementTick+0x198>
    2172:	e0 91 63 03 	lds	r30, 0x0363
    2176:	f0 91 64 03 	lds	r31, 0x0364
    217a:	80 81       	ld	r24, Z
    217c:	88 23       	and	r24, r24
    217e:	39 f4       	brne	.+14     	; 0x218e <vTaskIncrementTick+0xde>
    2180:	8f ef       	ldi	r24, 0xFF	; 255
    2182:	9f ef       	ldi	r25, 0xFF	; 255
    2184:	90 93 7f 00 	sts	0x007F, r25
    2188:	80 93 7e 00 	sts	0x007E, r24
    218c:	5d c0       	rjmp	.+186    	; 0x2248 <vTaskIncrementTick+0x198>
    218e:	e0 91 63 03 	lds	r30, 0x0363
    2192:	f0 91 64 03 	lds	r31, 0x0364
    2196:	05 80       	ldd	r0, Z+5	; 0x05
    2198:	f6 81       	ldd	r31, Z+6	; 0x06
    219a:	e0 2d       	mov	r30, r0
    219c:	86 81       	ldd	r24, Z+6	; 0x06
    219e:	97 81       	ldd	r25, Z+7	; 0x07
    21a0:	9e 83       	std	Y+6, r25	; 0x06
    21a2:	8d 83       	std	Y+5, r24	; 0x05
    21a4:	ed 81       	ldd	r30, Y+5	; 0x05
    21a6:	fe 81       	ldd	r31, Y+6	; 0x06
    21a8:	82 81       	ldd	r24, Z+2	; 0x02
    21aa:	93 81       	ldd	r25, Z+3	; 0x03
    21ac:	9a 83       	std	Y+2, r25	; 0x02
    21ae:	89 83       	std	Y+1, r24	; 0x01
    21b0:	20 91 1a 03 	lds	r18, 0x031A
    21b4:	30 91 1b 03 	lds	r19, 0x031B
    21b8:	89 81       	ldd	r24, Y+1	; 0x01
    21ba:	9a 81       	ldd	r25, Y+2	; 0x02
    21bc:	28 17       	cp	r18, r24
    21be:	39 07       	cpc	r19, r25
    21c0:	38 f4       	brcc	.+14     	; 0x21d0 <vTaskIncrementTick+0x120>
    21c2:	89 81       	ldd	r24, Y+1	; 0x01
    21c4:	9a 81       	ldd	r25, Y+2	; 0x02
    21c6:	90 93 7f 00 	sts	0x007F, r25
    21ca:	80 93 7e 00 	sts	0x007E, r24
    21ce:	3c c0       	rjmp	.+120    	; 0x2248 <vTaskIncrementTick+0x198>
    21d0:	8d 81       	ldd	r24, Y+5	; 0x05
    21d2:	9e 81       	ldd	r25, Y+6	; 0x06
    21d4:	02 96       	adiw	r24, 0x02	; 2
    21d6:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListRemove>
    21da:	ed 81       	ldd	r30, Y+5	; 0x05
    21dc:	fe 81       	ldd	r31, Y+6	; 0x06
    21de:	84 89       	ldd	r24, Z+20	; 0x14
    21e0:	95 89       	ldd	r25, Z+21	; 0x15
    21e2:	00 97       	sbiw	r24, 0x00	; 0
    21e4:	29 f0       	breq	.+10     	; 0x21f0 <vTaskIncrementTick+0x140>
    21e6:	8d 81       	ldd	r24, Y+5	; 0x05
    21e8:	9e 81       	ldd	r25, Y+6	; 0x06
    21ea:	0c 96       	adiw	r24, 0x0c	; 12
    21ec:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListRemove>
    21f0:	ed 81       	ldd	r30, Y+5	; 0x05
    21f2:	fe 81       	ldd	r31, Y+6	; 0x06
    21f4:	96 89       	ldd	r25, Z+22	; 0x16
    21f6:	80 91 1d 03 	lds	r24, 0x031D
    21fa:	89 17       	cp	r24, r25
    21fc:	28 f4       	brcc	.+10     	; 0x2208 <vTaskIncrementTick+0x158>
    21fe:	ed 81       	ldd	r30, Y+5	; 0x05
    2200:	fe 81       	ldd	r31, Y+6	; 0x06
    2202:	86 89       	ldd	r24, Z+22	; 0x16
    2204:	80 93 1d 03 	sts	0x031D, r24
    2208:	ed 81       	ldd	r30, Y+5	; 0x05
    220a:	fe 81       	ldd	r31, Y+6	; 0x06
    220c:	86 89       	ldd	r24, Z+22	; 0x16
    220e:	28 2f       	mov	r18, r24
    2210:	30 e0       	ldi	r19, 0x00	; 0
    2212:	c9 01       	movw	r24, r18
    2214:	88 0f       	add	r24, r24
    2216:	99 1f       	adc	r25, r25
    2218:	88 0f       	add	r24, r24
    221a:	99 1f       	adc	r25, r25
    221c:	88 0f       	add	r24, r24
    221e:	99 1f       	adc	r25, r25
    2220:	82 0f       	add	r24, r18
    2222:	93 1f       	adc	r25, r19
    2224:	ac 01       	movw	r20, r24
    2226:	4c 5d       	subi	r20, 0xDC	; 220
    2228:	5c 4f       	sbci	r21, 0xFC	; 252
    222a:	8d 81       	ldd	r24, Y+5	; 0x05
    222c:	9e 81       	ldd	r25, Y+6	; 0x06
    222e:	9c 01       	movw	r18, r24
    2230:	2e 5f       	subi	r18, 0xFE	; 254
    2232:	3f 4f       	sbci	r19, 0xFF	; 255
    2234:	ca 01       	movw	r24, r20
    2236:	b9 01       	movw	r22, r18
    2238:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInsertEnd>
    223c:	9a cf       	rjmp	.-204    	; 0x2172 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    223e:	80 91 20 03 	lds	r24, 0x0320
    2242:	8f 5f       	subi	r24, 0xFF	; 255
    2244:	80 93 20 03 	sts	0x0320, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2248:	26 96       	adiw	r28, 0x06	; 6
    224a:	0f b6       	in	r0, 0x3f	; 63
    224c:	f8 94       	cli
    224e:	de bf       	out	0x3e, r29	; 62
    2250:	0f be       	out	0x3f, r0	; 63
    2252:	cd bf       	out	0x3d, r28	; 61
    2254:	cf 91       	pop	r28
    2256:	df 91       	pop	r29
    2258:	08 95       	ret

0000225a <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    225a:	df 93       	push	r29
    225c:	cf 93       	push	r28
    225e:	00 d0       	rcall	.+0      	; 0x2260 <vTaskSwitchContext+0x6>
    2260:	cd b7       	in	r28, 0x3d	; 61
    2262:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2264:	80 91 1f 03 	lds	r24, 0x031F
    2268:	88 23       	and	r24, r24
    226a:	49 f0       	breq	.+18     	; 0x227e <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    226c:	81 e0       	ldi	r24, 0x01	; 1
    226e:	80 93 21 03 	sts	0x0321, r24
    2272:	54 c0       	rjmp	.+168    	; 0x231c <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2274:	80 91 1d 03 	lds	r24, 0x031D
    2278:	81 50       	subi	r24, 0x01	; 1
    227a:	80 93 1d 03 	sts	0x031D, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    227e:	80 91 1d 03 	lds	r24, 0x031D
    2282:	28 2f       	mov	r18, r24
    2284:	30 e0       	ldi	r19, 0x00	; 0
    2286:	c9 01       	movw	r24, r18
    2288:	88 0f       	add	r24, r24
    228a:	99 1f       	adc	r25, r25
    228c:	88 0f       	add	r24, r24
    228e:	99 1f       	adc	r25, r25
    2290:	88 0f       	add	r24, r24
    2292:	99 1f       	adc	r25, r25
    2294:	82 0f       	add	r24, r18
    2296:	93 1f       	adc	r25, r19
    2298:	fc 01       	movw	r30, r24
    229a:	ec 5d       	subi	r30, 0xDC	; 220
    229c:	fc 4f       	sbci	r31, 0xFC	; 252
    229e:	80 81       	ld	r24, Z
    22a0:	88 23       	and	r24, r24
    22a2:	41 f3       	breq	.-48     	; 0x2274 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    22a4:	80 91 1d 03 	lds	r24, 0x031D
    22a8:	28 2f       	mov	r18, r24
    22aa:	30 e0       	ldi	r19, 0x00	; 0
    22ac:	c9 01       	movw	r24, r18
    22ae:	88 0f       	add	r24, r24
    22b0:	99 1f       	adc	r25, r25
    22b2:	88 0f       	add	r24, r24
    22b4:	99 1f       	adc	r25, r25
    22b6:	88 0f       	add	r24, r24
    22b8:	99 1f       	adc	r25, r25
    22ba:	82 0f       	add	r24, r18
    22bc:	93 1f       	adc	r25, r19
    22be:	8c 5d       	subi	r24, 0xDC	; 220
    22c0:	9c 4f       	sbci	r25, 0xFC	; 252
    22c2:	9a 83       	std	Y+2, r25	; 0x02
    22c4:	89 83       	std	Y+1, r24	; 0x01
    22c6:	e9 81       	ldd	r30, Y+1	; 0x01
    22c8:	fa 81       	ldd	r31, Y+2	; 0x02
    22ca:	01 80       	ldd	r0, Z+1	; 0x01
    22cc:	f2 81       	ldd	r31, Z+2	; 0x02
    22ce:	e0 2d       	mov	r30, r0
    22d0:	82 81       	ldd	r24, Z+2	; 0x02
    22d2:	93 81       	ldd	r25, Z+3	; 0x03
    22d4:	e9 81       	ldd	r30, Y+1	; 0x01
    22d6:	fa 81       	ldd	r31, Y+2	; 0x02
    22d8:	92 83       	std	Z+2, r25	; 0x02
    22da:	81 83       	std	Z+1, r24	; 0x01
    22dc:	e9 81       	ldd	r30, Y+1	; 0x01
    22de:	fa 81       	ldd	r31, Y+2	; 0x02
    22e0:	21 81       	ldd	r18, Z+1	; 0x01
    22e2:	32 81       	ldd	r19, Z+2	; 0x02
    22e4:	89 81       	ldd	r24, Y+1	; 0x01
    22e6:	9a 81       	ldd	r25, Y+2	; 0x02
    22e8:	03 96       	adiw	r24, 0x03	; 3
    22ea:	28 17       	cp	r18, r24
    22ec:	39 07       	cpc	r19, r25
    22ee:	59 f4       	brne	.+22     	; 0x2306 <vTaskSwitchContext+0xac>
    22f0:	e9 81       	ldd	r30, Y+1	; 0x01
    22f2:	fa 81       	ldd	r31, Y+2	; 0x02
    22f4:	01 80       	ldd	r0, Z+1	; 0x01
    22f6:	f2 81       	ldd	r31, Z+2	; 0x02
    22f8:	e0 2d       	mov	r30, r0
    22fa:	82 81       	ldd	r24, Z+2	; 0x02
    22fc:	93 81       	ldd	r25, Z+3	; 0x03
    22fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2300:	fa 81       	ldd	r31, Y+2	; 0x02
    2302:	92 83       	std	Z+2, r25	; 0x02
    2304:	81 83       	std	Z+1, r24	; 0x01
    2306:	e9 81       	ldd	r30, Y+1	; 0x01
    2308:	fa 81       	ldd	r31, Y+2	; 0x02
    230a:	01 80       	ldd	r0, Z+1	; 0x01
    230c:	f2 81       	ldd	r31, Z+2	; 0x02
    230e:	e0 2d       	mov	r30, r0
    2310:	86 81       	ldd	r24, Z+6	; 0x06
    2312:	97 81       	ldd	r25, Z+7	; 0x07
    2314:	90 93 17 03 	sts	0x0317, r25
    2318:	80 93 16 03 	sts	0x0316, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    231c:	0f 90       	pop	r0
    231e:	0f 90       	pop	r0
    2320:	cf 91       	pop	r28
    2322:	df 91       	pop	r29
    2324:	08 95       	ret

00002326 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2326:	df 93       	push	r29
    2328:	cf 93       	push	r28
    232a:	00 d0       	rcall	.+0      	; 0x232c <vTaskPlaceOnEventList+0x6>
    232c:	00 d0       	rcall	.+0      	; 0x232e <vTaskPlaceOnEventList+0x8>
    232e:	00 d0       	rcall	.+0      	; 0x2330 <vTaskPlaceOnEventList+0xa>
    2330:	cd b7       	in	r28, 0x3d	; 61
    2332:	de b7       	in	r29, 0x3e	; 62
    2334:	9c 83       	std	Y+4, r25	; 0x04
    2336:	8b 83       	std	Y+3, r24	; 0x03
    2338:	7e 83       	std	Y+6, r23	; 0x06
    233a:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    233c:	4b 81       	ldd	r20, Y+3	; 0x03
    233e:	5c 81       	ldd	r21, Y+4	; 0x04
    2340:	80 91 16 03 	lds	r24, 0x0316
    2344:	90 91 17 03 	lds	r25, 0x0317
    2348:	9c 01       	movw	r18, r24
    234a:	24 5f       	subi	r18, 0xF4	; 244
    234c:	3f 4f       	sbci	r19, 0xFF	; 255
    234e:	ca 01       	movw	r24, r20
    2350:	b9 01       	movw	r22, r18
    2352:	0e 94 49 05 	call	0xa92	; 0xa92 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2356:	80 91 16 03 	lds	r24, 0x0316
    235a:	90 91 17 03 	lds	r25, 0x0317
    235e:	02 96       	adiw	r24, 0x02	; 2
    2360:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2364:	20 91 1a 03 	lds	r18, 0x031A
    2368:	30 91 1b 03 	lds	r19, 0x031B
    236c:	8d 81       	ldd	r24, Y+5	; 0x05
    236e:	9e 81       	ldd	r25, Y+6	; 0x06
    2370:	82 0f       	add	r24, r18
    2372:	93 1f       	adc	r25, r19
    2374:	9a 83       	std	Y+2, r25	; 0x02
    2376:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2378:	89 81       	ldd	r24, Y+1	; 0x01
    237a:	9a 81       	ldd	r25, Y+2	; 0x02
    237c:	0e 94 8d 13 	call	0x271a	; 0x271a <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2380:	26 96       	adiw	r28, 0x06	; 6
    2382:	0f b6       	in	r0, 0x3f	; 63
    2384:	f8 94       	cli
    2386:	de bf       	out	0x3e, r29	; 62
    2388:	0f be       	out	0x3f, r0	; 63
    238a:	cd bf       	out	0x3d, r28	; 61
    238c:	cf 91       	pop	r28
    238e:	df 91       	pop	r29
    2390:	08 95       	ret

00002392 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2392:	df 93       	push	r29
    2394:	cf 93       	push	r28
    2396:	00 d0       	rcall	.+0      	; 0x2398 <xTaskRemoveFromEventList+0x6>
    2398:	00 d0       	rcall	.+0      	; 0x239a <xTaskRemoveFromEventList+0x8>
    239a:	0f 92       	push	r0
    239c:	cd b7       	in	r28, 0x3d	; 61
    239e:	de b7       	in	r29, 0x3e	; 62
    23a0:	9d 83       	std	Y+5, r25	; 0x05
    23a2:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    23a4:	ec 81       	ldd	r30, Y+4	; 0x04
    23a6:	fd 81       	ldd	r31, Y+5	; 0x05
    23a8:	05 80       	ldd	r0, Z+5	; 0x05
    23aa:	f6 81       	ldd	r31, Z+6	; 0x06
    23ac:	e0 2d       	mov	r30, r0
    23ae:	86 81       	ldd	r24, Z+6	; 0x06
    23b0:	97 81       	ldd	r25, Z+7	; 0x07
    23b2:	9b 83       	std	Y+3, r25	; 0x03
    23b4:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    23b6:	8a 81       	ldd	r24, Y+2	; 0x02
    23b8:	9b 81       	ldd	r25, Y+3	; 0x03
    23ba:	0c 96       	adiw	r24, 0x0c	; 12
    23bc:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    23c0:	80 91 1f 03 	lds	r24, 0x031F
    23c4:	88 23       	and	r24, r24
    23c6:	61 f5       	brne	.+88     	; 0x2420 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    23c8:	8a 81       	ldd	r24, Y+2	; 0x02
    23ca:	9b 81       	ldd	r25, Y+3	; 0x03
    23cc:	02 96       	adiw	r24, 0x02	; 2
    23ce:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    23d2:	ea 81       	ldd	r30, Y+2	; 0x02
    23d4:	fb 81       	ldd	r31, Y+3	; 0x03
    23d6:	96 89       	ldd	r25, Z+22	; 0x16
    23d8:	80 91 1d 03 	lds	r24, 0x031D
    23dc:	89 17       	cp	r24, r25
    23de:	28 f4       	brcc	.+10     	; 0x23ea <xTaskRemoveFromEventList+0x58>
    23e0:	ea 81       	ldd	r30, Y+2	; 0x02
    23e2:	fb 81       	ldd	r31, Y+3	; 0x03
    23e4:	86 89       	ldd	r24, Z+22	; 0x16
    23e6:	80 93 1d 03 	sts	0x031D, r24
    23ea:	ea 81       	ldd	r30, Y+2	; 0x02
    23ec:	fb 81       	ldd	r31, Y+3	; 0x03
    23ee:	86 89       	ldd	r24, Z+22	; 0x16
    23f0:	28 2f       	mov	r18, r24
    23f2:	30 e0       	ldi	r19, 0x00	; 0
    23f4:	c9 01       	movw	r24, r18
    23f6:	88 0f       	add	r24, r24
    23f8:	99 1f       	adc	r25, r25
    23fa:	88 0f       	add	r24, r24
    23fc:	99 1f       	adc	r25, r25
    23fe:	88 0f       	add	r24, r24
    2400:	99 1f       	adc	r25, r25
    2402:	82 0f       	add	r24, r18
    2404:	93 1f       	adc	r25, r19
    2406:	ac 01       	movw	r20, r24
    2408:	4c 5d       	subi	r20, 0xDC	; 220
    240a:	5c 4f       	sbci	r21, 0xFC	; 252
    240c:	8a 81       	ldd	r24, Y+2	; 0x02
    240e:	9b 81       	ldd	r25, Y+3	; 0x03
    2410:	9c 01       	movw	r18, r24
    2412:	2e 5f       	subi	r18, 0xFE	; 254
    2414:	3f 4f       	sbci	r19, 0xFF	; 255
    2416:	ca 01       	movw	r24, r20
    2418:	b9 01       	movw	r22, r18
    241a:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInsertEnd>
    241e:	0a c0       	rjmp	.+20     	; 0x2434 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2420:	8a 81       	ldd	r24, Y+2	; 0x02
    2422:	9b 81       	ldd	r25, Y+3	; 0x03
    2424:	9c 01       	movw	r18, r24
    2426:	24 5f       	subi	r18, 0xF4	; 244
    2428:	3f 4f       	sbci	r19, 0xFF	; 255
    242a:	87 e6       	ldi	r24, 0x67	; 103
    242c:	93 e0       	ldi	r25, 0x03	; 3
    242e:	b9 01       	movw	r22, r18
    2430:	0e 94 fd 04 	call	0x9fa	; 0x9fa <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2434:	ea 81       	ldd	r30, Y+2	; 0x02
    2436:	fb 81       	ldd	r31, Y+3	; 0x03
    2438:	96 89       	ldd	r25, Z+22	; 0x16
    243a:	e0 91 16 03 	lds	r30, 0x0316
    243e:	f0 91 17 03 	lds	r31, 0x0317
    2442:	86 89       	ldd	r24, Z+22	; 0x16
    2444:	98 17       	cp	r25, r24
    2446:	18 f0       	brcs	.+6      	; 0x244e <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2448:	81 e0       	ldi	r24, 0x01	; 1
    244a:	89 83       	std	Y+1, r24	; 0x01
    244c:	01 c0       	rjmp	.+2      	; 0x2450 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    244e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2450:	89 81       	ldd	r24, Y+1	; 0x01
}
    2452:	0f 90       	pop	r0
    2454:	0f 90       	pop	r0
    2456:	0f 90       	pop	r0
    2458:	0f 90       	pop	r0
    245a:	0f 90       	pop	r0
    245c:	cf 91       	pop	r28
    245e:	df 91       	pop	r29
    2460:	08 95       	ret

00002462 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2462:	df 93       	push	r29
    2464:	cf 93       	push	r28
    2466:	00 d0       	rcall	.+0      	; 0x2468 <vTaskSetTimeOutState+0x6>
    2468:	cd b7       	in	r28, 0x3d	; 61
    246a:	de b7       	in	r29, 0x3e	; 62
    246c:	9a 83       	std	Y+2, r25	; 0x02
    246e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2470:	80 91 22 03 	lds	r24, 0x0322
    2474:	e9 81       	ldd	r30, Y+1	; 0x01
    2476:	fa 81       	ldd	r31, Y+2	; 0x02
    2478:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    247a:	80 91 1a 03 	lds	r24, 0x031A
    247e:	90 91 1b 03 	lds	r25, 0x031B
    2482:	e9 81       	ldd	r30, Y+1	; 0x01
    2484:	fa 81       	ldd	r31, Y+2	; 0x02
    2486:	92 83       	std	Z+2, r25	; 0x02
    2488:	81 83       	std	Z+1, r24	; 0x01
}
    248a:	0f 90       	pop	r0
    248c:	0f 90       	pop	r0
    248e:	cf 91       	pop	r28
    2490:	df 91       	pop	r29
    2492:	08 95       	ret

00002494 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2494:	df 93       	push	r29
    2496:	cf 93       	push	r28
    2498:	00 d0       	rcall	.+0      	; 0x249a <xTaskCheckForTimeOut+0x6>
    249a:	00 d0       	rcall	.+0      	; 0x249c <xTaskCheckForTimeOut+0x8>
    249c:	0f 92       	push	r0
    249e:	cd b7       	in	r28, 0x3d	; 61
    24a0:	de b7       	in	r29, 0x3e	; 62
    24a2:	9b 83       	std	Y+3, r25	; 0x03
    24a4:	8a 83       	std	Y+2, r24	; 0x02
    24a6:	7d 83       	std	Y+5, r23	; 0x05
    24a8:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    24aa:	0f b6       	in	r0, 0x3f	; 63
    24ac:	f8 94       	cli
    24ae:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    24b0:	ea 81       	ldd	r30, Y+2	; 0x02
    24b2:	fb 81       	ldd	r31, Y+3	; 0x03
    24b4:	90 81       	ld	r25, Z
    24b6:	80 91 22 03 	lds	r24, 0x0322
    24ba:	98 17       	cp	r25, r24
    24bc:	71 f0       	breq	.+28     	; 0x24da <xTaskCheckForTimeOut+0x46>
    24be:	ea 81       	ldd	r30, Y+2	; 0x02
    24c0:	fb 81       	ldd	r31, Y+3	; 0x03
    24c2:	21 81       	ldd	r18, Z+1	; 0x01
    24c4:	32 81       	ldd	r19, Z+2	; 0x02
    24c6:	80 91 1a 03 	lds	r24, 0x031A
    24ca:	90 91 1b 03 	lds	r25, 0x031B
    24ce:	82 17       	cp	r24, r18
    24d0:	93 07       	cpc	r25, r19
    24d2:	18 f0       	brcs	.+6      	; 0x24da <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    24d4:	81 e0       	ldi	r24, 0x01	; 1
    24d6:	89 83       	std	Y+1, r24	; 0x01
    24d8:	2f c0       	rjmp	.+94     	; 0x2538 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    24da:	20 91 1a 03 	lds	r18, 0x031A
    24de:	30 91 1b 03 	lds	r19, 0x031B
    24e2:	ea 81       	ldd	r30, Y+2	; 0x02
    24e4:	fb 81       	ldd	r31, Y+3	; 0x03
    24e6:	81 81       	ldd	r24, Z+1	; 0x01
    24e8:	92 81       	ldd	r25, Z+2	; 0x02
    24ea:	28 1b       	sub	r18, r24
    24ec:	39 0b       	sbc	r19, r25
    24ee:	ec 81       	ldd	r30, Y+4	; 0x04
    24f0:	fd 81       	ldd	r31, Y+5	; 0x05
    24f2:	80 81       	ld	r24, Z
    24f4:	91 81       	ldd	r25, Z+1	; 0x01
    24f6:	28 17       	cp	r18, r24
    24f8:	39 07       	cpc	r19, r25
    24fa:	e0 f4       	brcc	.+56     	; 0x2534 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    24fc:	ec 81       	ldd	r30, Y+4	; 0x04
    24fe:	fd 81       	ldd	r31, Y+5	; 0x05
    2500:	40 81       	ld	r20, Z
    2502:	51 81       	ldd	r21, Z+1	; 0x01
    2504:	ea 81       	ldd	r30, Y+2	; 0x02
    2506:	fb 81       	ldd	r31, Y+3	; 0x03
    2508:	21 81       	ldd	r18, Z+1	; 0x01
    250a:	32 81       	ldd	r19, Z+2	; 0x02
    250c:	80 91 1a 03 	lds	r24, 0x031A
    2510:	90 91 1b 03 	lds	r25, 0x031B
    2514:	b9 01       	movw	r22, r18
    2516:	68 1b       	sub	r22, r24
    2518:	79 0b       	sbc	r23, r25
    251a:	cb 01       	movw	r24, r22
    251c:	84 0f       	add	r24, r20
    251e:	95 1f       	adc	r25, r21
    2520:	ec 81       	ldd	r30, Y+4	; 0x04
    2522:	fd 81       	ldd	r31, Y+5	; 0x05
    2524:	91 83       	std	Z+1, r25	; 0x01
    2526:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    2528:	8a 81       	ldd	r24, Y+2	; 0x02
    252a:	9b 81       	ldd	r25, Y+3	; 0x03
    252c:	0e 94 31 12 	call	0x2462	; 0x2462 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2530:	19 82       	std	Y+1, r1	; 0x01
    2532:	02 c0       	rjmp	.+4      	; 0x2538 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    2534:	81 e0       	ldi	r24, 0x01	; 1
    2536:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2538:	0f 90       	pop	r0
    253a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    253c:	89 81       	ldd	r24, Y+1	; 0x01
}
    253e:	0f 90       	pop	r0
    2540:	0f 90       	pop	r0
    2542:	0f 90       	pop	r0
    2544:	0f 90       	pop	r0
    2546:	0f 90       	pop	r0
    2548:	cf 91       	pop	r28
    254a:	df 91       	pop	r29
    254c:	08 95       	ret

0000254e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    254e:	df 93       	push	r29
    2550:	cf 93       	push	r28
    2552:	cd b7       	in	r28, 0x3d	; 61
    2554:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    2556:	81 e0       	ldi	r24, 0x01	; 1
    2558:	80 93 21 03 	sts	0x0321, r24
}
    255c:	cf 91       	pop	r28
    255e:	df 91       	pop	r29
    2560:	08 95       	ret

00002562 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2562:	df 93       	push	r29
    2564:	cf 93       	push	r28
    2566:	00 d0       	rcall	.+0      	; 0x2568 <prvIdleTask+0x6>
    2568:	cd b7       	in	r28, 0x3d	; 61
    256a:	de b7       	in	r29, 0x3e	; 62
    256c:	9a 83       	std	Y+2, r25	; 0x02
    256e:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    2570:	0e 94 4f 13 	call	0x269e	; 0x269e <prvCheckTasksWaitingTermination>
    2574:	fd cf       	rjmp	.-6      	; 0x2570 <prvIdleTask+0xe>

00002576 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    2576:	0f 93       	push	r16
    2578:	1f 93       	push	r17
    257a:	df 93       	push	r29
    257c:	cf 93       	push	r28
    257e:	cd b7       	in	r28, 0x3d	; 61
    2580:	de b7       	in	r29, 0x3e	; 62
    2582:	29 97       	sbiw	r28, 0x09	; 9
    2584:	0f b6       	in	r0, 0x3f	; 63
    2586:	f8 94       	cli
    2588:	de bf       	out	0x3e, r29	; 62
    258a:	0f be       	out	0x3f, r0	; 63
    258c:	cd bf       	out	0x3d, r28	; 61
    258e:	9a 83       	std	Y+2, r25	; 0x02
    2590:	89 83       	std	Y+1, r24	; 0x01
    2592:	7c 83       	std	Y+4, r23	; 0x04
    2594:	6b 83       	std	Y+3, r22	; 0x03
    2596:	4d 83       	std	Y+5, r20	; 0x05
    2598:	3f 83       	std	Y+7, r19	; 0x07
    259a:	2e 83       	std	Y+6, r18	; 0x06
    259c:	19 87       	std	Y+9, r17	; 0x09
    259e:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    25a0:	89 81       	ldd	r24, Y+1	; 0x01
    25a2:	9a 81       	ldd	r25, Y+2	; 0x02
    25a4:	49 96       	adiw	r24, 0x19	; 25
    25a6:	2b 81       	ldd	r18, Y+3	; 0x03
    25a8:	3c 81       	ldd	r19, Y+4	; 0x04
    25aa:	b9 01       	movw	r22, r18
    25ac:	48 e0       	ldi	r20, 0x08	; 8
    25ae:	50 e0       	ldi	r21, 0x00	; 0
    25b0:	0e 94 4c 14 	call	0x2898	; 0x2898 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    25b4:	e9 81       	ldd	r30, Y+1	; 0x01
    25b6:	fa 81       	ldd	r31, Y+2	; 0x02
    25b8:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    25ba:	8d 81       	ldd	r24, Y+5	; 0x05
    25bc:	85 30       	cpi	r24, 0x05	; 5
    25be:	10 f0       	brcs	.+4      	; 0x25c4 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    25c0:	84 e0       	ldi	r24, 0x04	; 4
    25c2:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    25c4:	e9 81       	ldd	r30, Y+1	; 0x01
    25c6:	fa 81       	ldd	r31, Y+2	; 0x02
    25c8:	8d 81       	ldd	r24, Y+5	; 0x05
    25ca:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    25cc:	89 81       	ldd	r24, Y+1	; 0x01
    25ce:	9a 81       	ldd	r25, Y+2	; 0x02
    25d0:	02 96       	adiw	r24, 0x02	; 2
    25d2:	0e 94 ed 04 	call	0x9da	; 0x9da <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    25d6:	89 81       	ldd	r24, Y+1	; 0x01
    25d8:	9a 81       	ldd	r25, Y+2	; 0x02
    25da:	0c 96       	adiw	r24, 0x0c	; 12
    25dc:	0e 94 ed 04 	call	0x9da	; 0x9da <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    25e0:	e9 81       	ldd	r30, Y+1	; 0x01
    25e2:	fa 81       	ldd	r31, Y+2	; 0x02
    25e4:	89 81       	ldd	r24, Y+1	; 0x01
    25e6:	9a 81       	ldd	r25, Y+2	; 0x02
    25e8:	91 87       	std	Z+9, r25	; 0x09
    25ea:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    25ec:	8d 81       	ldd	r24, Y+5	; 0x05
    25ee:	28 2f       	mov	r18, r24
    25f0:	30 e0       	ldi	r19, 0x00	; 0
    25f2:	85 e0       	ldi	r24, 0x05	; 5
    25f4:	90 e0       	ldi	r25, 0x00	; 0
    25f6:	82 1b       	sub	r24, r18
    25f8:	93 0b       	sbc	r25, r19
    25fa:	e9 81       	ldd	r30, Y+1	; 0x01
    25fc:	fa 81       	ldd	r31, Y+2	; 0x02
    25fe:	95 87       	std	Z+13, r25	; 0x0d
    2600:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2602:	e9 81       	ldd	r30, Y+1	; 0x01
    2604:	fa 81       	ldd	r31, Y+2	; 0x02
    2606:	89 81       	ldd	r24, Y+1	; 0x01
    2608:	9a 81       	ldd	r25, Y+2	; 0x02
    260a:	93 8b       	std	Z+19, r25	; 0x13
    260c:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    260e:	29 96       	adiw	r28, 0x09	; 9
    2610:	0f b6       	in	r0, 0x3f	; 63
    2612:	f8 94       	cli
    2614:	de bf       	out	0x3e, r29	; 62
    2616:	0f be       	out	0x3f, r0	; 63
    2618:	cd bf       	out	0x3d, r28	; 61
    261a:	cf 91       	pop	r28
    261c:	df 91       	pop	r29
    261e:	1f 91       	pop	r17
    2620:	0f 91       	pop	r16
    2622:	08 95       	ret

00002624 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    2624:	df 93       	push	r29
    2626:	cf 93       	push	r28
    2628:	0f 92       	push	r0
    262a:	cd b7       	in	r28, 0x3d	; 61
    262c:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    262e:	19 82       	std	Y+1, r1	; 0x01
    2630:	13 c0       	rjmp	.+38     	; 0x2658 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2632:	89 81       	ldd	r24, Y+1	; 0x01
    2634:	28 2f       	mov	r18, r24
    2636:	30 e0       	ldi	r19, 0x00	; 0
    2638:	c9 01       	movw	r24, r18
    263a:	88 0f       	add	r24, r24
    263c:	99 1f       	adc	r25, r25
    263e:	88 0f       	add	r24, r24
    2640:	99 1f       	adc	r25, r25
    2642:	88 0f       	add	r24, r24
    2644:	99 1f       	adc	r25, r25
    2646:	82 0f       	add	r24, r18
    2648:	93 1f       	adc	r25, r19
    264a:	8c 5d       	subi	r24, 0xDC	; 220
    264c:	9c 4f       	sbci	r25, 0xFC	; 252
    264e:	0e 94 c3 04 	call	0x986	; 0x986 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2652:	89 81       	ldd	r24, Y+1	; 0x01
    2654:	8f 5f       	subi	r24, 0xFF	; 255
    2656:	89 83       	std	Y+1, r24	; 0x01
    2658:	89 81       	ldd	r24, Y+1	; 0x01
    265a:	85 30       	cpi	r24, 0x05	; 5
    265c:	50 f3       	brcs	.-44     	; 0x2632 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    265e:	81 e5       	ldi	r24, 0x51	; 81
    2660:	93 e0       	ldi	r25, 0x03	; 3
    2662:	0e 94 c3 04 	call	0x986	; 0x986 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2666:	8a e5       	ldi	r24, 0x5A	; 90
    2668:	93 e0       	ldi	r25, 0x03	; 3
    266a:	0e 94 c3 04 	call	0x986	; 0x986 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    266e:	87 e6       	ldi	r24, 0x67	; 103
    2670:	93 e0       	ldi	r25, 0x03	; 3
    2672:	0e 94 c3 04 	call	0x986	; 0x986 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2676:	80 e7       	ldi	r24, 0x70	; 112
    2678:	93 e0       	ldi	r25, 0x03	; 3
    267a:	0e 94 c3 04 	call	0x986	; 0x986 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    267e:	81 e5       	ldi	r24, 0x51	; 81
    2680:	93 e0       	ldi	r25, 0x03	; 3
    2682:	90 93 64 03 	sts	0x0364, r25
    2686:	80 93 63 03 	sts	0x0363, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    268a:	8a e5       	ldi	r24, 0x5A	; 90
    268c:	93 e0       	ldi	r25, 0x03	; 3
    268e:	90 93 66 03 	sts	0x0366, r25
    2692:	80 93 65 03 	sts	0x0365, r24
}
    2696:	0f 90       	pop	r0
    2698:	cf 91       	pop	r28
    269a:	df 91       	pop	r29
    269c:	08 95       	ret

0000269e <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    269e:	df 93       	push	r29
    26a0:	cf 93       	push	r28
    26a2:	00 d0       	rcall	.+0      	; 0x26a4 <prvCheckTasksWaitingTermination+0x6>
    26a4:	0f 92       	push	r0
    26a6:	cd b7       	in	r28, 0x3d	; 61
    26a8:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    26aa:	80 91 18 03 	lds	r24, 0x0318
    26ae:	88 23       	and	r24, r24
    26b0:	71 f1       	breq	.+92     	; 0x270e <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    26b2:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    26b6:	80 91 70 03 	lds	r24, 0x0370
    26ba:	1b 82       	std	Y+3, r1	; 0x03
    26bc:	88 23       	and	r24, r24
    26be:	11 f4       	brne	.+4      	; 0x26c4 <prvCheckTasksWaitingTermination+0x26>
    26c0:	81 e0       	ldi	r24, 0x01	; 1
    26c2:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    26c4:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    26c8:	8b 81       	ldd	r24, Y+3	; 0x03
    26ca:	88 23       	and	r24, r24
    26cc:	01 f5       	brne	.+64     	; 0x270e <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    26ce:	0f b6       	in	r0, 0x3f	; 63
    26d0:	f8 94       	cli
    26d2:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    26d4:	e0 91 75 03 	lds	r30, 0x0375
    26d8:	f0 91 76 03 	lds	r31, 0x0376
    26dc:	86 81       	ldd	r24, Z+6	; 0x06
    26de:	97 81       	ldd	r25, Z+7	; 0x07
    26e0:	9a 83       	std	Y+2, r25	; 0x02
    26e2:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    26e4:	89 81       	ldd	r24, Y+1	; 0x01
    26e6:	9a 81       	ldd	r25, Y+2	; 0x02
    26e8:	02 96       	adiw	r24, 0x02	; 2
    26ea:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListRemove>
					--uxCurrentNumberOfTasks;
    26ee:	80 91 19 03 	lds	r24, 0x0319
    26f2:	81 50       	subi	r24, 0x01	; 1
    26f4:	80 93 19 03 	sts	0x0319, r24
					--uxTasksDeleted;
    26f8:	80 91 18 03 	lds	r24, 0x0318
    26fc:	81 50       	subi	r24, 0x01	; 1
    26fe:	80 93 18 03 	sts	0x0318, r24
				}
				taskEXIT_CRITICAL();
    2702:	0f 90       	pop	r0
    2704:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2706:	89 81       	ldd	r24, Y+1	; 0x01
    2708:	9a 81       	ldd	r25, Y+2	; 0x02
    270a:	0e 94 26 14 	call	0x284c	; 0x284c <prvDeleteTCB>
			}
		}
	}
	#endif
}
    270e:	0f 90       	pop	r0
    2710:	0f 90       	pop	r0
    2712:	0f 90       	pop	r0
    2714:	cf 91       	pop	r28
    2716:	df 91       	pop	r29
    2718:	08 95       	ret

0000271a <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    271a:	df 93       	push	r29
    271c:	cf 93       	push	r28
    271e:	00 d0       	rcall	.+0      	; 0x2720 <prvAddCurrentTaskToDelayedList+0x6>
    2720:	cd b7       	in	r28, 0x3d	; 61
    2722:	de b7       	in	r29, 0x3e	; 62
    2724:	9a 83       	std	Y+2, r25	; 0x02
    2726:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2728:	e0 91 16 03 	lds	r30, 0x0316
    272c:	f0 91 17 03 	lds	r31, 0x0317
    2730:	89 81       	ldd	r24, Y+1	; 0x01
    2732:	9a 81       	ldd	r25, Y+2	; 0x02
    2734:	93 83       	std	Z+3, r25	; 0x03
    2736:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    2738:	20 91 1a 03 	lds	r18, 0x031A
    273c:	30 91 1b 03 	lds	r19, 0x031B
    2740:	89 81       	ldd	r24, Y+1	; 0x01
    2742:	9a 81       	ldd	r25, Y+2	; 0x02
    2744:	82 17       	cp	r24, r18
    2746:	93 07       	cpc	r25, r19
    2748:	70 f4       	brcc	.+28     	; 0x2766 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    274a:	80 91 65 03 	lds	r24, 0x0365
    274e:	90 91 66 03 	lds	r25, 0x0366
    2752:	20 91 16 03 	lds	r18, 0x0316
    2756:	30 91 17 03 	lds	r19, 0x0317
    275a:	2e 5f       	subi	r18, 0xFE	; 254
    275c:	3f 4f       	sbci	r19, 0xFF	; 255
    275e:	b9 01       	movw	r22, r18
    2760:	0e 94 49 05 	call	0xa92	; 0xa92 <vListInsert>
    2764:	1e c0       	rjmp	.+60     	; 0x27a2 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2766:	40 91 63 03 	lds	r20, 0x0363
    276a:	50 91 64 03 	lds	r21, 0x0364
    276e:	80 91 16 03 	lds	r24, 0x0316
    2772:	90 91 17 03 	lds	r25, 0x0317
    2776:	9c 01       	movw	r18, r24
    2778:	2e 5f       	subi	r18, 0xFE	; 254
    277a:	3f 4f       	sbci	r19, 0xFF	; 255
    277c:	ca 01       	movw	r24, r20
    277e:	b9 01       	movw	r22, r18
    2780:	0e 94 49 05 	call	0xa92	; 0xa92 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    2784:	20 91 7e 00 	lds	r18, 0x007E
    2788:	30 91 7f 00 	lds	r19, 0x007F
    278c:	89 81       	ldd	r24, Y+1	; 0x01
    278e:	9a 81       	ldd	r25, Y+2	; 0x02
    2790:	82 17       	cp	r24, r18
    2792:	93 07       	cpc	r25, r19
    2794:	30 f4       	brcc	.+12     	; 0x27a2 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    2796:	89 81       	ldd	r24, Y+1	; 0x01
    2798:	9a 81       	ldd	r25, Y+2	; 0x02
    279a:	90 93 7f 00 	sts	0x007F, r25
    279e:	80 93 7e 00 	sts	0x007E, r24
		}
	}
}
    27a2:	0f 90       	pop	r0
    27a4:	0f 90       	pop	r0
    27a6:	cf 91       	pop	r28
    27a8:	df 91       	pop	r29
    27aa:	08 95       	ret

000027ac <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    27ac:	df 93       	push	r29
    27ae:	cf 93       	push	r28
    27b0:	cd b7       	in	r28, 0x3d	; 61
    27b2:	de b7       	in	r29, 0x3e	; 62
    27b4:	28 97       	sbiw	r28, 0x08	; 8
    27b6:	0f b6       	in	r0, 0x3f	; 63
    27b8:	f8 94       	cli
    27ba:	de bf       	out	0x3e, r29	; 62
    27bc:	0f be       	out	0x3f, r0	; 63
    27be:	cd bf       	out	0x3d, r28	; 61
    27c0:	9c 83       	std	Y+4, r25	; 0x04
    27c2:	8b 83       	std	Y+3, r24	; 0x03
    27c4:	7e 83       	std	Y+6, r23	; 0x06
    27c6:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    27c8:	81 e2       	ldi	r24, 0x21	; 33
    27ca:	90 e0       	ldi	r25, 0x00	; 0
    27cc:	0e 94 57 04 	call	0x8ae	; 0x8ae <pvPortMalloc>
    27d0:	9a 83       	std	Y+2, r25	; 0x02
    27d2:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    27d4:	89 81       	ldd	r24, Y+1	; 0x01
    27d6:	9a 81       	ldd	r25, Y+2	; 0x02
    27d8:	00 97       	sbiw	r24, 0x00	; 0
    27da:	69 f1       	breq	.+90     	; 0x2836 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    27dc:	8d 81       	ldd	r24, Y+5	; 0x05
    27de:	9e 81       	ldd	r25, Y+6	; 0x06
    27e0:	00 97       	sbiw	r24, 0x00	; 0
    27e2:	39 f4       	brne	.+14     	; 0x27f2 <prvAllocateTCBAndStack+0x46>
    27e4:	8b 81       	ldd	r24, Y+3	; 0x03
    27e6:	9c 81       	ldd	r25, Y+4	; 0x04
    27e8:	0e 94 57 04 	call	0x8ae	; 0x8ae <pvPortMalloc>
    27ec:	98 87       	std	Y+8, r25	; 0x08
    27ee:	8f 83       	std	Y+7, r24	; 0x07
    27f0:	04 c0       	rjmp	.+8      	; 0x27fa <prvAllocateTCBAndStack+0x4e>
    27f2:	8d 81       	ldd	r24, Y+5	; 0x05
    27f4:	9e 81       	ldd	r25, Y+6	; 0x06
    27f6:	98 87       	std	Y+8, r25	; 0x08
    27f8:	8f 83       	std	Y+7, r24	; 0x07
    27fa:	e9 81       	ldd	r30, Y+1	; 0x01
    27fc:	fa 81       	ldd	r31, Y+2	; 0x02
    27fe:	8f 81       	ldd	r24, Y+7	; 0x07
    2800:	98 85       	ldd	r25, Y+8	; 0x08
    2802:	90 8f       	std	Z+24, r25	; 0x18
    2804:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2806:	e9 81       	ldd	r30, Y+1	; 0x01
    2808:	fa 81       	ldd	r31, Y+2	; 0x02
    280a:	87 89       	ldd	r24, Z+23	; 0x17
    280c:	90 8d       	ldd	r25, Z+24	; 0x18
    280e:	00 97       	sbiw	r24, 0x00	; 0
    2810:	39 f4       	brne	.+14     	; 0x2820 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2812:	89 81       	ldd	r24, Y+1	; 0x01
    2814:	9a 81       	ldd	r25, Y+2	; 0x02
    2816:	0e 94 9d 04 	call	0x93a	; 0x93a <vPortFree>
			pxNewTCB = NULL;
    281a:	1a 82       	std	Y+2, r1	; 0x02
    281c:	19 82       	std	Y+1, r1	; 0x01
    281e:	0b c0       	rjmp	.+22     	; 0x2836 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    2820:	e9 81       	ldd	r30, Y+1	; 0x01
    2822:	fa 81       	ldd	r31, Y+2	; 0x02
    2824:	87 89       	ldd	r24, Z+23	; 0x17
    2826:	90 8d       	ldd	r25, Z+24	; 0x18
    2828:	2b 81       	ldd	r18, Y+3	; 0x03
    282a:	3c 81       	ldd	r19, Y+4	; 0x04
    282c:	65 ea       	ldi	r22, 0xA5	; 165
    282e:	70 e0       	ldi	r23, 0x00	; 0
    2830:	a9 01       	movw	r20, r18
    2832:	0e 94 45 14 	call	0x288a	; 0x288a <memset>
		}
	}

	return pxNewTCB;
    2836:	89 81       	ldd	r24, Y+1	; 0x01
    2838:	9a 81       	ldd	r25, Y+2	; 0x02
}
    283a:	28 96       	adiw	r28, 0x08	; 8
    283c:	0f b6       	in	r0, 0x3f	; 63
    283e:	f8 94       	cli
    2840:	de bf       	out	0x3e, r29	; 62
    2842:	0f be       	out	0x3f, r0	; 63
    2844:	cd bf       	out	0x3d, r28	; 61
    2846:	cf 91       	pop	r28
    2848:	df 91       	pop	r29
    284a:	08 95       	ret

0000284c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    284c:	df 93       	push	r29
    284e:	cf 93       	push	r28
    2850:	00 d0       	rcall	.+0      	; 0x2852 <prvDeleteTCB+0x6>
    2852:	cd b7       	in	r28, 0x3d	; 61
    2854:	de b7       	in	r29, 0x3e	; 62
    2856:	9a 83       	std	Y+2, r25	; 0x02
    2858:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    285a:	e9 81       	ldd	r30, Y+1	; 0x01
    285c:	fa 81       	ldd	r31, Y+2	; 0x02
    285e:	87 89       	ldd	r24, Z+23	; 0x17
    2860:	90 8d       	ldd	r25, Z+24	; 0x18
    2862:	0e 94 9d 04 	call	0x93a	; 0x93a <vPortFree>
		vPortFree( pxTCB );
    2866:	89 81       	ldd	r24, Y+1	; 0x01
    2868:	9a 81       	ldd	r25, Y+2	; 0x02
    286a:	0e 94 9d 04 	call	0x93a	; 0x93a <vPortFree>
	}
    286e:	0f 90       	pop	r0
    2870:	0f 90       	pop	r0
    2872:	cf 91       	pop	r28
    2874:	df 91       	pop	r29
    2876:	08 95       	ret

00002878 <memcpy>:
    2878:	fb 01       	movw	r30, r22
    287a:	dc 01       	movw	r26, r24
    287c:	02 c0       	rjmp	.+4      	; 0x2882 <memcpy+0xa>
    287e:	01 90       	ld	r0, Z+
    2880:	0d 92       	st	X+, r0
    2882:	41 50       	subi	r20, 0x01	; 1
    2884:	50 40       	sbci	r21, 0x00	; 0
    2886:	d8 f7       	brcc	.-10     	; 0x287e <memcpy+0x6>
    2888:	08 95       	ret

0000288a <memset>:
    288a:	dc 01       	movw	r26, r24
    288c:	01 c0       	rjmp	.+2      	; 0x2890 <memset+0x6>
    288e:	6d 93       	st	X+, r22
    2890:	41 50       	subi	r20, 0x01	; 1
    2892:	50 40       	sbci	r21, 0x00	; 0
    2894:	e0 f7       	brcc	.-8      	; 0x288e <memset+0x4>
    2896:	08 95       	ret

00002898 <strncpy>:
    2898:	fb 01       	movw	r30, r22
    289a:	dc 01       	movw	r26, r24
    289c:	41 50       	subi	r20, 0x01	; 1
    289e:	50 40       	sbci	r21, 0x00	; 0
    28a0:	48 f0       	brcs	.+18     	; 0x28b4 <strncpy+0x1c>
    28a2:	01 90       	ld	r0, Z+
    28a4:	0d 92       	st	X+, r0
    28a6:	00 20       	and	r0, r0
    28a8:	c9 f7       	brne	.-14     	; 0x289c <strncpy+0x4>
    28aa:	01 c0       	rjmp	.+2      	; 0x28ae <strncpy+0x16>
    28ac:	1d 92       	st	X+, r1
    28ae:	41 50       	subi	r20, 0x01	; 1
    28b0:	50 40       	sbci	r21, 0x00	; 0
    28b2:	e0 f7       	brcc	.-8      	; 0x28ac <strncpy+0x14>
    28b4:	08 95       	ret

000028b6 <_exit>:
    28b6:	f8 94       	cli

000028b8 <__stop_program>:
    28b8:	ff cf       	rjmp	.-2      	; 0x28b8 <__stop_program>
