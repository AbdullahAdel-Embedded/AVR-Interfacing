
RTOS_Task7_TryDisableScheduling.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000027f0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001a  00800060  000027f0  00002884  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002f8  0080007a  0080007a  0000289e  2**0
                  ALLOC
  3 .stab         00004620  00000000  00000000  000028a0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002b3c  00000000  00000000  00006ec0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 68 08 	jmp	0x10d0	; 0x10d0 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 ef       	ldi	r30, 0xF0	; 240
      68:	f7 e2       	ldi	r31, 0x27	; 39
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	aa 37       	cpi	r26, 0x7A	; 122
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	aa e7       	ldi	r26, 0x7A	; 122
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a2 37       	cpi	r26, 0x72	; 114
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 49 00 	call	0x92	; 0x92 <main>
      8a:	0c 94 f6 13 	jmp	0x27ec	; 0x27ec <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <main>:
      92:	af 92       	push	r10
      94:	bf 92       	push	r11
      96:	cf 92       	push	r12
      98:	df 92       	push	r13
      9a:	ef 92       	push	r14
      9c:	ff 92       	push	r15
      9e:	0f 93       	push	r16
      a0:	df 93       	push	r29
      a2:	cf 93       	push	r28
      a4:	00 d0       	rcall	.+0      	; 0xa6 <main+0x14>
      a6:	00 d0       	rcall	.+0      	; 0xa8 <main+0x16>
      a8:	cd b7       	in	r28, 0x3d	; 61
      aa:	de b7       	in	r29, 0x3e	; 62
      ac:	1a 82       	std	Y+2, r1	; 0x02
      ae:	19 82       	std	Y+1, r1	; 0x01
      b0:	20 e6       	ldi	r18, 0x60	; 96
      b2:	30 e0       	ldi	r19, 0x00	; 0
      b4:	86 ea       	ldi	r24, 0xA6	; 166
      b6:	90 e0       	ldi	r25, 0x00	; 0
      b8:	b9 01       	movw	r22, r18
      ba:	45 e5       	ldi	r20, 0x55	; 85
      bc:	50 e0       	ldi	r21, 0x00	; 0
      be:	20 e0       	ldi	r18, 0x00	; 0
      c0:	30 e0       	ldi	r19, 0x00	; 0
      c2:	01 e0       	ldi	r16, 0x01	; 1
      c4:	fe 01       	movw	r30, r28
      c6:	31 96       	adiw	r30, 0x01	; 1
      c8:	7f 01       	movw	r14, r30
      ca:	cc 24       	eor	r12, r12
      cc:	dd 24       	eor	r13, r13
      ce:	aa 24       	eor	r10, r10
      d0:	bb 24       	eor	r11, r11
      d2:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <xTaskGenericCreate>
      d6:	1c 82       	std	Y+4, r1	; 0x04
      d8:	1b 82       	std	Y+3, r1	; 0x03
      da:	2c e6       	ldi	r18, 0x6C	; 108
      dc:	30 e0       	ldi	r19, 0x00	; 0
      de:	8e ed       	ldi	r24, 0xDE	; 222
      e0:	90 e0       	ldi	r25, 0x00	; 0
      e2:	fe 01       	movw	r30, r28
      e4:	33 96       	adiw	r30, 0x03	; 3
      e6:	b9 01       	movw	r22, r18
      e8:	45 e5       	ldi	r20, 0x55	; 85
      ea:	50 e0       	ldi	r21, 0x00	; 0
      ec:	20 e0       	ldi	r18, 0x00	; 0
      ee:	30 e0       	ldi	r19, 0x00	; 0
      f0:	02 e0       	ldi	r16, 0x02	; 2
      f2:	7f 01       	movw	r14, r30
      f4:	cc 24       	eor	r12, r12
      f6:	dd 24       	eor	r13, r13
      f8:	aa 24       	eor	r10, r10
      fa:	bb 24       	eor	r11, r11
      fc:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <xTaskGenericCreate>
     100:	0e 94 94 00 	call	0x128	; 0x128 <init>
     104:	0e 94 e5 0e 	call	0x1dca	; 0x1dca <vTaskStartScheduler>
     108:	80 e0       	ldi	r24, 0x00	; 0
     10a:	90 e0       	ldi	r25, 0x00	; 0
     10c:	0f 90       	pop	r0
     10e:	0f 90       	pop	r0
     110:	0f 90       	pop	r0
     112:	0f 90       	pop	r0
     114:	cf 91       	pop	r28
     116:	df 91       	pop	r29
     118:	0f 91       	pop	r16
     11a:	ff 90       	pop	r15
     11c:	ef 90       	pop	r14
     11e:	df 90       	pop	r13
     120:	cf 90       	pop	r12
     122:	bf 90       	pop	r11
     124:	af 90       	pop	r10
     126:	08 95       	ret

00000128 <init>:

	/*Never Enter Here */
	return 0;
}

void init(void){
     128:	df 93       	push	r29
     12a:	cf 93       	push	r28
     12c:	cd b7       	in	r28, 0x3d	; 61
     12e:	de b7       	in	r29, 0x3e	; 62

	DDRB = 0xFF;
     130:	e7 e3       	ldi	r30, 0x37	; 55
     132:	f0 e0       	ldi	r31, 0x00	; 0
     134:	8f ef       	ldi	r24, 0xFF	; 255
     136:	80 83       	st	Z, r24

	DDRC = 0x00;
     138:	e4 e3       	ldi	r30, 0x34	; 52
     13a:	f0 e0       	ldi	r31, 0x00	; 0
     13c:	10 82       	st	Z, r1

	PORTC = 0xFF;
     13e:	e5 e3       	ldi	r30, 0x35	; 53
     140:	f0 e0       	ldi	r31, 0x00	; 0
     142:	8f ef       	ldi	r24, 0xFF	; 255
     144:	80 83       	st	Z, r24

}
     146:	cf 91       	pop	r28
     148:	df 91       	pop	r29
     14a:	08 95       	ret

0000014c <PushButton>:
 void PushButton(void * pvparam){
     14c:	df 93       	push	r29
     14e:	cf 93       	push	r28
     150:	00 d0       	rcall	.+0      	; 0x152 <PushButton+0x6>
     152:	00 d0       	rcall	.+0      	; 0x154 <PushButton+0x8>
     154:	00 d0       	rcall	.+0      	; 0x156 <PushButton+0xa>
     156:	cd b7       	in	r28, 0x3d	; 61
     158:	de b7       	in	r29, 0x3e	; 62
     15a:	9e 83       	std	Y+6, r25	; 0x06
     15c:	8d 83       	std	Y+5, r24	; 0x05
	 portTickType Freq = 100;
     15e:	84 e6       	ldi	r24, 0x64	; 100
     160:	90 e0       	ldi	r25, 0x00	; 0
     162:	9a 83       	std	Y+2, r25	; 0x02
     164:	89 83       	std	Y+1, r24	; 0x01
	 portTickType Start = xTaskGetTickCount();
     166:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <xTaskGetTickCount>
     16a:	9c 83       	std	Y+4, r25	; 0x04
     16c:	8b 83       	std	Y+3, r24	; 0x03
	 while (1){
		 /* if the Push Button is Pressed */
		 if ((PINC & 0x01) == 0){
     16e:	e3 e3       	ldi	r30, 0x33	; 51
     170:	f0 e0       	ldi	r31, 0x00	; 0
     172:	80 81       	ld	r24, Z
     174:	88 2f       	mov	r24, r24
     176:	90 e0       	ldi	r25, 0x00	; 0
     178:	81 70       	andi	r24, 0x01	; 1
     17a:	90 70       	andi	r25, 0x00	; 0
     17c:	00 97       	sbiw	r24, 0x00	; 0
     17e:	b1 f4       	brne	.+44     	; 0x1ac <PushButton+0x60>

			 /* If the Resource No One is Using so Stop Scheduling to Use it **/
			 if(ButtonStateFlag == 0){
     180:	80 91 7a 00 	lds	r24, 0x007A
     184:	88 23       	and	r24, r24
     186:	71 f4       	brne	.+28     	; 0x1a4 <PushButton+0x58>
				 /**Disable Global Interrupt*/
				 SREG = 0;
     188:	ef e5       	ldi	r30, 0x5F	; 95
     18a:	f0 e0       	ldi	r31, 0x00	; 0
     18c:	10 82       	st	Z, r1

				 /*Raise the Flag */
				 ButtonStateFlag = 1;
     18e:	81 e0       	ldi	r24, 0x01	; 1
     190:	80 93 7a 00 	sts	0x007A, r24
				 /**Enable Global Interrupt*/
				 SREG = 128;
				#endif

				 /*Change the State **/
				 ButtonState = 0;
     194:	10 92 76 00 	sts	0x0076, r1


				 /**Disable Global Interrupt*/
				 SREG = 0;
     198:	ef e5       	ldi	r30, 0x5F	; 95
     19a:	f0 e0       	ldi	r31, 0x00	; 0
     19c:	10 82       	st	Z, r1

				 /*Release the Flag */
				 ButtonStateFlag = 0;
     19e:	10 92 7a 00 	sts	0x007A, r1
     1a2:	04 c0       	rjmp	.+8      	; 0x1ac <PushButton+0x60>
				 SREG = 128;
				#endif
			 }
			 /*Else Delay 10 Tick till the Resource is Free **/
			 else {
				 vTaskDelay(10);
     1a4:	8a e0       	ldi	r24, 0x0A	; 10
     1a6:	90 e0       	ldi	r25, 0x00	; 0
     1a8:	0e 94 b0 0e 	call	0x1d60	; 0x1d60 <vTaskDelay>
			 }

		 }

		 /*Make the Task Periodic with Period 50 Tick */
		 vTaskDelayUntil(&Start,Freq);
     1ac:	ce 01       	movw	r24, r28
     1ae:	03 96       	adiw	r24, 0x03	; 3
     1b0:	29 81       	ldd	r18, Y+1	; 0x01
     1b2:	3a 81       	ldd	r19, Y+2	; 0x02
     1b4:	b9 01       	movw	r22, r18
     1b6:	0e 94 3c 0e 	call	0x1c78	; 0x1c78 <vTaskDelayUntil>
     1ba:	d9 cf       	rjmp	.-78     	; 0x16e <PushButton+0x22>

000001bc <Led>:
	 }

 }


 void Led(void * pvparam){
     1bc:	df 93       	push	r29
     1be:	cf 93       	push	r28
     1c0:	00 d0       	rcall	.+0      	; 0x1c2 <Led+0x6>
     1c2:	00 d0       	rcall	.+0      	; 0x1c4 <Led+0x8>
     1c4:	00 d0       	rcall	.+0      	; 0x1c6 <Led+0xa>
     1c6:	cd b7       	in	r28, 0x3d	; 61
     1c8:	de b7       	in	r29, 0x3e	; 62
     1ca:	9e 83       	std	Y+6, r25	; 0x06
     1cc:	8d 83       	std	Y+5, r24	; 0x05
	 portTickType Freq = 100;
     1ce:	84 e6       	ldi	r24, 0x64	; 100
     1d0:	90 e0       	ldi	r25, 0x00	; 0
     1d2:	9a 83       	std	Y+2, r25	; 0x02
     1d4:	89 83       	std	Y+1, r24	; 0x01
	 portTickType Start = xTaskGetTickCount();
     1d6:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <xTaskGetTickCount>
     1da:	9c 83       	std	Y+4, r25	; 0x04
     1dc:	8b 83       	std	Y+3, r24	; 0x03
	 while (1){
		 /* if the Push Button is Pressed */


		 /* If the Resource No One is Using so Raise a Flag to Use it **/
		 if(ButtonStateFlag == 0){
     1de:	80 91 7a 00 	lds	r24, 0x007A
     1e2:	88 23       	and	r24, r24
     1e4:	d9 f4       	brne	.+54     	; 0x21c <Led+0x60>
			 /**Disable Global Interrupt*/
			 SREG = 0 ;
     1e6:	ef e5       	ldi	r30, 0x5F	; 95
     1e8:	f0 e0       	ldi	r31, 0x00	; 0
     1ea:	10 82       	st	Z, r1

			 /*Raise the Flag */
			 ButtonStateFlag = 1;
     1ec:	81 e0       	ldi	r24, 0x01	; 1
     1ee:	80 93 7a 00 	sts	0x007A, r24
			#if (FrogetGlobalInterrupt == 0)
			 /**Enable Global Interrupt*/
			 SREG = 128;
			#endif

			 if (ButtonState == 0){
     1f2:	80 91 76 00 	lds	r24, 0x0076
     1f6:	88 23       	and	r24, r24
     1f8:	59 f4       	brne	.+22     	; 0x210 <Led+0x54>
				 PORTB ^= 0x01;
     1fa:	a8 e3       	ldi	r26, 0x38	; 56
     1fc:	b0 e0       	ldi	r27, 0x00	; 0
     1fe:	e8 e3       	ldi	r30, 0x38	; 56
     200:	f0 e0       	ldi	r31, 0x00	; 0
     202:	90 81       	ld	r25, Z
     204:	81 e0       	ldi	r24, 0x01	; 1
     206:	89 27       	eor	r24, r25
     208:	8c 93       	st	X, r24
				 ButtonState = 1;
     20a:	81 e0       	ldi	r24, 0x01	; 1
     20c:	80 93 76 00 	sts	0x0076, r24
			 }

			 /**Disable Global Interrupt*/
			 SREG = 0;
     210:	ef e5       	ldi	r30, 0x5F	; 95
     212:	f0 e0       	ldi	r31, 0x00	; 0
     214:	10 82       	st	Z, r1

			 /*Release the Flag */
			 ButtonStateFlag = 0;
     216:	10 92 7a 00 	sts	0x007A, r1
     21a:	04 c0       	rjmp	.+8      	; 0x224 <Led+0x68>
			 SREG = 128;
			#endif
		 }
		 /*Else Delay 10 Tick till the Resource is Free **/
		 else {
			 vTaskDelay(10);
     21c:	8a e0       	ldi	r24, 0x0A	; 10
     21e:	90 e0       	ldi	r25, 0x00	; 0
     220:	0e 94 b0 0e 	call	0x1d60	; 0x1d60 <vTaskDelay>
		 }

		 /*Make the Task Periodic with Period 50 Tick */
		 vTaskDelayUntil(&Start,Freq);
     224:	ce 01       	movw	r24, r28
     226:	03 96       	adiw	r24, 0x03	; 3
     228:	29 81       	ldd	r18, Y+1	; 0x01
     22a:	3a 81       	ldd	r19, Y+2	; 0x02
     22c:	b9 01       	movw	r22, r18
     22e:	0e 94 3c 0e 	call	0x1c78	; 0x1c78 <vTaskDelayUntil>
     232:	d5 cf       	rjmp	.-86     	; 0x1de <Led+0x22>

00000234 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     234:	df 93       	push	r29
     236:	cf 93       	push	r28
     238:	cd b7       	in	r28, 0x3d	; 61
     23a:	de b7       	in	r29, 0x3e	; 62
     23c:	27 97       	sbiw	r28, 0x07	; 7
     23e:	0f b6       	in	r0, 0x3f	; 63
     240:	f8 94       	cli
     242:	de bf       	out	0x3e, r29	; 62
     244:	0f be       	out	0x3f, r0	; 63
     246:	cd bf       	out	0x3d, r28	; 61
     248:	9d 83       	std	Y+5, r25	; 0x05
     24a:	8c 83       	std	Y+4, r24	; 0x04
     24c:	6e 83       	std	Y+6, r22	; 0x06
     24e:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     250:	8a e1       	ldi	r24, 0x1A	; 26
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <pvPortMalloc>
     258:	9a 83       	std	Y+2, r25	; 0x02
     25a:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     25c:	89 81       	ldd	r24, Y+1	; 0x01
     25e:	9a 81       	ldd	r25, Y+2	; 0x02
     260:	00 97       	sbiw	r24, 0x00	; 0
     262:	09 f4       	brne	.+2      	; 0x266 <xCoRoutineCreate+0x32>
     264:	6f c0       	rjmp	.+222    	; 0x344 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     266:	80 91 7b 00 	lds	r24, 0x007B
     26a:	90 91 7c 00 	lds	r25, 0x007C
     26e:	00 97       	sbiw	r24, 0x00	; 0
     270:	41 f4       	brne	.+16     	; 0x282 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     272:	89 81       	ldd	r24, Y+1	; 0x01
     274:	9a 81       	ldd	r25, Y+2	; 0x02
     276:	90 93 7c 00 	sts	0x007C, r25
     27a:	80 93 7b 00 	sts	0x007B, r24
			prvInitialiseCoRoutineLists();
     27e:	0e 94 81 03 	call	0x702	; 0x702 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     282:	8e 81       	ldd	r24, Y+6	; 0x06
     284:	82 30       	cpi	r24, 0x02	; 2
     286:	10 f0       	brcs	.+4      	; 0x28c <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     288:	81 e0       	ldi	r24, 0x01	; 1
     28a:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     28c:	e9 81       	ldd	r30, Y+1	; 0x01
     28e:	fa 81       	ldd	r31, Y+2	; 0x02
     290:	11 8e       	std	Z+25, r1	; 0x19
     292:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     294:	e9 81       	ldd	r30, Y+1	; 0x01
     296:	fa 81       	ldd	r31, Y+2	; 0x02
     298:	8e 81       	ldd	r24, Y+6	; 0x06
     29a:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     29c:	e9 81       	ldd	r30, Y+1	; 0x01
     29e:	fa 81       	ldd	r31, Y+2	; 0x02
     2a0:	8f 81       	ldd	r24, Y+7	; 0x07
     2a2:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     2a4:	e9 81       	ldd	r30, Y+1	; 0x01
     2a6:	fa 81       	ldd	r31, Y+2	; 0x02
     2a8:	8c 81       	ldd	r24, Y+4	; 0x04
     2aa:	9d 81       	ldd	r25, Y+5	; 0x05
     2ac:	91 83       	std	Z+1, r25	; 0x01
     2ae:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     2b0:	89 81       	ldd	r24, Y+1	; 0x01
     2b2:	9a 81       	ldd	r25, Y+2	; 0x02
     2b4:	02 96       	adiw	r24, 0x02	; 2
     2b6:	0e 94 88 04 	call	0x910	; 0x910 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     2ba:	89 81       	ldd	r24, Y+1	; 0x01
     2bc:	9a 81       	ldd	r25, Y+2	; 0x02
     2be:	0c 96       	adiw	r24, 0x0c	; 12
     2c0:	0e 94 88 04 	call	0x910	; 0x910 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     2c4:	e9 81       	ldd	r30, Y+1	; 0x01
     2c6:	fa 81       	ldd	r31, Y+2	; 0x02
     2c8:	89 81       	ldd	r24, Y+1	; 0x01
     2ca:	9a 81       	ldd	r25, Y+2	; 0x02
     2cc:	91 87       	std	Z+9, r25	; 0x09
     2ce:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     2d0:	e9 81       	ldd	r30, Y+1	; 0x01
     2d2:	fa 81       	ldd	r31, Y+2	; 0x02
     2d4:	89 81       	ldd	r24, Y+1	; 0x01
     2d6:	9a 81       	ldd	r25, Y+2	; 0x02
     2d8:	93 8b       	std	Z+19, r25	; 0x13
     2da:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     2dc:	8e 81       	ldd	r24, Y+6	; 0x06
     2de:	28 2f       	mov	r18, r24
     2e0:	30 e0       	ldi	r19, 0x00	; 0
     2e2:	85 e0       	ldi	r24, 0x05	; 5
     2e4:	90 e0       	ldi	r25, 0x00	; 0
     2e6:	82 1b       	sub	r24, r18
     2e8:	93 0b       	sbc	r25, r19
     2ea:	e9 81       	ldd	r30, Y+1	; 0x01
     2ec:	fa 81       	ldd	r31, Y+2	; 0x02
     2ee:	95 87       	std	Z+13, r25	; 0x0d
     2f0:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     2f2:	e9 81       	ldd	r30, Y+1	; 0x01
     2f4:	fa 81       	ldd	r31, Y+2	; 0x02
     2f6:	96 89       	ldd	r25, Z+22	; 0x16
     2f8:	80 91 7d 00 	lds	r24, 0x007D
     2fc:	89 17       	cp	r24, r25
     2fe:	28 f4       	brcc	.+10     	; 0x30a <xCoRoutineCreate+0xd6>
     300:	e9 81       	ldd	r30, Y+1	; 0x01
     302:	fa 81       	ldd	r31, Y+2	; 0x02
     304:	86 89       	ldd	r24, Z+22	; 0x16
     306:	80 93 7d 00 	sts	0x007D, r24
     30a:	e9 81       	ldd	r30, Y+1	; 0x01
     30c:	fa 81       	ldd	r31, Y+2	; 0x02
     30e:	86 89       	ldd	r24, Z+22	; 0x16
     310:	28 2f       	mov	r18, r24
     312:	30 e0       	ldi	r19, 0x00	; 0
     314:	c9 01       	movw	r24, r18
     316:	88 0f       	add	r24, r24
     318:	99 1f       	adc	r25, r25
     31a:	88 0f       	add	r24, r24
     31c:	99 1f       	adc	r25, r25
     31e:	88 0f       	add	r24, r24
     320:	99 1f       	adc	r25, r25
     322:	82 0f       	add	r24, r18
     324:	93 1f       	adc	r25, r19
     326:	ac 01       	movw	r20, r24
     328:	4c 57       	subi	r20, 0x7C	; 124
     32a:	5f 4f       	sbci	r21, 0xFF	; 255
     32c:	89 81       	ldd	r24, Y+1	; 0x01
     32e:	9a 81       	ldd	r25, Y+2	; 0x02
     330:	9c 01       	movw	r18, r24
     332:	2e 5f       	subi	r18, 0xFE	; 254
     334:	3f 4f       	sbci	r19, 0xFF	; 255
     336:	ca 01       	movw	r24, r20
     338:	b9 01       	movw	r22, r18
     33a:	0e 94 98 04 	call	0x930	; 0x930 <vListInsertEnd>

		xReturn = pdPASS;
     33e:	81 e0       	ldi	r24, 0x01	; 1
     340:	8b 83       	std	Y+3, r24	; 0x03
     342:	02 c0       	rjmp	.+4      	; 0x348 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     344:	8f ef       	ldi	r24, 0xFF	; 255
     346:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     348:	8b 81       	ldd	r24, Y+3	; 0x03
}
     34a:	27 96       	adiw	r28, 0x07	; 7
     34c:	0f b6       	in	r0, 0x3f	; 63
     34e:	f8 94       	cli
     350:	de bf       	out	0x3e, r29	; 62
     352:	0f be       	out	0x3f, r0	; 63
     354:	cd bf       	out	0x3d, r28	; 61
     356:	cf 91       	pop	r28
     358:	df 91       	pop	r29
     35a:	08 95       	ret

0000035c <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     35c:	df 93       	push	r29
     35e:	cf 93       	push	r28
     360:	00 d0       	rcall	.+0      	; 0x362 <vCoRoutineAddToDelayedList+0x6>
     362:	00 d0       	rcall	.+0      	; 0x364 <vCoRoutineAddToDelayedList+0x8>
     364:	00 d0       	rcall	.+0      	; 0x366 <vCoRoutineAddToDelayedList+0xa>
     366:	cd b7       	in	r28, 0x3d	; 61
     368:	de b7       	in	r29, 0x3e	; 62
     36a:	9c 83       	std	Y+4, r25	; 0x04
     36c:	8b 83       	std	Y+3, r24	; 0x03
     36e:	7e 83       	std	Y+6, r23	; 0x06
     370:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     372:	20 91 7e 00 	lds	r18, 0x007E
     376:	30 91 7f 00 	lds	r19, 0x007F
     37a:	8b 81       	ldd	r24, Y+3	; 0x03
     37c:	9c 81       	ldd	r25, Y+4	; 0x04
     37e:	82 0f       	add	r24, r18
     380:	93 1f       	adc	r25, r19
     382:	9a 83       	std	Y+2, r25	; 0x02
     384:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     386:	80 91 7b 00 	lds	r24, 0x007B
     38a:	90 91 7c 00 	lds	r25, 0x007C
     38e:	02 96       	adiw	r24, 0x02	; 2
     390:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     394:	e0 91 7b 00 	lds	r30, 0x007B
     398:	f0 91 7c 00 	lds	r31, 0x007C
     39c:	89 81       	ldd	r24, Y+1	; 0x01
     39e:	9a 81       	ldd	r25, Y+2	; 0x02
     3a0:	93 83       	std	Z+3, r25	; 0x03
     3a2:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     3a4:	20 91 7e 00 	lds	r18, 0x007E
     3a8:	30 91 7f 00 	lds	r19, 0x007F
     3ac:	89 81       	ldd	r24, Y+1	; 0x01
     3ae:	9a 81       	ldd	r25, Y+2	; 0x02
     3b0:	82 17       	cp	r24, r18
     3b2:	93 07       	cpc	r25, r19
     3b4:	70 f4       	brcc	.+28     	; 0x3d2 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     3b6:	80 91 aa 00 	lds	r24, 0x00AA
     3ba:	90 91 ab 00 	lds	r25, 0x00AB
     3be:	20 91 7b 00 	lds	r18, 0x007B
     3c2:	30 91 7c 00 	lds	r19, 0x007C
     3c6:	2e 5f       	subi	r18, 0xFE	; 254
     3c8:	3f 4f       	sbci	r19, 0xFF	; 255
     3ca:	b9 01       	movw	r22, r18
     3cc:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <vListInsert>
     3d0:	0d c0       	rjmp	.+26     	; 0x3ec <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     3d2:	80 91 a8 00 	lds	r24, 0x00A8
     3d6:	90 91 a9 00 	lds	r25, 0x00A9
     3da:	20 91 7b 00 	lds	r18, 0x007B
     3de:	30 91 7c 00 	lds	r19, 0x007C
     3e2:	2e 5f       	subi	r18, 0xFE	; 254
     3e4:	3f 4f       	sbci	r19, 0xFF	; 255
     3e6:	b9 01       	movw	r22, r18
     3e8:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <vListInsert>
	}

	if( pxEventList )
     3ec:	8d 81       	ldd	r24, Y+5	; 0x05
     3ee:	9e 81       	ldd	r25, Y+6	; 0x06
     3f0:	00 97       	sbiw	r24, 0x00	; 0
     3f2:	61 f0       	breq	.+24     	; 0x40c <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     3f4:	80 91 7b 00 	lds	r24, 0x007B
     3f8:	90 91 7c 00 	lds	r25, 0x007C
     3fc:	9c 01       	movw	r18, r24
     3fe:	24 5f       	subi	r18, 0xF4	; 244
     400:	3f 4f       	sbci	r19, 0xFF	; 255
     402:	8d 81       	ldd	r24, Y+5	; 0x05
     404:	9e 81       	ldd	r25, Y+6	; 0x06
     406:	b9 01       	movw	r22, r18
     408:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <vListInsert>
	}
}
     40c:	26 96       	adiw	r28, 0x06	; 6
     40e:	0f b6       	in	r0, 0x3f	; 63
     410:	f8 94       	cli
     412:	de bf       	out	0x3e, r29	; 62
     414:	0f be       	out	0x3f, r0	; 63
     416:	cd bf       	out	0x3d, r28	; 61
     418:	cf 91       	pop	r28
     41a:	df 91       	pop	r29
     41c:	08 95       	ret

0000041e <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     41e:	df 93       	push	r29
     420:	cf 93       	push	r28
     422:	00 d0       	rcall	.+0      	; 0x424 <prvCheckPendingReadyList+0x6>
     424:	cd b7       	in	r28, 0x3d	; 61
     426:	de b7       	in	r29, 0x3e	; 62
     428:	3a c0       	rjmp	.+116    	; 0x49e <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     42a:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     42c:	e0 91 b1 00 	lds	r30, 0x00B1
     430:	f0 91 b2 00 	lds	r31, 0x00B2
     434:	86 81       	ldd	r24, Z+6	; 0x06
     436:	97 81       	ldd	r25, Z+7	; 0x07
     438:	9a 83       	std	Y+2, r25	; 0x02
     43a:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     43c:	89 81       	ldd	r24, Y+1	; 0x01
     43e:	9a 81       	ldd	r25, Y+2	; 0x02
     440:	0c 96       	adiw	r24, 0x0c	; 12
     442:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     446:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     448:	89 81       	ldd	r24, Y+1	; 0x01
     44a:	9a 81       	ldd	r25, Y+2	; 0x02
     44c:	02 96       	adiw	r24, 0x02	; 2
     44e:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     452:	e9 81       	ldd	r30, Y+1	; 0x01
     454:	fa 81       	ldd	r31, Y+2	; 0x02
     456:	96 89       	ldd	r25, Z+22	; 0x16
     458:	80 91 7d 00 	lds	r24, 0x007D
     45c:	89 17       	cp	r24, r25
     45e:	28 f4       	brcc	.+10     	; 0x46a <prvCheckPendingReadyList+0x4c>
     460:	e9 81       	ldd	r30, Y+1	; 0x01
     462:	fa 81       	ldd	r31, Y+2	; 0x02
     464:	86 89       	ldd	r24, Z+22	; 0x16
     466:	80 93 7d 00 	sts	0x007D, r24
     46a:	e9 81       	ldd	r30, Y+1	; 0x01
     46c:	fa 81       	ldd	r31, Y+2	; 0x02
     46e:	86 89       	ldd	r24, Z+22	; 0x16
     470:	28 2f       	mov	r18, r24
     472:	30 e0       	ldi	r19, 0x00	; 0
     474:	c9 01       	movw	r24, r18
     476:	88 0f       	add	r24, r24
     478:	99 1f       	adc	r25, r25
     47a:	88 0f       	add	r24, r24
     47c:	99 1f       	adc	r25, r25
     47e:	88 0f       	add	r24, r24
     480:	99 1f       	adc	r25, r25
     482:	82 0f       	add	r24, r18
     484:	93 1f       	adc	r25, r19
     486:	ac 01       	movw	r20, r24
     488:	4c 57       	subi	r20, 0x7C	; 124
     48a:	5f 4f       	sbci	r21, 0xFF	; 255
     48c:	89 81       	ldd	r24, Y+1	; 0x01
     48e:	9a 81       	ldd	r25, Y+2	; 0x02
     490:	9c 01       	movw	r18, r24
     492:	2e 5f       	subi	r18, 0xFE	; 254
     494:	3f 4f       	sbci	r19, 0xFF	; 255
     496:	ca 01       	movw	r24, r20
     498:	b9 01       	movw	r22, r18
     49a:	0e 94 98 04 	call	0x930	; 0x930 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     49e:	80 91 ac 00 	lds	r24, 0x00AC
     4a2:	88 23       	and	r24, r24
     4a4:	09 f0       	breq	.+2      	; 0x4a8 <prvCheckPendingReadyList+0x8a>
     4a6:	c1 cf       	rjmp	.-126    	; 0x42a <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     4a8:	0f 90       	pop	r0
     4aa:	0f 90       	pop	r0
     4ac:	cf 91       	pop	r28
     4ae:	df 91       	pop	r29
     4b0:	08 95       	ret

000004b2 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     4b2:	df 93       	push	r29
     4b4:	cf 93       	push	r28
     4b6:	00 d0       	rcall	.+0      	; 0x4b8 <prvCheckDelayedList+0x6>
     4b8:	00 d0       	rcall	.+0      	; 0x4ba <prvCheckDelayedList+0x8>
     4ba:	cd b7       	in	r28, 0x3d	; 61
     4bc:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     4be:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <xTaskGetTickCount>
     4c2:	20 91 80 00 	lds	r18, 0x0080
     4c6:	30 91 81 00 	lds	r19, 0x0081
     4ca:	82 1b       	sub	r24, r18
     4cc:	93 0b       	sbc	r25, r19
     4ce:	90 93 83 00 	sts	0x0083, r25
     4d2:	80 93 82 00 	sts	0x0082, r24
     4d6:	85 c0       	rjmp	.+266    	; 0x5e2 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     4d8:	80 91 7e 00 	lds	r24, 0x007E
     4dc:	90 91 7f 00 	lds	r25, 0x007F
     4e0:	01 96       	adiw	r24, 0x01	; 1
     4e2:	90 93 7f 00 	sts	0x007F, r25
     4e6:	80 93 7e 00 	sts	0x007E, r24
		xPassedTicks--;
     4ea:	80 91 82 00 	lds	r24, 0x0082
     4ee:	90 91 83 00 	lds	r25, 0x0083
     4f2:	01 97       	sbiw	r24, 0x01	; 1
     4f4:	90 93 83 00 	sts	0x0083, r25
     4f8:	80 93 82 00 	sts	0x0082, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     4fc:	80 91 7e 00 	lds	r24, 0x007E
     500:	90 91 7f 00 	lds	r25, 0x007F
     504:	00 97       	sbiw	r24, 0x00	; 0
     506:	09 f0       	breq	.+2      	; 0x50a <prvCheckDelayedList+0x58>
     508:	64 c0       	rjmp	.+200    	; 0x5d2 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     50a:	80 91 a8 00 	lds	r24, 0x00A8
     50e:	90 91 a9 00 	lds	r25, 0x00A9
     512:	9a 83       	std	Y+2, r25	; 0x02
     514:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     516:	80 91 aa 00 	lds	r24, 0x00AA
     51a:	90 91 ab 00 	lds	r25, 0x00AB
     51e:	90 93 a9 00 	sts	0x00A9, r25
     522:	80 93 a8 00 	sts	0x00A8, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     526:	89 81       	ldd	r24, Y+1	; 0x01
     528:	9a 81       	ldd	r25, Y+2	; 0x02
     52a:	90 93 ab 00 	sts	0x00AB, r25
     52e:	80 93 aa 00 	sts	0x00AA, r24
     532:	4f c0       	rjmp	.+158    	; 0x5d2 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     534:	e0 91 a8 00 	lds	r30, 0x00A8
     538:	f0 91 a9 00 	lds	r31, 0x00A9
     53c:	05 80       	ldd	r0, Z+5	; 0x05
     53e:	f6 81       	ldd	r31, Z+6	; 0x06
     540:	e0 2d       	mov	r30, r0
     542:	86 81       	ldd	r24, Z+6	; 0x06
     544:	97 81       	ldd	r25, Z+7	; 0x07
     546:	9c 83       	std	Y+4, r25	; 0x04
     548:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     54a:	eb 81       	ldd	r30, Y+3	; 0x03
     54c:	fc 81       	ldd	r31, Y+4	; 0x04
     54e:	22 81       	ldd	r18, Z+2	; 0x02
     550:	33 81       	ldd	r19, Z+3	; 0x03
     552:	80 91 7e 00 	lds	r24, 0x007E
     556:	90 91 7f 00 	lds	r25, 0x007F
     55a:	82 17       	cp	r24, r18
     55c:	93 07       	cpc	r25, r19
     55e:	08 f4       	brcc	.+2      	; 0x562 <prvCheckDelayedList+0xb0>
     560:	40 c0       	rjmp	.+128    	; 0x5e2 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     562:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     564:	8b 81       	ldd	r24, Y+3	; 0x03
     566:	9c 81       	ldd	r25, Y+4	; 0x04
     568:	02 96       	adiw	r24, 0x02	; 2
     56a:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     56e:	eb 81       	ldd	r30, Y+3	; 0x03
     570:	fc 81       	ldd	r31, Y+4	; 0x04
     572:	84 89       	ldd	r24, Z+20	; 0x14
     574:	95 89       	ldd	r25, Z+21	; 0x15
     576:	00 97       	sbiw	r24, 0x00	; 0
     578:	29 f0       	breq	.+10     	; 0x584 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     57a:	8b 81       	ldd	r24, Y+3	; 0x03
     57c:	9c 81       	ldd	r25, Y+4	; 0x04
     57e:	0c 96       	adiw	r24, 0x0c	; 12
     580:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     584:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     586:	eb 81       	ldd	r30, Y+3	; 0x03
     588:	fc 81       	ldd	r31, Y+4	; 0x04
     58a:	96 89       	ldd	r25, Z+22	; 0x16
     58c:	80 91 7d 00 	lds	r24, 0x007D
     590:	89 17       	cp	r24, r25
     592:	28 f4       	brcc	.+10     	; 0x59e <prvCheckDelayedList+0xec>
     594:	eb 81       	ldd	r30, Y+3	; 0x03
     596:	fc 81       	ldd	r31, Y+4	; 0x04
     598:	86 89       	ldd	r24, Z+22	; 0x16
     59a:	80 93 7d 00 	sts	0x007D, r24
     59e:	eb 81       	ldd	r30, Y+3	; 0x03
     5a0:	fc 81       	ldd	r31, Y+4	; 0x04
     5a2:	86 89       	ldd	r24, Z+22	; 0x16
     5a4:	28 2f       	mov	r18, r24
     5a6:	30 e0       	ldi	r19, 0x00	; 0
     5a8:	c9 01       	movw	r24, r18
     5aa:	88 0f       	add	r24, r24
     5ac:	99 1f       	adc	r25, r25
     5ae:	88 0f       	add	r24, r24
     5b0:	99 1f       	adc	r25, r25
     5b2:	88 0f       	add	r24, r24
     5b4:	99 1f       	adc	r25, r25
     5b6:	82 0f       	add	r24, r18
     5b8:	93 1f       	adc	r25, r19
     5ba:	ac 01       	movw	r20, r24
     5bc:	4c 57       	subi	r20, 0x7C	; 124
     5be:	5f 4f       	sbci	r21, 0xFF	; 255
     5c0:	8b 81       	ldd	r24, Y+3	; 0x03
     5c2:	9c 81       	ldd	r25, Y+4	; 0x04
     5c4:	9c 01       	movw	r18, r24
     5c6:	2e 5f       	subi	r18, 0xFE	; 254
     5c8:	3f 4f       	sbci	r19, 0xFF	; 255
     5ca:	ca 01       	movw	r24, r20
     5cc:	b9 01       	movw	r22, r18
     5ce:	0e 94 98 04 	call	0x930	; 0x930 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     5d2:	e0 91 a8 00 	lds	r30, 0x00A8
     5d6:	f0 91 a9 00 	lds	r31, 0x00A9
     5da:	80 81       	ld	r24, Z
     5dc:	88 23       	and	r24, r24
     5de:	09 f0       	breq	.+2      	; 0x5e2 <prvCheckDelayedList+0x130>
     5e0:	a9 cf       	rjmp	.-174    	; 0x534 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     5e2:	80 91 82 00 	lds	r24, 0x0082
     5e6:	90 91 83 00 	lds	r25, 0x0083
     5ea:	00 97       	sbiw	r24, 0x00	; 0
     5ec:	09 f0       	breq	.+2      	; 0x5f0 <prvCheckDelayedList+0x13e>
     5ee:	74 cf       	rjmp	.-280    	; 0x4d8 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     5f0:	80 91 7e 00 	lds	r24, 0x007E
     5f4:	90 91 7f 00 	lds	r25, 0x007F
     5f8:	90 93 81 00 	sts	0x0081, r25
     5fc:	80 93 80 00 	sts	0x0080, r24
}
     600:	0f 90       	pop	r0
     602:	0f 90       	pop	r0
     604:	0f 90       	pop	r0
     606:	0f 90       	pop	r0
     608:	cf 91       	pop	r28
     60a:	df 91       	pop	r29
     60c:	08 95       	ret

0000060e <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     60e:	df 93       	push	r29
     610:	cf 93       	push	r28
     612:	00 d0       	rcall	.+0      	; 0x614 <vCoRoutineSchedule+0x6>
     614:	cd b7       	in	r28, 0x3d	; 61
     616:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     618:	0e 94 0f 02 	call	0x41e	; 0x41e <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     61c:	0e 94 59 02 	call	0x4b2	; 0x4b2 <prvCheckDelayedList>
     620:	0a c0       	rjmp	.+20     	; 0x636 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     622:	80 91 7d 00 	lds	r24, 0x007D
     626:	88 23       	and	r24, r24
     628:	09 f4       	brne	.+2      	; 0x62c <vCoRoutineSchedule+0x1e>
     62a:	66 c0       	rjmp	.+204    	; 0x6f8 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     62c:	80 91 7d 00 	lds	r24, 0x007D
     630:	81 50       	subi	r24, 0x01	; 1
     632:	80 93 7d 00 	sts	0x007D, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     636:	80 91 7d 00 	lds	r24, 0x007D
     63a:	28 2f       	mov	r18, r24
     63c:	30 e0       	ldi	r19, 0x00	; 0
     63e:	c9 01       	movw	r24, r18
     640:	88 0f       	add	r24, r24
     642:	99 1f       	adc	r25, r25
     644:	88 0f       	add	r24, r24
     646:	99 1f       	adc	r25, r25
     648:	88 0f       	add	r24, r24
     64a:	99 1f       	adc	r25, r25
     64c:	82 0f       	add	r24, r18
     64e:	93 1f       	adc	r25, r19
     650:	fc 01       	movw	r30, r24
     652:	ec 57       	subi	r30, 0x7C	; 124
     654:	ff 4f       	sbci	r31, 0xFF	; 255
     656:	80 81       	ld	r24, Z
     658:	88 23       	and	r24, r24
     65a:	19 f3       	breq	.-58     	; 0x622 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     65c:	80 91 7d 00 	lds	r24, 0x007D
     660:	28 2f       	mov	r18, r24
     662:	30 e0       	ldi	r19, 0x00	; 0
     664:	c9 01       	movw	r24, r18
     666:	88 0f       	add	r24, r24
     668:	99 1f       	adc	r25, r25
     66a:	88 0f       	add	r24, r24
     66c:	99 1f       	adc	r25, r25
     66e:	88 0f       	add	r24, r24
     670:	99 1f       	adc	r25, r25
     672:	82 0f       	add	r24, r18
     674:	93 1f       	adc	r25, r19
     676:	8c 57       	subi	r24, 0x7C	; 124
     678:	9f 4f       	sbci	r25, 0xFF	; 255
     67a:	9a 83       	std	Y+2, r25	; 0x02
     67c:	89 83       	std	Y+1, r24	; 0x01
     67e:	e9 81       	ldd	r30, Y+1	; 0x01
     680:	fa 81       	ldd	r31, Y+2	; 0x02
     682:	01 80       	ldd	r0, Z+1	; 0x01
     684:	f2 81       	ldd	r31, Z+2	; 0x02
     686:	e0 2d       	mov	r30, r0
     688:	82 81       	ldd	r24, Z+2	; 0x02
     68a:	93 81       	ldd	r25, Z+3	; 0x03
     68c:	e9 81       	ldd	r30, Y+1	; 0x01
     68e:	fa 81       	ldd	r31, Y+2	; 0x02
     690:	92 83       	std	Z+2, r25	; 0x02
     692:	81 83       	std	Z+1, r24	; 0x01
     694:	e9 81       	ldd	r30, Y+1	; 0x01
     696:	fa 81       	ldd	r31, Y+2	; 0x02
     698:	21 81       	ldd	r18, Z+1	; 0x01
     69a:	32 81       	ldd	r19, Z+2	; 0x02
     69c:	89 81       	ldd	r24, Y+1	; 0x01
     69e:	9a 81       	ldd	r25, Y+2	; 0x02
     6a0:	03 96       	adiw	r24, 0x03	; 3
     6a2:	28 17       	cp	r18, r24
     6a4:	39 07       	cpc	r19, r25
     6a6:	59 f4       	brne	.+22     	; 0x6be <vCoRoutineSchedule+0xb0>
     6a8:	e9 81       	ldd	r30, Y+1	; 0x01
     6aa:	fa 81       	ldd	r31, Y+2	; 0x02
     6ac:	01 80       	ldd	r0, Z+1	; 0x01
     6ae:	f2 81       	ldd	r31, Z+2	; 0x02
     6b0:	e0 2d       	mov	r30, r0
     6b2:	82 81       	ldd	r24, Z+2	; 0x02
     6b4:	93 81       	ldd	r25, Z+3	; 0x03
     6b6:	e9 81       	ldd	r30, Y+1	; 0x01
     6b8:	fa 81       	ldd	r31, Y+2	; 0x02
     6ba:	92 83       	std	Z+2, r25	; 0x02
     6bc:	81 83       	std	Z+1, r24	; 0x01
     6be:	e9 81       	ldd	r30, Y+1	; 0x01
     6c0:	fa 81       	ldd	r31, Y+2	; 0x02
     6c2:	01 80       	ldd	r0, Z+1	; 0x01
     6c4:	f2 81       	ldd	r31, Z+2	; 0x02
     6c6:	e0 2d       	mov	r30, r0
     6c8:	86 81       	ldd	r24, Z+6	; 0x06
     6ca:	97 81       	ldd	r25, Z+7	; 0x07
     6cc:	90 93 7c 00 	sts	0x007C, r25
     6d0:	80 93 7b 00 	sts	0x007B, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     6d4:	e0 91 7b 00 	lds	r30, 0x007B
     6d8:	f0 91 7c 00 	lds	r31, 0x007C
     6dc:	40 81       	ld	r20, Z
     6de:	51 81       	ldd	r21, Z+1	; 0x01
     6e0:	80 91 7b 00 	lds	r24, 0x007B
     6e4:	90 91 7c 00 	lds	r25, 0x007C
     6e8:	e0 91 7b 00 	lds	r30, 0x007B
     6ec:	f0 91 7c 00 	lds	r31, 0x007C
     6f0:	27 89       	ldd	r18, Z+23	; 0x17
     6f2:	62 2f       	mov	r22, r18
     6f4:	fa 01       	movw	r30, r20
     6f6:	09 95       	icall

	return;
}
     6f8:	0f 90       	pop	r0
     6fa:	0f 90       	pop	r0
     6fc:	cf 91       	pop	r28
     6fe:	df 91       	pop	r29
     700:	08 95       	ret

00000702 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     702:	df 93       	push	r29
     704:	cf 93       	push	r28
     706:	0f 92       	push	r0
     708:	cd b7       	in	r28, 0x3d	; 61
     70a:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     70c:	19 82       	std	Y+1, r1	; 0x01
     70e:	13 c0       	rjmp	.+38     	; 0x736 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     710:	89 81       	ldd	r24, Y+1	; 0x01
     712:	28 2f       	mov	r18, r24
     714:	30 e0       	ldi	r19, 0x00	; 0
     716:	c9 01       	movw	r24, r18
     718:	88 0f       	add	r24, r24
     71a:	99 1f       	adc	r25, r25
     71c:	88 0f       	add	r24, r24
     71e:	99 1f       	adc	r25, r25
     720:	88 0f       	add	r24, r24
     722:	99 1f       	adc	r25, r25
     724:	82 0f       	add	r24, r18
     726:	93 1f       	adc	r25, r19
     728:	8c 57       	subi	r24, 0x7C	; 124
     72a:	9f 4f       	sbci	r25, 0xFF	; 255
     72c:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     730:	89 81       	ldd	r24, Y+1	; 0x01
     732:	8f 5f       	subi	r24, 0xFF	; 255
     734:	89 83       	std	Y+1, r24	; 0x01
     736:	89 81       	ldd	r24, Y+1	; 0x01
     738:	82 30       	cpi	r24, 0x02	; 2
     73a:	50 f3       	brcs	.-44     	; 0x710 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     73c:	86 e9       	ldi	r24, 0x96	; 150
     73e:	90 e0       	ldi	r25, 0x00	; 0
     740:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     744:	8f e9       	ldi	r24, 0x9F	; 159
     746:	90 e0       	ldi	r25, 0x00	; 0
     748:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     74c:	8c ea       	ldi	r24, 0xAC	; 172
     74e:	90 e0       	ldi	r25, 0x00	; 0
     750:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     754:	86 e9       	ldi	r24, 0x96	; 150
     756:	90 e0       	ldi	r25, 0x00	; 0
     758:	90 93 a9 00 	sts	0x00A9, r25
     75c:	80 93 a8 00 	sts	0x00A8, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     760:	8f e9       	ldi	r24, 0x9F	; 159
     762:	90 e0       	ldi	r25, 0x00	; 0
     764:	90 93 ab 00 	sts	0x00AB, r25
     768:	80 93 aa 00 	sts	0x00AA, r24
}
     76c:	0f 90       	pop	r0
     76e:	cf 91       	pop	r28
     770:	df 91       	pop	r29
     772:	08 95       	ret

00000774 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     774:	df 93       	push	r29
     776:	cf 93       	push	r28
     778:	00 d0       	rcall	.+0      	; 0x77a <xCoRoutineRemoveFromEventList+0x6>
     77a:	00 d0       	rcall	.+0      	; 0x77c <xCoRoutineRemoveFromEventList+0x8>
     77c:	0f 92       	push	r0
     77e:	cd b7       	in	r28, 0x3d	; 61
     780:	de b7       	in	r29, 0x3e	; 62
     782:	9d 83       	std	Y+5, r25	; 0x05
     784:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     786:	ec 81       	ldd	r30, Y+4	; 0x04
     788:	fd 81       	ldd	r31, Y+5	; 0x05
     78a:	05 80       	ldd	r0, Z+5	; 0x05
     78c:	f6 81       	ldd	r31, Z+6	; 0x06
     78e:	e0 2d       	mov	r30, r0
     790:	86 81       	ldd	r24, Z+6	; 0x06
     792:	97 81       	ldd	r25, Z+7	; 0x07
     794:	9b 83       	std	Y+3, r25	; 0x03
     796:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     798:	8a 81       	ldd	r24, Y+2	; 0x02
     79a:	9b 81       	ldd	r25, Y+3	; 0x03
     79c:	0c 96       	adiw	r24, 0x0c	; 12
     79e:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     7a2:	8a 81       	ldd	r24, Y+2	; 0x02
     7a4:	9b 81       	ldd	r25, Y+3	; 0x03
     7a6:	9c 01       	movw	r18, r24
     7a8:	24 5f       	subi	r18, 0xF4	; 244
     7aa:	3f 4f       	sbci	r19, 0xFF	; 255
     7ac:	8c ea       	ldi	r24, 0xAC	; 172
     7ae:	90 e0       	ldi	r25, 0x00	; 0
     7b0:	b9 01       	movw	r22, r18
     7b2:	0e 94 98 04 	call	0x930	; 0x930 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     7b6:	ea 81       	ldd	r30, Y+2	; 0x02
     7b8:	fb 81       	ldd	r31, Y+3	; 0x03
     7ba:	96 89       	ldd	r25, Z+22	; 0x16
     7bc:	e0 91 7b 00 	lds	r30, 0x007B
     7c0:	f0 91 7c 00 	lds	r31, 0x007C
     7c4:	86 89       	ldd	r24, Z+22	; 0x16
     7c6:	98 17       	cp	r25, r24
     7c8:	18 f0       	brcs	.+6      	; 0x7d0 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     7ca:	81 e0       	ldi	r24, 0x01	; 1
     7cc:	89 83       	std	Y+1, r24	; 0x01
     7ce:	01 c0       	rjmp	.+2      	; 0x7d2 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     7d0:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     7d2:	89 81       	ldd	r24, Y+1	; 0x01
}
     7d4:	0f 90       	pop	r0
     7d6:	0f 90       	pop	r0
     7d8:	0f 90       	pop	r0
     7da:	0f 90       	pop	r0
     7dc:	0f 90       	pop	r0
     7de:	cf 91       	pop	r28
     7e0:	df 91       	pop	r29
     7e2:	08 95       	ret

000007e4 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     7e4:	df 93       	push	r29
     7e6:	cf 93       	push	r28
     7e8:	00 d0       	rcall	.+0      	; 0x7ea <pvPortMalloc+0x6>
     7ea:	00 d0       	rcall	.+0      	; 0x7ec <pvPortMalloc+0x8>
     7ec:	cd b7       	in	r28, 0x3d	; 61
     7ee:	de b7       	in	r29, 0x3e	; 62
     7f0:	9c 83       	std	Y+4, r25	; 0x04
     7f2:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     7f4:	1a 82       	std	Y+2, r1	; 0x02
     7f6:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     7f8:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     7fc:	80 91 b5 00 	lds	r24, 0x00B5
     800:	90 91 b6 00 	lds	r25, 0x00B6
     804:	2b 81       	ldd	r18, Y+3	; 0x03
     806:	3c 81       	ldd	r19, Y+4	; 0x04
     808:	82 0f       	add	r24, r18
     80a:	93 1f       	adc	r25, r19
     80c:	22 e0       	ldi	r18, 0x02	; 2
     80e:	88 35       	cpi	r24, 0x58	; 88
     810:	92 07       	cpc	r25, r18
     812:	18 f5       	brcc	.+70     	; 0x85a <pvPortMalloc+0x76>
     814:	20 91 b5 00 	lds	r18, 0x00B5
     818:	30 91 b6 00 	lds	r19, 0x00B6
     81c:	8b 81       	ldd	r24, Y+3	; 0x03
     81e:	9c 81       	ldd	r25, Y+4	; 0x04
     820:	28 0f       	add	r18, r24
     822:	39 1f       	adc	r19, r25
     824:	80 91 b5 00 	lds	r24, 0x00B5
     828:	90 91 b6 00 	lds	r25, 0x00B6
     82c:	82 17       	cp	r24, r18
     82e:	93 07       	cpc	r25, r19
     830:	a0 f4       	brcc	.+40     	; 0x85a <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     832:	80 91 b5 00 	lds	r24, 0x00B5
     836:	90 91 b6 00 	lds	r25, 0x00B6
     83a:	89 54       	subi	r24, 0x49	; 73
     83c:	9f 4f       	sbci	r25, 0xFF	; 255
     83e:	9a 83       	std	Y+2, r25	; 0x02
     840:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     842:	20 91 b5 00 	lds	r18, 0x00B5
     846:	30 91 b6 00 	lds	r19, 0x00B6
     84a:	8b 81       	ldd	r24, Y+3	; 0x03
     84c:	9c 81       	ldd	r25, Y+4	; 0x04
     84e:	82 0f       	add	r24, r18
     850:	93 1f       	adc	r25, r19
     852:	90 93 b6 00 	sts	0x00B6, r25
     856:	80 93 b5 00 	sts	0x00B5, r24
		}	
	}
	xTaskResumeAll();
     85a:	0e 94 34 0f 	call	0x1e68	; 0x1e68 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     85e:	89 81       	ldd	r24, Y+1	; 0x01
     860:	9a 81       	ldd	r25, Y+2	; 0x02
}
     862:	0f 90       	pop	r0
     864:	0f 90       	pop	r0
     866:	0f 90       	pop	r0
     868:	0f 90       	pop	r0
     86a:	cf 91       	pop	r28
     86c:	df 91       	pop	r29
     86e:	08 95       	ret

00000870 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     870:	df 93       	push	r29
     872:	cf 93       	push	r28
     874:	00 d0       	rcall	.+0      	; 0x876 <vPortFree+0x6>
     876:	cd b7       	in	r28, 0x3d	; 61
     878:	de b7       	in	r29, 0x3e	; 62
     87a:	9a 83       	std	Y+2, r25	; 0x02
     87c:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     87e:	0f 90       	pop	r0
     880:	0f 90       	pop	r0
     882:	cf 91       	pop	r28
     884:	df 91       	pop	r29
     886:	08 95       	ret

00000888 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     888:	df 93       	push	r29
     88a:	cf 93       	push	r28
     88c:	cd b7       	in	r28, 0x3d	; 61
     88e:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     890:	10 92 b6 00 	sts	0x00B6, r1
     894:	10 92 b5 00 	sts	0x00B5, r1
}
     898:	cf 91       	pop	r28
     89a:	df 91       	pop	r29
     89c:	08 95       	ret

0000089e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     89e:	df 93       	push	r29
     8a0:	cf 93       	push	r28
     8a2:	cd b7       	in	r28, 0x3d	; 61
     8a4:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     8a6:	20 91 b5 00 	lds	r18, 0x00B5
     8aa:	30 91 b6 00 	lds	r19, 0x00B6
     8ae:	88 e5       	ldi	r24, 0x58	; 88
     8b0:	92 e0       	ldi	r25, 0x02	; 2
     8b2:	82 1b       	sub	r24, r18
     8b4:	93 0b       	sbc	r25, r19
}
     8b6:	cf 91       	pop	r28
     8b8:	df 91       	pop	r29
     8ba:	08 95       	ret

000008bc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     8bc:	df 93       	push	r29
     8be:	cf 93       	push	r28
     8c0:	00 d0       	rcall	.+0      	; 0x8c2 <vListInitialise+0x6>
     8c2:	cd b7       	in	r28, 0x3d	; 61
     8c4:	de b7       	in	r29, 0x3e	; 62
     8c6:	9a 83       	std	Y+2, r25	; 0x02
     8c8:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     8ca:	89 81       	ldd	r24, Y+1	; 0x01
     8cc:	9a 81       	ldd	r25, Y+2	; 0x02
     8ce:	03 96       	adiw	r24, 0x03	; 3
     8d0:	e9 81       	ldd	r30, Y+1	; 0x01
     8d2:	fa 81       	ldd	r31, Y+2	; 0x02
     8d4:	92 83       	std	Z+2, r25	; 0x02
     8d6:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     8d8:	e9 81       	ldd	r30, Y+1	; 0x01
     8da:	fa 81       	ldd	r31, Y+2	; 0x02
     8dc:	8f ef       	ldi	r24, 0xFF	; 255
     8de:	9f ef       	ldi	r25, 0xFF	; 255
     8e0:	94 83       	std	Z+4, r25	; 0x04
     8e2:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     8e4:	89 81       	ldd	r24, Y+1	; 0x01
     8e6:	9a 81       	ldd	r25, Y+2	; 0x02
     8e8:	03 96       	adiw	r24, 0x03	; 3
     8ea:	e9 81       	ldd	r30, Y+1	; 0x01
     8ec:	fa 81       	ldd	r31, Y+2	; 0x02
     8ee:	96 83       	std	Z+6, r25	; 0x06
     8f0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     8f2:	89 81       	ldd	r24, Y+1	; 0x01
     8f4:	9a 81       	ldd	r25, Y+2	; 0x02
     8f6:	03 96       	adiw	r24, 0x03	; 3
     8f8:	e9 81       	ldd	r30, Y+1	; 0x01
     8fa:	fa 81       	ldd	r31, Y+2	; 0x02
     8fc:	90 87       	std	Z+8, r25	; 0x08
     8fe:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     900:	e9 81       	ldd	r30, Y+1	; 0x01
     902:	fa 81       	ldd	r31, Y+2	; 0x02
     904:	10 82       	st	Z, r1
}
     906:	0f 90       	pop	r0
     908:	0f 90       	pop	r0
     90a:	cf 91       	pop	r28
     90c:	df 91       	pop	r29
     90e:	08 95       	ret

00000910 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     910:	df 93       	push	r29
     912:	cf 93       	push	r28
     914:	00 d0       	rcall	.+0      	; 0x916 <vListInitialiseItem+0x6>
     916:	cd b7       	in	r28, 0x3d	; 61
     918:	de b7       	in	r29, 0x3e	; 62
     91a:	9a 83       	std	Y+2, r25	; 0x02
     91c:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     91e:	e9 81       	ldd	r30, Y+1	; 0x01
     920:	fa 81       	ldd	r31, Y+2	; 0x02
     922:	11 86       	std	Z+9, r1	; 0x09
     924:	10 86       	std	Z+8, r1	; 0x08
}
     926:	0f 90       	pop	r0
     928:	0f 90       	pop	r0
     92a:	cf 91       	pop	r28
     92c:	df 91       	pop	r29
     92e:	08 95       	ret

00000930 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     930:	df 93       	push	r29
     932:	cf 93       	push	r28
     934:	00 d0       	rcall	.+0      	; 0x936 <vListInsertEnd+0x6>
     936:	00 d0       	rcall	.+0      	; 0x938 <vListInsertEnd+0x8>
     938:	00 d0       	rcall	.+0      	; 0x93a <vListInsertEnd+0xa>
     93a:	cd b7       	in	r28, 0x3d	; 61
     93c:	de b7       	in	r29, 0x3e	; 62
     93e:	9c 83       	std	Y+4, r25	; 0x04
     940:	8b 83       	std	Y+3, r24	; 0x03
     942:	7e 83       	std	Y+6, r23	; 0x06
     944:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     946:	eb 81       	ldd	r30, Y+3	; 0x03
     948:	fc 81       	ldd	r31, Y+4	; 0x04
     94a:	81 81       	ldd	r24, Z+1	; 0x01
     94c:	92 81       	ldd	r25, Z+2	; 0x02
     94e:	9a 83       	std	Y+2, r25	; 0x02
     950:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     952:	e9 81       	ldd	r30, Y+1	; 0x01
     954:	fa 81       	ldd	r31, Y+2	; 0x02
     956:	82 81       	ldd	r24, Z+2	; 0x02
     958:	93 81       	ldd	r25, Z+3	; 0x03
     95a:	ed 81       	ldd	r30, Y+5	; 0x05
     95c:	fe 81       	ldd	r31, Y+6	; 0x06
     95e:	93 83       	std	Z+3, r25	; 0x03
     960:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     962:	eb 81       	ldd	r30, Y+3	; 0x03
     964:	fc 81       	ldd	r31, Y+4	; 0x04
     966:	81 81       	ldd	r24, Z+1	; 0x01
     968:	92 81       	ldd	r25, Z+2	; 0x02
     96a:	ed 81       	ldd	r30, Y+5	; 0x05
     96c:	fe 81       	ldd	r31, Y+6	; 0x06
     96e:	95 83       	std	Z+5, r25	; 0x05
     970:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     972:	e9 81       	ldd	r30, Y+1	; 0x01
     974:	fa 81       	ldd	r31, Y+2	; 0x02
     976:	02 80       	ldd	r0, Z+2	; 0x02
     978:	f3 81       	ldd	r31, Z+3	; 0x03
     97a:	e0 2d       	mov	r30, r0
     97c:	8d 81       	ldd	r24, Y+5	; 0x05
     97e:	9e 81       	ldd	r25, Y+6	; 0x06
     980:	95 83       	std	Z+5, r25	; 0x05
     982:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     984:	8d 81       	ldd	r24, Y+5	; 0x05
     986:	9e 81       	ldd	r25, Y+6	; 0x06
     988:	e9 81       	ldd	r30, Y+1	; 0x01
     98a:	fa 81       	ldd	r31, Y+2	; 0x02
     98c:	93 83       	std	Z+3, r25	; 0x03
     98e:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     990:	8d 81       	ldd	r24, Y+5	; 0x05
     992:	9e 81       	ldd	r25, Y+6	; 0x06
     994:	eb 81       	ldd	r30, Y+3	; 0x03
     996:	fc 81       	ldd	r31, Y+4	; 0x04
     998:	92 83       	std	Z+2, r25	; 0x02
     99a:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     99c:	ed 81       	ldd	r30, Y+5	; 0x05
     99e:	fe 81       	ldd	r31, Y+6	; 0x06
     9a0:	8b 81       	ldd	r24, Y+3	; 0x03
     9a2:	9c 81       	ldd	r25, Y+4	; 0x04
     9a4:	91 87       	std	Z+9, r25	; 0x09
     9a6:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     9a8:	eb 81       	ldd	r30, Y+3	; 0x03
     9aa:	fc 81       	ldd	r31, Y+4	; 0x04
     9ac:	80 81       	ld	r24, Z
     9ae:	8f 5f       	subi	r24, 0xFF	; 255
     9b0:	eb 81       	ldd	r30, Y+3	; 0x03
     9b2:	fc 81       	ldd	r31, Y+4	; 0x04
     9b4:	80 83       	st	Z, r24
}
     9b6:	26 96       	adiw	r28, 0x06	; 6
     9b8:	0f b6       	in	r0, 0x3f	; 63
     9ba:	f8 94       	cli
     9bc:	de bf       	out	0x3e, r29	; 62
     9be:	0f be       	out	0x3f, r0	; 63
     9c0:	cd bf       	out	0x3d, r28	; 61
     9c2:	cf 91       	pop	r28
     9c4:	df 91       	pop	r29
     9c6:	08 95       	ret

000009c8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     9c8:	df 93       	push	r29
     9ca:	cf 93       	push	r28
     9cc:	cd b7       	in	r28, 0x3d	; 61
     9ce:	de b7       	in	r29, 0x3e	; 62
     9d0:	28 97       	sbiw	r28, 0x08	; 8
     9d2:	0f b6       	in	r0, 0x3f	; 63
     9d4:	f8 94       	cli
     9d6:	de bf       	out	0x3e, r29	; 62
     9d8:	0f be       	out	0x3f, r0	; 63
     9da:	cd bf       	out	0x3d, r28	; 61
     9dc:	9e 83       	std	Y+6, r25	; 0x06
     9de:	8d 83       	std	Y+5, r24	; 0x05
     9e0:	78 87       	std	Y+8, r23	; 0x08
     9e2:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     9e4:	ef 81       	ldd	r30, Y+7	; 0x07
     9e6:	f8 85       	ldd	r31, Y+8	; 0x08
     9e8:	80 81       	ld	r24, Z
     9ea:	91 81       	ldd	r25, Z+1	; 0x01
     9ec:	9a 83       	std	Y+2, r25	; 0x02
     9ee:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     9f0:	89 81       	ldd	r24, Y+1	; 0x01
     9f2:	9a 81       	ldd	r25, Y+2	; 0x02
     9f4:	2f ef       	ldi	r18, 0xFF	; 255
     9f6:	8f 3f       	cpi	r24, 0xFF	; 255
     9f8:	92 07       	cpc	r25, r18
     9fa:	39 f4       	brne	.+14     	; 0xa0a <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     9fc:	ed 81       	ldd	r30, Y+5	; 0x05
     9fe:	fe 81       	ldd	r31, Y+6	; 0x06
     a00:	87 81       	ldd	r24, Z+7	; 0x07
     a02:	90 85       	ldd	r25, Z+8	; 0x08
     a04:	9c 83       	std	Y+4, r25	; 0x04
     a06:	8b 83       	std	Y+3, r24	; 0x03
     a08:	18 c0       	rjmp	.+48     	; 0xa3a <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     a0a:	8d 81       	ldd	r24, Y+5	; 0x05
     a0c:	9e 81       	ldd	r25, Y+6	; 0x06
     a0e:	03 96       	adiw	r24, 0x03	; 3
     a10:	9c 83       	std	Y+4, r25	; 0x04
     a12:	8b 83       	std	Y+3, r24	; 0x03
     a14:	06 c0       	rjmp	.+12     	; 0xa22 <vListInsert+0x5a>
     a16:	eb 81       	ldd	r30, Y+3	; 0x03
     a18:	fc 81       	ldd	r31, Y+4	; 0x04
     a1a:	82 81       	ldd	r24, Z+2	; 0x02
     a1c:	93 81       	ldd	r25, Z+3	; 0x03
     a1e:	9c 83       	std	Y+4, r25	; 0x04
     a20:	8b 83       	std	Y+3, r24	; 0x03
     a22:	eb 81       	ldd	r30, Y+3	; 0x03
     a24:	fc 81       	ldd	r31, Y+4	; 0x04
     a26:	02 80       	ldd	r0, Z+2	; 0x02
     a28:	f3 81       	ldd	r31, Z+3	; 0x03
     a2a:	e0 2d       	mov	r30, r0
     a2c:	20 81       	ld	r18, Z
     a2e:	31 81       	ldd	r19, Z+1	; 0x01
     a30:	89 81       	ldd	r24, Y+1	; 0x01
     a32:	9a 81       	ldd	r25, Y+2	; 0x02
     a34:	82 17       	cp	r24, r18
     a36:	93 07       	cpc	r25, r19
     a38:	70 f7       	brcc	.-36     	; 0xa16 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a3a:	eb 81       	ldd	r30, Y+3	; 0x03
     a3c:	fc 81       	ldd	r31, Y+4	; 0x04
     a3e:	82 81       	ldd	r24, Z+2	; 0x02
     a40:	93 81       	ldd	r25, Z+3	; 0x03
     a42:	ef 81       	ldd	r30, Y+7	; 0x07
     a44:	f8 85       	ldd	r31, Y+8	; 0x08
     a46:	93 83       	std	Z+3, r25	; 0x03
     a48:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     a4a:	ef 81       	ldd	r30, Y+7	; 0x07
     a4c:	f8 85       	ldd	r31, Y+8	; 0x08
     a4e:	02 80       	ldd	r0, Z+2	; 0x02
     a50:	f3 81       	ldd	r31, Z+3	; 0x03
     a52:	e0 2d       	mov	r30, r0
     a54:	8f 81       	ldd	r24, Y+7	; 0x07
     a56:	98 85       	ldd	r25, Y+8	; 0x08
     a58:	95 83       	std	Z+5, r25	; 0x05
     a5a:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     a5c:	ef 81       	ldd	r30, Y+7	; 0x07
     a5e:	f8 85       	ldd	r31, Y+8	; 0x08
     a60:	8b 81       	ldd	r24, Y+3	; 0x03
     a62:	9c 81       	ldd	r25, Y+4	; 0x04
     a64:	95 83       	std	Z+5, r25	; 0x05
     a66:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     a68:	8f 81       	ldd	r24, Y+7	; 0x07
     a6a:	98 85       	ldd	r25, Y+8	; 0x08
     a6c:	eb 81       	ldd	r30, Y+3	; 0x03
     a6e:	fc 81       	ldd	r31, Y+4	; 0x04
     a70:	93 83       	std	Z+3, r25	; 0x03
     a72:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a74:	ef 81       	ldd	r30, Y+7	; 0x07
     a76:	f8 85       	ldd	r31, Y+8	; 0x08
     a78:	8d 81       	ldd	r24, Y+5	; 0x05
     a7a:	9e 81       	ldd	r25, Y+6	; 0x06
     a7c:	91 87       	std	Z+9, r25	; 0x09
     a7e:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     a80:	ed 81       	ldd	r30, Y+5	; 0x05
     a82:	fe 81       	ldd	r31, Y+6	; 0x06
     a84:	80 81       	ld	r24, Z
     a86:	8f 5f       	subi	r24, 0xFF	; 255
     a88:	ed 81       	ldd	r30, Y+5	; 0x05
     a8a:	fe 81       	ldd	r31, Y+6	; 0x06
     a8c:	80 83       	st	Z, r24
}
     a8e:	28 96       	adiw	r28, 0x08	; 8
     a90:	0f b6       	in	r0, 0x3f	; 63
     a92:	f8 94       	cli
     a94:	de bf       	out	0x3e, r29	; 62
     a96:	0f be       	out	0x3f, r0	; 63
     a98:	cd bf       	out	0x3d, r28	; 61
     a9a:	cf 91       	pop	r28
     a9c:	df 91       	pop	r29
     a9e:	08 95       	ret

00000aa0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     aa0:	df 93       	push	r29
     aa2:	cf 93       	push	r28
     aa4:	00 d0       	rcall	.+0      	; 0xaa6 <vListRemove+0x6>
     aa6:	00 d0       	rcall	.+0      	; 0xaa8 <vListRemove+0x8>
     aa8:	cd b7       	in	r28, 0x3d	; 61
     aaa:	de b7       	in	r29, 0x3e	; 62
     aac:	9c 83       	std	Y+4, r25	; 0x04
     aae:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     ab0:	eb 81       	ldd	r30, Y+3	; 0x03
     ab2:	fc 81       	ldd	r31, Y+4	; 0x04
     ab4:	a2 81       	ldd	r26, Z+2	; 0x02
     ab6:	b3 81       	ldd	r27, Z+3	; 0x03
     ab8:	eb 81       	ldd	r30, Y+3	; 0x03
     aba:	fc 81       	ldd	r31, Y+4	; 0x04
     abc:	84 81       	ldd	r24, Z+4	; 0x04
     abe:	95 81       	ldd	r25, Z+5	; 0x05
     ac0:	15 96       	adiw	r26, 0x05	; 5
     ac2:	9c 93       	st	X, r25
     ac4:	8e 93       	st	-X, r24
     ac6:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     ac8:	eb 81       	ldd	r30, Y+3	; 0x03
     aca:	fc 81       	ldd	r31, Y+4	; 0x04
     acc:	a4 81       	ldd	r26, Z+4	; 0x04
     ace:	b5 81       	ldd	r27, Z+5	; 0x05
     ad0:	eb 81       	ldd	r30, Y+3	; 0x03
     ad2:	fc 81       	ldd	r31, Y+4	; 0x04
     ad4:	82 81       	ldd	r24, Z+2	; 0x02
     ad6:	93 81       	ldd	r25, Z+3	; 0x03
     ad8:	13 96       	adiw	r26, 0x03	; 3
     ada:	9c 93       	st	X, r25
     adc:	8e 93       	st	-X, r24
     ade:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     ae0:	eb 81       	ldd	r30, Y+3	; 0x03
     ae2:	fc 81       	ldd	r31, Y+4	; 0x04
     ae4:	80 85       	ldd	r24, Z+8	; 0x08
     ae6:	91 85       	ldd	r25, Z+9	; 0x09
     ae8:	9a 83       	std	Y+2, r25	; 0x02
     aea:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     aec:	e9 81       	ldd	r30, Y+1	; 0x01
     aee:	fa 81       	ldd	r31, Y+2	; 0x02
     af0:	21 81       	ldd	r18, Z+1	; 0x01
     af2:	32 81       	ldd	r19, Z+2	; 0x02
     af4:	8b 81       	ldd	r24, Y+3	; 0x03
     af6:	9c 81       	ldd	r25, Y+4	; 0x04
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	41 f4       	brne	.+16     	; 0xb0e <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     afe:	eb 81       	ldd	r30, Y+3	; 0x03
     b00:	fc 81       	ldd	r31, Y+4	; 0x04
     b02:	84 81       	ldd	r24, Z+4	; 0x04
     b04:	95 81       	ldd	r25, Z+5	; 0x05
     b06:	e9 81       	ldd	r30, Y+1	; 0x01
     b08:	fa 81       	ldd	r31, Y+2	; 0x02
     b0a:	92 83       	std	Z+2, r25	; 0x02
     b0c:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     b0e:	eb 81       	ldd	r30, Y+3	; 0x03
     b10:	fc 81       	ldd	r31, Y+4	; 0x04
     b12:	11 86       	std	Z+9, r1	; 0x09
     b14:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     b16:	e9 81       	ldd	r30, Y+1	; 0x01
     b18:	fa 81       	ldd	r31, Y+2	; 0x02
     b1a:	80 81       	ld	r24, Z
     b1c:	81 50       	subi	r24, 0x01	; 1
     b1e:	e9 81       	ldd	r30, Y+1	; 0x01
     b20:	fa 81       	ldd	r31, Y+2	; 0x02
     b22:	80 83       	st	Z, r24
}
     b24:	0f 90       	pop	r0
     b26:	0f 90       	pop	r0
     b28:	0f 90       	pop	r0
     b2a:	0f 90       	pop	r0
     b2c:	cf 91       	pop	r28
     b2e:	df 91       	pop	r29
     b30:	08 95       	ret

00000b32 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
     b32:	df 93       	push	r29
     b34:	cf 93       	push	r28
     b36:	cd b7       	in	r28, 0x3d	; 61
     b38:	de b7       	in	r29, 0x3e	; 62
     b3a:	28 97       	sbiw	r28, 0x08	; 8
     b3c:	0f b6       	in	r0, 0x3f	; 63
     b3e:	f8 94       	cli
     b40:	de bf       	out	0x3e, r29	; 62
     b42:	0f be       	out	0x3f, r0	; 63
     b44:	cd bf       	out	0x3d, r28	; 61
     b46:	9c 83       	std	Y+4, r25	; 0x04
     b48:	8b 83       	std	Y+3, r24	; 0x03
     b4a:	7e 83       	std	Y+6, r23	; 0x06
     b4c:	6d 83       	std	Y+5, r22	; 0x05
     b4e:	58 87       	std	Y+8, r21	; 0x08
     b50:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     b52:	eb 81       	ldd	r30, Y+3	; 0x03
     b54:	fc 81       	ldd	r31, Y+4	; 0x04
     b56:	81 e1       	ldi	r24, 0x11	; 17
     b58:	80 83       	st	Z, r24
	pxTopOfStack--;
     b5a:	8b 81       	ldd	r24, Y+3	; 0x03
     b5c:	9c 81       	ldd	r25, Y+4	; 0x04
     b5e:	01 97       	sbiw	r24, 0x01	; 1
     b60:	9c 83       	std	Y+4, r25	; 0x04
     b62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     b64:	eb 81       	ldd	r30, Y+3	; 0x03
     b66:	fc 81       	ldd	r31, Y+4	; 0x04
     b68:	82 e2       	ldi	r24, 0x22	; 34
     b6a:	80 83       	st	Z, r24
	pxTopOfStack--;
     b6c:	8b 81       	ldd	r24, Y+3	; 0x03
     b6e:	9c 81       	ldd	r25, Y+4	; 0x04
     b70:	01 97       	sbiw	r24, 0x01	; 1
     b72:	9c 83       	std	Y+4, r25	; 0x04
     b74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     b76:	eb 81       	ldd	r30, Y+3	; 0x03
     b78:	fc 81       	ldd	r31, Y+4	; 0x04
     b7a:	83 e3       	ldi	r24, 0x33	; 51
     b7c:	80 83       	st	Z, r24
	pxTopOfStack--;
     b7e:	8b 81       	ldd	r24, Y+3	; 0x03
     b80:	9c 81       	ldd	r25, Y+4	; 0x04
     b82:	01 97       	sbiw	r24, 0x01	; 1
     b84:	9c 83       	std	Y+4, r25	; 0x04
     b86:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
     b88:	8d 81       	ldd	r24, Y+5	; 0x05
     b8a:	9e 81       	ldd	r25, Y+6	; 0x06
     b8c:	9a 83       	std	Y+2, r25	; 0x02
     b8e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     b90:	89 81       	ldd	r24, Y+1	; 0x01
     b92:	eb 81       	ldd	r30, Y+3	; 0x03
     b94:	fc 81       	ldd	r31, Y+4	; 0x04
     b96:	80 83       	st	Z, r24
	pxTopOfStack--;
     b98:	8b 81       	ldd	r24, Y+3	; 0x03
     b9a:	9c 81       	ldd	r25, Y+4	; 0x04
     b9c:	01 97       	sbiw	r24, 0x01	; 1
     b9e:	9c 83       	std	Y+4, r25	; 0x04
     ba0:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     ba2:	89 81       	ldd	r24, Y+1	; 0x01
     ba4:	9a 81       	ldd	r25, Y+2	; 0x02
     ba6:	89 2f       	mov	r24, r25
     ba8:	99 27       	eor	r25, r25
     baa:	9a 83       	std	Y+2, r25	; 0x02
     bac:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     bae:	89 81       	ldd	r24, Y+1	; 0x01
     bb0:	eb 81       	ldd	r30, Y+3	; 0x03
     bb2:	fc 81       	ldd	r31, Y+4	; 0x04
     bb4:	80 83       	st	Z, r24
	pxTopOfStack--;
     bb6:	8b 81       	ldd	r24, Y+3	; 0x03
     bb8:	9c 81       	ldd	r25, Y+4	; 0x04
     bba:	01 97       	sbiw	r24, 0x01	; 1
     bbc:	9c 83       	std	Y+4, r25	; 0x04
     bbe:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     bc0:	eb 81       	ldd	r30, Y+3	; 0x03
     bc2:	fc 81       	ldd	r31, Y+4	; 0x04
     bc4:	10 82       	st	Z, r1
	pxTopOfStack--;
     bc6:	8b 81       	ldd	r24, Y+3	; 0x03
     bc8:	9c 81       	ldd	r25, Y+4	; 0x04
     bca:	01 97       	sbiw	r24, 0x01	; 1
     bcc:	9c 83       	std	Y+4, r25	; 0x04
     bce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     bd0:	eb 81       	ldd	r30, Y+3	; 0x03
     bd2:	fc 81       	ldd	r31, Y+4	; 0x04
     bd4:	80 e8       	ldi	r24, 0x80	; 128
     bd6:	80 83       	st	Z, r24
	pxTopOfStack--;
     bd8:	8b 81       	ldd	r24, Y+3	; 0x03
     bda:	9c 81       	ldd	r25, Y+4	; 0x04
     bdc:	01 97       	sbiw	r24, 0x01	; 1
     bde:	9c 83       	std	Y+4, r25	; 0x04
     be0:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     be2:	eb 81       	ldd	r30, Y+3	; 0x03
     be4:	fc 81       	ldd	r31, Y+4	; 0x04
     be6:	10 82       	st	Z, r1
	pxTopOfStack--;
     be8:	8b 81       	ldd	r24, Y+3	; 0x03
     bea:	9c 81       	ldd	r25, Y+4	; 0x04
     bec:	01 97       	sbiw	r24, 0x01	; 1
     bee:	9c 83       	std	Y+4, r25	; 0x04
     bf0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     bf2:	eb 81       	ldd	r30, Y+3	; 0x03
     bf4:	fc 81       	ldd	r31, Y+4	; 0x04
     bf6:	82 e0       	ldi	r24, 0x02	; 2
     bf8:	80 83       	st	Z, r24
	pxTopOfStack--;
     bfa:	8b 81       	ldd	r24, Y+3	; 0x03
     bfc:	9c 81       	ldd	r25, Y+4	; 0x04
     bfe:	01 97       	sbiw	r24, 0x01	; 1
     c00:	9c 83       	std	Y+4, r25	; 0x04
     c02:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     c04:	eb 81       	ldd	r30, Y+3	; 0x03
     c06:	fc 81       	ldd	r31, Y+4	; 0x04
     c08:	83 e0       	ldi	r24, 0x03	; 3
     c0a:	80 83       	st	Z, r24
	pxTopOfStack--;
     c0c:	8b 81       	ldd	r24, Y+3	; 0x03
     c0e:	9c 81       	ldd	r25, Y+4	; 0x04
     c10:	01 97       	sbiw	r24, 0x01	; 1
     c12:	9c 83       	std	Y+4, r25	; 0x04
     c14:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     c16:	eb 81       	ldd	r30, Y+3	; 0x03
     c18:	fc 81       	ldd	r31, Y+4	; 0x04
     c1a:	84 e0       	ldi	r24, 0x04	; 4
     c1c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c1e:	8b 81       	ldd	r24, Y+3	; 0x03
     c20:	9c 81       	ldd	r25, Y+4	; 0x04
     c22:	01 97       	sbiw	r24, 0x01	; 1
     c24:	9c 83       	std	Y+4, r25	; 0x04
     c26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     c28:	eb 81       	ldd	r30, Y+3	; 0x03
     c2a:	fc 81       	ldd	r31, Y+4	; 0x04
     c2c:	85 e0       	ldi	r24, 0x05	; 5
     c2e:	80 83       	st	Z, r24
	pxTopOfStack--;
     c30:	8b 81       	ldd	r24, Y+3	; 0x03
     c32:	9c 81       	ldd	r25, Y+4	; 0x04
     c34:	01 97       	sbiw	r24, 0x01	; 1
     c36:	9c 83       	std	Y+4, r25	; 0x04
     c38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     c3a:	eb 81       	ldd	r30, Y+3	; 0x03
     c3c:	fc 81       	ldd	r31, Y+4	; 0x04
     c3e:	86 e0       	ldi	r24, 0x06	; 6
     c40:	80 83       	st	Z, r24
	pxTopOfStack--;
     c42:	8b 81       	ldd	r24, Y+3	; 0x03
     c44:	9c 81       	ldd	r25, Y+4	; 0x04
     c46:	01 97       	sbiw	r24, 0x01	; 1
     c48:	9c 83       	std	Y+4, r25	; 0x04
     c4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     c4c:	eb 81       	ldd	r30, Y+3	; 0x03
     c4e:	fc 81       	ldd	r31, Y+4	; 0x04
     c50:	87 e0       	ldi	r24, 0x07	; 7
     c52:	80 83       	st	Z, r24
	pxTopOfStack--;
     c54:	8b 81       	ldd	r24, Y+3	; 0x03
     c56:	9c 81       	ldd	r25, Y+4	; 0x04
     c58:	01 97       	sbiw	r24, 0x01	; 1
     c5a:	9c 83       	std	Y+4, r25	; 0x04
     c5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     c5e:	eb 81       	ldd	r30, Y+3	; 0x03
     c60:	fc 81       	ldd	r31, Y+4	; 0x04
     c62:	88 e0       	ldi	r24, 0x08	; 8
     c64:	80 83       	st	Z, r24
	pxTopOfStack--;
     c66:	8b 81       	ldd	r24, Y+3	; 0x03
     c68:	9c 81       	ldd	r25, Y+4	; 0x04
     c6a:	01 97       	sbiw	r24, 0x01	; 1
     c6c:	9c 83       	std	Y+4, r25	; 0x04
     c6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     c70:	eb 81       	ldd	r30, Y+3	; 0x03
     c72:	fc 81       	ldd	r31, Y+4	; 0x04
     c74:	89 e0       	ldi	r24, 0x09	; 9
     c76:	80 83       	st	Z, r24
	pxTopOfStack--;
     c78:	8b 81       	ldd	r24, Y+3	; 0x03
     c7a:	9c 81       	ldd	r25, Y+4	; 0x04
     c7c:	01 97       	sbiw	r24, 0x01	; 1
     c7e:	9c 83       	std	Y+4, r25	; 0x04
     c80:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     c82:	eb 81       	ldd	r30, Y+3	; 0x03
     c84:	fc 81       	ldd	r31, Y+4	; 0x04
     c86:	80 e1       	ldi	r24, 0x10	; 16
     c88:	80 83       	st	Z, r24
	pxTopOfStack--;
     c8a:	8b 81       	ldd	r24, Y+3	; 0x03
     c8c:	9c 81       	ldd	r25, Y+4	; 0x04
     c8e:	01 97       	sbiw	r24, 0x01	; 1
     c90:	9c 83       	std	Y+4, r25	; 0x04
     c92:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     c94:	eb 81       	ldd	r30, Y+3	; 0x03
     c96:	fc 81       	ldd	r31, Y+4	; 0x04
     c98:	81 e1       	ldi	r24, 0x11	; 17
     c9a:	80 83       	st	Z, r24
	pxTopOfStack--;
     c9c:	8b 81       	ldd	r24, Y+3	; 0x03
     c9e:	9c 81       	ldd	r25, Y+4	; 0x04
     ca0:	01 97       	sbiw	r24, 0x01	; 1
     ca2:	9c 83       	std	Y+4, r25	; 0x04
     ca4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     ca6:	eb 81       	ldd	r30, Y+3	; 0x03
     ca8:	fc 81       	ldd	r31, Y+4	; 0x04
     caa:	82 e1       	ldi	r24, 0x12	; 18
     cac:	80 83       	st	Z, r24
	pxTopOfStack--;
     cae:	8b 81       	ldd	r24, Y+3	; 0x03
     cb0:	9c 81       	ldd	r25, Y+4	; 0x04
     cb2:	01 97       	sbiw	r24, 0x01	; 1
     cb4:	9c 83       	std	Y+4, r25	; 0x04
     cb6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     cb8:	eb 81       	ldd	r30, Y+3	; 0x03
     cba:	fc 81       	ldd	r31, Y+4	; 0x04
     cbc:	83 e1       	ldi	r24, 0x13	; 19
     cbe:	80 83       	st	Z, r24
	pxTopOfStack--;
     cc0:	8b 81       	ldd	r24, Y+3	; 0x03
     cc2:	9c 81       	ldd	r25, Y+4	; 0x04
     cc4:	01 97       	sbiw	r24, 0x01	; 1
     cc6:	9c 83       	std	Y+4, r25	; 0x04
     cc8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     cca:	eb 81       	ldd	r30, Y+3	; 0x03
     ccc:	fc 81       	ldd	r31, Y+4	; 0x04
     cce:	84 e1       	ldi	r24, 0x14	; 20
     cd0:	80 83       	st	Z, r24
	pxTopOfStack--;
     cd2:	8b 81       	ldd	r24, Y+3	; 0x03
     cd4:	9c 81       	ldd	r25, Y+4	; 0x04
     cd6:	01 97       	sbiw	r24, 0x01	; 1
     cd8:	9c 83       	std	Y+4, r25	; 0x04
     cda:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     cdc:	eb 81       	ldd	r30, Y+3	; 0x03
     cde:	fc 81       	ldd	r31, Y+4	; 0x04
     ce0:	85 e1       	ldi	r24, 0x15	; 21
     ce2:	80 83       	st	Z, r24
	pxTopOfStack--;
     ce4:	8b 81       	ldd	r24, Y+3	; 0x03
     ce6:	9c 81       	ldd	r25, Y+4	; 0x04
     ce8:	01 97       	sbiw	r24, 0x01	; 1
     cea:	9c 83       	std	Y+4, r25	; 0x04
     cec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     cee:	eb 81       	ldd	r30, Y+3	; 0x03
     cf0:	fc 81       	ldd	r31, Y+4	; 0x04
     cf2:	86 e1       	ldi	r24, 0x16	; 22
     cf4:	80 83       	st	Z, r24
	pxTopOfStack--;
     cf6:	8b 81       	ldd	r24, Y+3	; 0x03
     cf8:	9c 81       	ldd	r25, Y+4	; 0x04
     cfa:	01 97       	sbiw	r24, 0x01	; 1
     cfc:	9c 83       	std	Y+4, r25	; 0x04
     cfe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     d00:	eb 81       	ldd	r30, Y+3	; 0x03
     d02:	fc 81       	ldd	r31, Y+4	; 0x04
     d04:	87 e1       	ldi	r24, 0x17	; 23
     d06:	80 83       	st	Z, r24
	pxTopOfStack--;
     d08:	8b 81       	ldd	r24, Y+3	; 0x03
     d0a:	9c 81       	ldd	r25, Y+4	; 0x04
     d0c:	01 97       	sbiw	r24, 0x01	; 1
     d0e:	9c 83       	std	Y+4, r25	; 0x04
     d10:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     d12:	eb 81       	ldd	r30, Y+3	; 0x03
     d14:	fc 81       	ldd	r31, Y+4	; 0x04
     d16:	88 e1       	ldi	r24, 0x18	; 24
     d18:	80 83       	st	Z, r24
	pxTopOfStack--;
     d1a:	8b 81       	ldd	r24, Y+3	; 0x03
     d1c:	9c 81       	ldd	r25, Y+4	; 0x04
     d1e:	01 97       	sbiw	r24, 0x01	; 1
     d20:	9c 83       	std	Y+4, r25	; 0x04
     d22:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     d24:	eb 81       	ldd	r30, Y+3	; 0x03
     d26:	fc 81       	ldd	r31, Y+4	; 0x04
     d28:	89 e1       	ldi	r24, 0x19	; 25
     d2a:	80 83       	st	Z, r24
	pxTopOfStack--;
     d2c:	8b 81       	ldd	r24, Y+3	; 0x03
     d2e:	9c 81       	ldd	r25, Y+4	; 0x04
     d30:	01 97       	sbiw	r24, 0x01	; 1
     d32:	9c 83       	std	Y+4, r25	; 0x04
     d34:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     d36:	eb 81       	ldd	r30, Y+3	; 0x03
     d38:	fc 81       	ldd	r31, Y+4	; 0x04
     d3a:	80 e2       	ldi	r24, 0x20	; 32
     d3c:	80 83       	st	Z, r24
	pxTopOfStack--;
     d3e:	8b 81       	ldd	r24, Y+3	; 0x03
     d40:	9c 81       	ldd	r25, Y+4	; 0x04
     d42:	01 97       	sbiw	r24, 0x01	; 1
     d44:	9c 83       	std	Y+4, r25	; 0x04
     d46:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     d48:	eb 81       	ldd	r30, Y+3	; 0x03
     d4a:	fc 81       	ldd	r31, Y+4	; 0x04
     d4c:	81 e2       	ldi	r24, 0x21	; 33
     d4e:	80 83       	st	Z, r24
	pxTopOfStack--;
     d50:	8b 81       	ldd	r24, Y+3	; 0x03
     d52:	9c 81       	ldd	r25, Y+4	; 0x04
     d54:	01 97       	sbiw	r24, 0x01	; 1
     d56:	9c 83       	std	Y+4, r25	; 0x04
     d58:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     d5a:	eb 81       	ldd	r30, Y+3	; 0x03
     d5c:	fc 81       	ldd	r31, Y+4	; 0x04
     d5e:	82 e2       	ldi	r24, 0x22	; 34
     d60:	80 83       	st	Z, r24
	pxTopOfStack--;
     d62:	8b 81       	ldd	r24, Y+3	; 0x03
     d64:	9c 81       	ldd	r25, Y+4	; 0x04
     d66:	01 97       	sbiw	r24, 0x01	; 1
     d68:	9c 83       	std	Y+4, r25	; 0x04
     d6a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     d6c:	eb 81       	ldd	r30, Y+3	; 0x03
     d6e:	fc 81       	ldd	r31, Y+4	; 0x04
     d70:	83 e2       	ldi	r24, 0x23	; 35
     d72:	80 83       	st	Z, r24
	pxTopOfStack--;
     d74:	8b 81       	ldd	r24, Y+3	; 0x03
     d76:	9c 81       	ldd	r25, Y+4	; 0x04
     d78:	01 97       	sbiw	r24, 0x01	; 1
     d7a:	9c 83       	std	Y+4, r25	; 0x04
     d7c:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
     d7e:	8f 81       	ldd	r24, Y+7	; 0x07
     d80:	98 85       	ldd	r25, Y+8	; 0x08
     d82:	9a 83       	std	Y+2, r25	; 0x02
     d84:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     d86:	89 81       	ldd	r24, Y+1	; 0x01
     d88:	eb 81       	ldd	r30, Y+3	; 0x03
     d8a:	fc 81       	ldd	r31, Y+4	; 0x04
     d8c:	80 83       	st	Z, r24
	pxTopOfStack--;
     d8e:	8b 81       	ldd	r24, Y+3	; 0x03
     d90:	9c 81       	ldd	r25, Y+4	; 0x04
     d92:	01 97       	sbiw	r24, 0x01	; 1
     d94:	9c 83       	std	Y+4, r25	; 0x04
     d96:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     d98:	89 81       	ldd	r24, Y+1	; 0x01
     d9a:	9a 81       	ldd	r25, Y+2	; 0x02
     d9c:	89 2f       	mov	r24, r25
     d9e:	99 27       	eor	r25, r25
     da0:	9a 83       	std	Y+2, r25	; 0x02
     da2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     da4:	89 81       	ldd	r24, Y+1	; 0x01
     da6:	eb 81       	ldd	r30, Y+3	; 0x03
     da8:	fc 81       	ldd	r31, Y+4	; 0x04
     daa:	80 83       	st	Z, r24
	pxTopOfStack--;
     dac:	8b 81       	ldd	r24, Y+3	; 0x03
     dae:	9c 81       	ldd	r25, Y+4	; 0x04
     db0:	01 97       	sbiw	r24, 0x01	; 1
     db2:	9c 83       	std	Y+4, r25	; 0x04
     db4:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     db6:	eb 81       	ldd	r30, Y+3	; 0x03
     db8:	fc 81       	ldd	r31, Y+4	; 0x04
     dba:	86 e2       	ldi	r24, 0x26	; 38
     dbc:	80 83       	st	Z, r24
	pxTopOfStack--;
     dbe:	8b 81       	ldd	r24, Y+3	; 0x03
     dc0:	9c 81       	ldd	r25, Y+4	; 0x04
     dc2:	01 97       	sbiw	r24, 0x01	; 1
     dc4:	9c 83       	std	Y+4, r25	; 0x04
     dc6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     dc8:	eb 81       	ldd	r30, Y+3	; 0x03
     dca:	fc 81       	ldd	r31, Y+4	; 0x04
     dcc:	87 e2       	ldi	r24, 0x27	; 39
     dce:	80 83       	st	Z, r24
	pxTopOfStack--;
     dd0:	8b 81       	ldd	r24, Y+3	; 0x03
     dd2:	9c 81       	ldd	r25, Y+4	; 0x04
     dd4:	01 97       	sbiw	r24, 0x01	; 1
     dd6:	9c 83       	std	Y+4, r25	; 0x04
     dd8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     dda:	eb 81       	ldd	r30, Y+3	; 0x03
     ddc:	fc 81       	ldd	r31, Y+4	; 0x04
     dde:	88 e2       	ldi	r24, 0x28	; 40
     de0:	80 83       	st	Z, r24
	pxTopOfStack--;
     de2:	8b 81       	ldd	r24, Y+3	; 0x03
     de4:	9c 81       	ldd	r25, Y+4	; 0x04
     de6:	01 97       	sbiw	r24, 0x01	; 1
     de8:	9c 83       	std	Y+4, r25	; 0x04
     dea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     dec:	eb 81       	ldd	r30, Y+3	; 0x03
     dee:	fc 81       	ldd	r31, Y+4	; 0x04
     df0:	89 e2       	ldi	r24, 0x29	; 41
     df2:	80 83       	st	Z, r24
	pxTopOfStack--;
     df4:	8b 81       	ldd	r24, Y+3	; 0x03
     df6:	9c 81       	ldd	r25, Y+4	; 0x04
     df8:	01 97       	sbiw	r24, 0x01	; 1
     dfa:	9c 83       	std	Y+4, r25	; 0x04
     dfc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     dfe:	eb 81       	ldd	r30, Y+3	; 0x03
     e00:	fc 81       	ldd	r31, Y+4	; 0x04
     e02:	80 e3       	ldi	r24, 0x30	; 48
     e04:	80 83       	st	Z, r24
	pxTopOfStack--;
     e06:	8b 81       	ldd	r24, Y+3	; 0x03
     e08:	9c 81       	ldd	r25, Y+4	; 0x04
     e0a:	01 97       	sbiw	r24, 0x01	; 1
     e0c:	9c 83       	std	Y+4, r25	; 0x04
     e0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     e10:	eb 81       	ldd	r30, Y+3	; 0x03
     e12:	fc 81       	ldd	r31, Y+4	; 0x04
     e14:	81 e3       	ldi	r24, 0x31	; 49
     e16:	80 83       	st	Z, r24
	pxTopOfStack--;
     e18:	8b 81       	ldd	r24, Y+3	; 0x03
     e1a:	9c 81       	ldd	r25, Y+4	; 0x04
     e1c:	01 97       	sbiw	r24, 0x01	; 1
     e1e:	9c 83       	std	Y+4, r25	; 0x04
     e20:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     e22:	8b 81       	ldd	r24, Y+3	; 0x03
     e24:	9c 81       	ldd	r25, Y+4	; 0x04
}
     e26:	28 96       	adiw	r28, 0x08	; 8
     e28:	0f b6       	in	r0, 0x3f	; 63
     e2a:	f8 94       	cli
     e2c:	de bf       	out	0x3e, r29	; 62
     e2e:	0f be       	out	0x3f, r0	; 63
     e30:	cd bf       	out	0x3d, r28	; 61
     e32:	cf 91       	pop	r28
     e34:	df 91       	pop	r29
     e36:	08 95       	ret

00000e38 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
     e38:	df 93       	push	r29
     e3a:	cf 93       	push	r28
     e3c:	cd b7       	in	r28, 0x3d	; 61
     e3e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     e40:	0e 94 0c 08 	call	0x1018	; 0x1018 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     e44:	a0 91 0f 03 	lds	r26, 0x030F
     e48:	b0 91 10 03 	lds	r27, 0x0310
     e4c:	cd 91       	ld	r28, X+
     e4e:	cd bf       	out	0x3d, r28	; 61
     e50:	dd 91       	ld	r29, X+
     e52:	de bf       	out	0x3e, r29	; 62
     e54:	ff 91       	pop	r31
     e56:	ef 91       	pop	r30
     e58:	df 91       	pop	r29
     e5a:	cf 91       	pop	r28
     e5c:	bf 91       	pop	r27
     e5e:	af 91       	pop	r26
     e60:	9f 91       	pop	r25
     e62:	8f 91       	pop	r24
     e64:	7f 91       	pop	r23
     e66:	6f 91       	pop	r22
     e68:	5f 91       	pop	r21
     e6a:	4f 91       	pop	r20
     e6c:	3f 91       	pop	r19
     e6e:	2f 91       	pop	r18
     e70:	1f 91       	pop	r17
     e72:	0f 91       	pop	r16
     e74:	ff 90       	pop	r15
     e76:	ef 90       	pop	r14
     e78:	df 90       	pop	r13
     e7a:	cf 90       	pop	r12
     e7c:	bf 90       	pop	r11
     e7e:	af 90       	pop	r10
     e80:	9f 90       	pop	r9
     e82:	8f 90       	pop	r8
     e84:	7f 90       	pop	r7
     e86:	6f 90       	pop	r6
     e88:	5f 90       	pop	r5
     e8a:	4f 90       	pop	r4
     e8c:	3f 90       	pop	r3
     e8e:	2f 90       	pop	r2
     e90:	1f 90       	pop	r1
     e92:	0f 90       	pop	r0
     e94:	0f be       	out	0x3f, r0	; 63
     e96:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     e98:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     e9a:	81 e0       	ldi	r24, 0x01	; 1
}
     e9c:	cf 91       	pop	r28
     e9e:	df 91       	pop	r29
     ea0:	08 95       	ret

00000ea2 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     ea2:	df 93       	push	r29
     ea4:	cf 93       	push	r28
     ea6:	cd b7       	in	r28, 0x3d	; 61
     ea8:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     eaa:	cf 91       	pop	r28
     eac:	df 91       	pop	r29
     eae:	08 95       	ret

00000eb0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     eb0:	0f 92       	push	r0
     eb2:	0f b6       	in	r0, 0x3f	; 63
     eb4:	f8 94       	cli
     eb6:	0f 92       	push	r0
     eb8:	1f 92       	push	r1
     eba:	11 24       	eor	r1, r1
     ebc:	2f 92       	push	r2
     ebe:	3f 92       	push	r3
     ec0:	4f 92       	push	r4
     ec2:	5f 92       	push	r5
     ec4:	6f 92       	push	r6
     ec6:	7f 92       	push	r7
     ec8:	8f 92       	push	r8
     eca:	9f 92       	push	r9
     ecc:	af 92       	push	r10
     ece:	bf 92       	push	r11
     ed0:	cf 92       	push	r12
     ed2:	df 92       	push	r13
     ed4:	ef 92       	push	r14
     ed6:	ff 92       	push	r15
     ed8:	0f 93       	push	r16
     eda:	1f 93       	push	r17
     edc:	2f 93       	push	r18
     ede:	3f 93       	push	r19
     ee0:	4f 93       	push	r20
     ee2:	5f 93       	push	r21
     ee4:	6f 93       	push	r22
     ee6:	7f 93       	push	r23
     ee8:	8f 93       	push	r24
     eea:	9f 93       	push	r25
     eec:	af 93       	push	r26
     eee:	bf 93       	push	r27
     ef0:	cf 93       	push	r28
     ef2:	df 93       	push	r29
     ef4:	ef 93       	push	r30
     ef6:	ff 93       	push	r31
     ef8:	a0 91 0f 03 	lds	r26, 0x030F
     efc:	b0 91 10 03 	lds	r27, 0x0310
     f00:	0d b6       	in	r0, 0x3d	; 61
     f02:	0d 92       	st	X+, r0
     f04:	0e b6       	in	r0, 0x3e	; 62
     f06:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     f08:	0e 94 c8 10 	call	0x2190	; 0x2190 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     f0c:	a0 91 0f 03 	lds	r26, 0x030F
     f10:	b0 91 10 03 	lds	r27, 0x0310
     f14:	cd 91       	ld	r28, X+
     f16:	cd bf       	out	0x3d, r28	; 61
     f18:	dd 91       	ld	r29, X+
     f1a:	de bf       	out	0x3e, r29	; 62
     f1c:	ff 91       	pop	r31
     f1e:	ef 91       	pop	r30
     f20:	df 91       	pop	r29
     f22:	cf 91       	pop	r28
     f24:	bf 91       	pop	r27
     f26:	af 91       	pop	r26
     f28:	9f 91       	pop	r25
     f2a:	8f 91       	pop	r24
     f2c:	7f 91       	pop	r23
     f2e:	6f 91       	pop	r22
     f30:	5f 91       	pop	r21
     f32:	4f 91       	pop	r20
     f34:	3f 91       	pop	r19
     f36:	2f 91       	pop	r18
     f38:	1f 91       	pop	r17
     f3a:	0f 91       	pop	r16
     f3c:	ff 90       	pop	r15
     f3e:	ef 90       	pop	r14
     f40:	df 90       	pop	r13
     f42:	cf 90       	pop	r12
     f44:	bf 90       	pop	r11
     f46:	af 90       	pop	r10
     f48:	9f 90       	pop	r9
     f4a:	8f 90       	pop	r8
     f4c:	7f 90       	pop	r7
     f4e:	6f 90       	pop	r6
     f50:	5f 90       	pop	r5
     f52:	4f 90       	pop	r4
     f54:	3f 90       	pop	r3
     f56:	2f 90       	pop	r2
     f58:	1f 90       	pop	r1
     f5a:	0f 90       	pop	r0
     f5c:	0f be       	out	0x3f, r0	; 63
     f5e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f60:	08 95       	ret

00000f62 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     f62:	0f 92       	push	r0
     f64:	0f b6       	in	r0, 0x3f	; 63
     f66:	f8 94       	cli
     f68:	0f 92       	push	r0
     f6a:	1f 92       	push	r1
     f6c:	11 24       	eor	r1, r1
     f6e:	2f 92       	push	r2
     f70:	3f 92       	push	r3
     f72:	4f 92       	push	r4
     f74:	5f 92       	push	r5
     f76:	6f 92       	push	r6
     f78:	7f 92       	push	r7
     f7a:	8f 92       	push	r8
     f7c:	9f 92       	push	r9
     f7e:	af 92       	push	r10
     f80:	bf 92       	push	r11
     f82:	cf 92       	push	r12
     f84:	df 92       	push	r13
     f86:	ef 92       	push	r14
     f88:	ff 92       	push	r15
     f8a:	0f 93       	push	r16
     f8c:	1f 93       	push	r17
     f8e:	2f 93       	push	r18
     f90:	3f 93       	push	r19
     f92:	4f 93       	push	r20
     f94:	5f 93       	push	r21
     f96:	6f 93       	push	r22
     f98:	7f 93       	push	r23
     f9a:	8f 93       	push	r24
     f9c:	9f 93       	push	r25
     f9e:	af 93       	push	r26
     fa0:	bf 93       	push	r27
     fa2:	cf 93       	push	r28
     fa4:	df 93       	push	r29
     fa6:	ef 93       	push	r30
     fa8:	ff 93       	push	r31
     faa:	a0 91 0f 03 	lds	r26, 0x030F
     fae:	b0 91 10 03 	lds	r27, 0x0310
     fb2:	0d b6       	in	r0, 0x3d	; 61
     fb4:	0d 92       	st	X+, r0
     fb6:	0e b6       	in	r0, 0x3e	; 62
     fb8:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     fba:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <vTaskIncrementTick>
	vTaskSwitchContext();
     fbe:	0e 94 c8 10 	call	0x2190	; 0x2190 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     fc2:	a0 91 0f 03 	lds	r26, 0x030F
     fc6:	b0 91 10 03 	lds	r27, 0x0310
     fca:	cd 91       	ld	r28, X+
     fcc:	cd bf       	out	0x3d, r28	; 61
     fce:	dd 91       	ld	r29, X+
     fd0:	de bf       	out	0x3e, r29	; 62
     fd2:	ff 91       	pop	r31
     fd4:	ef 91       	pop	r30
     fd6:	df 91       	pop	r29
     fd8:	cf 91       	pop	r28
     fda:	bf 91       	pop	r27
     fdc:	af 91       	pop	r26
     fde:	9f 91       	pop	r25
     fe0:	8f 91       	pop	r24
     fe2:	7f 91       	pop	r23
     fe4:	6f 91       	pop	r22
     fe6:	5f 91       	pop	r21
     fe8:	4f 91       	pop	r20
     fea:	3f 91       	pop	r19
     fec:	2f 91       	pop	r18
     fee:	1f 91       	pop	r17
     ff0:	0f 91       	pop	r16
     ff2:	ff 90       	pop	r15
     ff4:	ef 90       	pop	r14
     ff6:	df 90       	pop	r13
     ff8:	cf 90       	pop	r12
     ffa:	bf 90       	pop	r11
     ffc:	af 90       	pop	r10
     ffe:	9f 90       	pop	r9
    1000:	8f 90       	pop	r8
    1002:	7f 90       	pop	r7
    1004:	6f 90       	pop	r6
    1006:	5f 90       	pop	r5
    1008:	4f 90       	pop	r4
    100a:	3f 90       	pop	r3
    100c:	2f 90       	pop	r2
    100e:	1f 90       	pop	r1
    1010:	0f 90       	pop	r0
    1012:	0f be       	out	0x3f, r0	; 63
    1014:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1016:	08 95       	ret

00001018 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1018:	df 93       	push	r29
    101a:	cf 93       	push	r28
    101c:	00 d0       	rcall	.+0      	; 0x101e <prvSetupTimerInterrupt+0x6>
    101e:	00 d0       	rcall	.+0      	; 0x1020 <prvSetupTimerInterrupt+0x8>
    1020:	00 d0       	rcall	.+0      	; 0x1022 <prvSetupTimerInterrupt+0xa>
    1022:	cd b7       	in	r28, 0x3d	; 61
    1024:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1026:	80 e4       	ldi	r24, 0x40	; 64
    1028:	9f e1       	ldi	r25, 0x1F	; 31
    102a:	a0 e0       	ldi	r26, 0x00	; 0
    102c:	b0 e0       	ldi	r27, 0x00	; 0
    102e:	8b 83       	std	Y+3, r24	; 0x03
    1030:	9c 83       	std	Y+4, r25	; 0x04
    1032:	ad 83       	std	Y+5, r26	; 0x05
    1034:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1036:	8b 81       	ldd	r24, Y+3	; 0x03
    1038:	9c 81       	ldd	r25, Y+4	; 0x04
    103a:	ad 81       	ldd	r26, Y+5	; 0x05
    103c:	be 81       	ldd	r27, Y+6	; 0x06
    103e:	68 94       	set
    1040:	15 f8       	bld	r1, 5
    1042:	b6 95       	lsr	r27
    1044:	a7 95       	ror	r26
    1046:	97 95       	ror	r25
    1048:	87 95       	ror	r24
    104a:	16 94       	lsr	r1
    104c:	d1 f7       	brne	.-12     	; 0x1042 <prvSetupTimerInterrupt+0x2a>
    104e:	8b 83       	std	Y+3, r24	; 0x03
    1050:	9c 83       	std	Y+4, r25	; 0x04
    1052:	ad 83       	std	Y+5, r26	; 0x05
    1054:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    1056:	8b 81       	ldd	r24, Y+3	; 0x03
    1058:	9c 81       	ldd	r25, Y+4	; 0x04
    105a:	ad 81       	ldd	r26, Y+5	; 0x05
    105c:	be 81       	ldd	r27, Y+6	; 0x06
    105e:	01 97       	sbiw	r24, 0x01	; 1
    1060:	a1 09       	sbc	r26, r1
    1062:	b1 09       	sbc	r27, r1
    1064:	8b 83       	std	Y+3, r24	; 0x03
    1066:	9c 83       	std	Y+4, r25	; 0x04
    1068:	ad 83       	std	Y+5, r26	; 0x05
    106a:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    106c:	8b 81       	ldd	r24, Y+3	; 0x03
    106e:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1070:	8b 81       	ldd	r24, Y+3	; 0x03
    1072:	9c 81       	ldd	r25, Y+4	; 0x04
    1074:	ad 81       	ldd	r26, Y+5	; 0x05
    1076:	be 81       	ldd	r27, Y+6	; 0x06
    1078:	89 2f       	mov	r24, r25
    107a:	9a 2f       	mov	r25, r26
    107c:	ab 2f       	mov	r26, r27
    107e:	bb 27       	eor	r27, r27
    1080:	8b 83       	std	Y+3, r24	; 0x03
    1082:	9c 83       	std	Y+4, r25	; 0x04
    1084:	ad 83       	std	Y+5, r26	; 0x05
    1086:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1088:	8b 81       	ldd	r24, Y+3	; 0x03
    108a:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    108c:	eb e4       	ldi	r30, 0x4B	; 75
    108e:	f0 e0       	ldi	r31, 0x00	; 0
    1090:	8a 81       	ldd	r24, Y+2	; 0x02
    1092:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1094:	ea e4       	ldi	r30, 0x4A	; 74
    1096:	f0 e0       	ldi	r31, 0x00	; 0
    1098:	89 81       	ldd	r24, Y+1	; 0x01
    109a:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    109c:	8b e0       	ldi	r24, 0x0B	; 11
    109e:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    10a0:	ee e4       	ldi	r30, 0x4E	; 78
    10a2:	f0 e0       	ldi	r31, 0x00	; 0
    10a4:	89 81       	ldd	r24, Y+1	; 0x01
    10a6:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    10a8:	e9 e5       	ldi	r30, 0x59	; 89
    10aa:	f0 e0       	ldi	r31, 0x00	; 0
    10ac:	80 81       	ld	r24, Z
    10ae:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    10b0:	89 81       	ldd	r24, Y+1	; 0x01
    10b2:	80 61       	ori	r24, 0x10	; 16
    10b4:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    10b6:	e9 e5       	ldi	r30, 0x59	; 89
    10b8:	f0 e0       	ldi	r31, 0x00	; 0
    10ba:	89 81       	ldd	r24, Y+1	; 0x01
    10bc:	80 83       	st	Z, r24
}
    10be:	26 96       	adiw	r28, 0x06	; 6
    10c0:	0f b6       	in	r0, 0x3f	; 63
    10c2:	f8 94       	cli
    10c4:	de bf       	out	0x3e, r29	; 62
    10c6:	0f be       	out	0x3f, r0	; 63
    10c8:	cd bf       	out	0x3d, r28	; 61
    10ca:	cf 91       	pop	r28
    10cc:	df 91       	pop	r29
    10ce:	08 95       	ret

000010d0 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    10d0:	0e 94 b1 07 	call	0xf62	; 0xf62 <vPortYieldFromTick>
		asm volatile ( "reti" );
    10d4:	18 95       	reti

000010d6 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    10d6:	df 93       	push	r29
    10d8:	cf 93       	push	r28
    10da:	cd b7       	in	r28, 0x3d	; 61
    10dc:	de b7       	in	r29, 0x3e	; 62
    10de:	28 97       	sbiw	r28, 0x08	; 8
    10e0:	0f b6       	in	r0, 0x3f	; 63
    10e2:	f8 94       	cli
    10e4:	de bf       	out	0x3e, r29	; 62
    10e6:	0f be       	out	0x3f, r0	; 63
    10e8:	cd bf       	out	0x3d, r28	; 61
    10ea:	8f 83       	std	Y+7, r24	; 0x07
    10ec:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    10ee:	1a 82       	std	Y+2, r1	; 0x02
    10f0:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    10f2:	8f 81       	ldd	r24, Y+7	; 0x07
    10f4:	88 23       	and	r24, r24
    10f6:	09 f4       	brne	.+2      	; 0x10fa <xQueueCreate+0x24>
    10f8:	8c c0       	rjmp	.+280    	; 0x1212 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    10fa:	8f e1       	ldi	r24, 0x1F	; 31
    10fc:	90 e0       	ldi	r25, 0x00	; 0
    10fe:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <pvPortMalloc>
    1102:	9e 83       	std	Y+6, r25	; 0x06
    1104:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1106:	8d 81       	ldd	r24, Y+5	; 0x05
    1108:	9e 81       	ldd	r25, Y+6	; 0x06
    110a:	00 97       	sbiw	r24, 0x00	; 0
    110c:	09 f4       	brne	.+2      	; 0x1110 <xQueueCreate+0x3a>
    110e:	81 c0       	rjmp	.+258    	; 0x1212 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1110:	8f 81       	ldd	r24, Y+7	; 0x07
    1112:	28 2f       	mov	r18, r24
    1114:	30 e0       	ldi	r19, 0x00	; 0
    1116:	88 85       	ldd	r24, Y+8	; 0x08
    1118:	88 2f       	mov	r24, r24
    111a:	90 e0       	ldi	r25, 0x00	; 0
    111c:	ac 01       	movw	r20, r24
    111e:	24 9f       	mul	r18, r20
    1120:	c0 01       	movw	r24, r0
    1122:	25 9f       	mul	r18, r21
    1124:	90 0d       	add	r25, r0
    1126:	34 9f       	mul	r19, r20
    1128:	90 0d       	add	r25, r0
    112a:	11 24       	eor	r1, r1
    112c:	01 96       	adiw	r24, 0x01	; 1
    112e:	9c 83       	std	Y+4, r25	; 0x04
    1130:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1132:	8b 81       	ldd	r24, Y+3	; 0x03
    1134:	9c 81       	ldd	r25, Y+4	; 0x04
    1136:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <pvPortMalloc>
    113a:	ed 81       	ldd	r30, Y+5	; 0x05
    113c:	fe 81       	ldd	r31, Y+6	; 0x06
    113e:	91 83       	std	Z+1, r25	; 0x01
    1140:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    1142:	ed 81       	ldd	r30, Y+5	; 0x05
    1144:	fe 81       	ldd	r31, Y+6	; 0x06
    1146:	80 81       	ld	r24, Z
    1148:	91 81       	ldd	r25, Z+1	; 0x01
    114a:	00 97       	sbiw	r24, 0x00	; 0
    114c:	09 f4       	brne	.+2      	; 0x1150 <xQueueCreate+0x7a>
    114e:	5d c0       	rjmp	.+186    	; 0x120a <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1150:	ed 81       	ldd	r30, Y+5	; 0x05
    1152:	fe 81       	ldd	r31, Y+6	; 0x06
    1154:	40 81       	ld	r20, Z
    1156:	51 81       	ldd	r21, Z+1	; 0x01
    1158:	8f 81       	ldd	r24, Y+7	; 0x07
    115a:	28 2f       	mov	r18, r24
    115c:	30 e0       	ldi	r19, 0x00	; 0
    115e:	88 85       	ldd	r24, Y+8	; 0x08
    1160:	88 2f       	mov	r24, r24
    1162:	90 e0       	ldi	r25, 0x00	; 0
    1164:	bc 01       	movw	r22, r24
    1166:	26 9f       	mul	r18, r22
    1168:	c0 01       	movw	r24, r0
    116a:	27 9f       	mul	r18, r23
    116c:	90 0d       	add	r25, r0
    116e:	36 9f       	mul	r19, r22
    1170:	90 0d       	add	r25, r0
    1172:	11 24       	eor	r1, r1
    1174:	84 0f       	add	r24, r20
    1176:	95 1f       	adc	r25, r21
    1178:	ed 81       	ldd	r30, Y+5	; 0x05
    117a:	fe 81       	ldd	r31, Y+6	; 0x06
    117c:	93 83       	std	Z+3, r25	; 0x03
    117e:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1180:	ed 81       	ldd	r30, Y+5	; 0x05
    1182:	fe 81       	ldd	r31, Y+6	; 0x06
    1184:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1186:	ed 81       	ldd	r30, Y+5	; 0x05
    1188:	fe 81       	ldd	r31, Y+6	; 0x06
    118a:	80 81       	ld	r24, Z
    118c:	91 81       	ldd	r25, Z+1	; 0x01
    118e:	ed 81       	ldd	r30, Y+5	; 0x05
    1190:	fe 81       	ldd	r31, Y+6	; 0x06
    1192:	95 83       	std	Z+5, r25	; 0x05
    1194:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    1196:	ed 81       	ldd	r30, Y+5	; 0x05
    1198:	fe 81       	ldd	r31, Y+6	; 0x06
    119a:	40 81       	ld	r20, Z
    119c:	51 81       	ldd	r21, Z+1	; 0x01
    119e:	8f 81       	ldd	r24, Y+7	; 0x07
    11a0:	88 2f       	mov	r24, r24
    11a2:	90 e0       	ldi	r25, 0x00	; 0
    11a4:	9c 01       	movw	r18, r24
    11a6:	21 50       	subi	r18, 0x01	; 1
    11a8:	30 40       	sbci	r19, 0x00	; 0
    11aa:	88 85       	ldd	r24, Y+8	; 0x08
    11ac:	88 2f       	mov	r24, r24
    11ae:	90 e0       	ldi	r25, 0x00	; 0
    11b0:	bc 01       	movw	r22, r24
    11b2:	26 9f       	mul	r18, r22
    11b4:	c0 01       	movw	r24, r0
    11b6:	27 9f       	mul	r18, r23
    11b8:	90 0d       	add	r25, r0
    11ba:	36 9f       	mul	r19, r22
    11bc:	90 0d       	add	r25, r0
    11be:	11 24       	eor	r1, r1
    11c0:	84 0f       	add	r24, r20
    11c2:	95 1f       	adc	r25, r21
    11c4:	ed 81       	ldd	r30, Y+5	; 0x05
    11c6:	fe 81       	ldd	r31, Y+6	; 0x06
    11c8:	97 83       	std	Z+7, r25	; 0x07
    11ca:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    11cc:	ed 81       	ldd	r30, Y+5	; 0x05
    11ce:	fe 81       	ldd	r31, Y+6	; 0x06
    11d0:	8f 81       	ldd	r24, Y+7	; 0x07
    11d2:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    11d4:	ed 81       	ldd	r30, Y+5	; 0x05
    11d6:	fe 81       	ldd	r31, Y+6	; 0x06
    11d8:	88 85       	ldd	r24, Y+8	; 0x08
    11da:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    11dc:	ed 81       	ldd	r30, Y+5	; 0x05
    11de:	fe 81       	ldd	r31, Y+6	; 0x06
    11e0:	8f ef       	ldi	r24, 0xFF	; 255
    11e2:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    11e4:	ed 81       	ldd	r30, Y+5	; 0x05
    11e6:	fe 81       	ldd	r31, Y+6	; 0x06
    11e8:	8f ef       	ldi	r24, 0xFF	; 255
    11ea:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    11ec:	8d 81       	ldd	r24, Y+5	; 0x05
    11ee:	9e 81       	ldd	r25, Y+6	; 0x06
    11f0:	08 96       	adiw	r24, 0x08	; 8
    11f2:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    11f6:	8d 81       	ldd	r24, Y+5	; 0x05
    11f8:	9e 81       	ldd	r25, Y+6	; 0x06
    11fa:	41 96       	adiw	r24, 0x11	; 17
    11fc:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1200:	8d 81       	ldd	r24, Y+5	; 0x05
    1202:	9e 81       	ldd	r25, Y+6	; 0x06
    1204:	9a 83       	std	Y+2, r25	; 0x02
    1206:	89 83       	std	Y+1, r24	; 0x01
    1208:	04 c0       	rjmp	.+8      	; 0x1212 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    120a:	8d 81       	ldd	r24, Y+5	; 0x05
    120c:	9e 81       	ldd	r25, Y+6	; 0x06
    120e:	0e 94 38 04 	call	0x870	; 0x870 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1212:	89 81       	ldd	r24, Y+1	; 0x01
    1214:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1216:	28 96       	adiw	r28, 0x08	; 8
    1218:	0f b6       	in	r0, 0x3f	; 63
    121a:	f8 94       	cli
    121c:	de bf       	out	0x3e, r29	; 62
    121e:	0f be       	out	0x3f, r0	; 63
    1220:	cd bf       	out	0x3d, r28	; 61
    1222:	cf 91       	pop	r28
    1224:	df 91       	pop	r29
    1226:	08 95       	ret

00001228 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1228:	df 93       	push	r29
    122a:	cf 93       	push	r28
    122c:	cd b7       	in	r28, 0x3d	; 61
    122e:	de b7       	in	r29, 0x3e	; 62
    1230:	2c 97       	sbiw	r28, 0x0c	; 12
    1232:	0f b6       	in	r0, 0x3f	; 63
    1234:	f8 94       	cli
    1236:	de bf       	out	0x3e, r29	; 62
    1238:	0f be       	out	0x3f, r0	; 63
    123a:	cd bf       	out	0x3d, r28	; 61
    123c:	9e 83       	std	Y+6, r25	; 0x06
    123e:	8d 83       	std	Y+5, r24	; 0x05
    1240:	78 87       	std	Y+8, r23	; 0x08
    1242:	6f 83       	std	Y+7, r22	; 0x07
    1244:	5a 87       	std	Y+10, r21	; 0x0a
    1246:	49 87       	std	Y+9, r20	; 0x09
    1248:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    124a:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    124c:	0f b6       	in	r0, 0x3f	; 63
    124e:	f8 94       	cli
    1250:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1252:	ed 81       	ldd	r30, Y+5	; 0x05
    1254:	fe 81       	ldd	r31, Y+6	; 0x06
    1256:	92 8d       	ldd	r25, Z+26	; 0x1a
    1258:	ed 81       	ldd	r30, Y+5	; 0x05
    125a:	fe 81       	ldd	r31, Y+6	; 0x06
    125c:	83 8d       	ldd	r24, Z+27	; 0x1b
    125e:	98 17       	cp	r25, r24
    1260:	d8 f4       	brcc	.+54     	; 0x1298 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1262:	8d 81       	ldd	r24, Y+5	; 0x05
    1264:	9e 81       	ldd	r25, Y+6	; 0x06
    1266:	2f 81       	ldd	r18, Y+7	; 0x07
    1268:	38 85       	ldd	r19, Y+8	; 0x08
    126a:	b9 01       	movw	r22, r18
    126c:	4b 85       	ldd	r20, Y+11	; 0x0b
    126e:	0e 94 4f 0b 	call	0x169e	; 0x169e <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1272:	ed 81       	ldd	r30, Y+5	; 0x05
    1274:	fe 81       	ldd	r31, Y+6	; 0x06
    1276:	81 89       	ldd	r24, Z+17	; 0x11
    1278:	88 23       	and	r24, r24
    127a:	49 f0       	breq	.+18     	; 0x128e <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    127c:	8d 81       	ldd	r24, Y+5	; 0x05
    127e:	9e 81       	ldd	r25, Y+6	; 0x06
    1280:	41 96       	adiw	r24, 0x11	; 17
    1282:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xTaskRemoveFromEventList>
    1286:	81 30       	cpi	r24, 0x01	; 1
    1288:	11 f4       	brne	.+4      	; 0x128e <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    128a:	0e 94 58 07 	call	0xeb0	; 0xeb0 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    128e:	0f 90       	pop	r0
    1290:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1292:	81 e0       	ldi	r24, 0x01	; 1
    1294:	8c 87       	std	Y+12, r24	; 0x0c
    1296:	5c c0       	rjmp	.+184    	; 0x1350 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1298:	89 85       	ldd	r24, Y+9	; 0x09
    129a:	9a 85       	ldd	r25, Y+10	; 0x0a
    129c:	00 97       	sbiw	r24, 0x00	; 0
    129e:	21 f4       	brne	.+8      	; 0x12a8 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    12a0:	0f 90       	pop	r0
    12a2:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    12a4:	1c 86       	std	Y+12, r1	; 0x0c
    12a6:	54 c0       	rjmp	.+168    	; 0x1350 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    12a8:	89 81       	ldd	r24, Y+1	; 0x01
    12aa:	88 23       	and	r24, r24
    12ac:	31 f4       	brne	.+12     	; 0x12ba <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    12ae:	ce 01       	movw	r24, r28
    12b0:	02 96       	adiw	r24, 0x02	; 2
    12b2:	0e 94 cc 11 	call	0x2398	; 0x2398 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    12b6:	81 e0       	ldi	r24, 0x01	; 1
    12b8:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    12ba:	0f 90       	pop	r0
    12bc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    12be:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    12c2:	0f b6       	in	r0, 0x3f	; 63
    12c4:	f8 94       	cli
    12c6:	0f 92       	push	r0
    12c8:	ed 81       	ldd	r30, Y+5	; 0x05
    12ca:	fe 81       	ldd	r31, Y+6	; 0x06
    12cc:	85 8d       	ldd	r24, Z+29	; 0x1d
    12ce:	8f 3f       	cpi	r24, 0xFF	; 255
    12d0:	19 f4       	brne	.+6      	; 0x12d8 <xQueueGenericSend+0xb0>
    12d2:	ed 81       	ldd	r30, Y+5	; 0x05
    12d4:	fe 81       	ldd	r31, Y+6	; 0x06
    12d6:	15 8e       	std	Z+29, r1	; 0x1d
    12d8:	ed 81       	ldd	r30, Y+5	; 0x05
    12da:	fe 81       	ldd	r31, Y+6	; 0x06
    12dc:	86 8d       	ldd	r24, Z+30	; 0x1e
    12de:	8f 3f       	cpi	r24, 0xFF	; 255
    12e0:	19 f4       	brne	.+6      	; 0x12e8 <xQueueGenericSend+0xc0>
    12e2:	ed 81       	ldd	r30, Y+5	; 0x05
    12e4:	fe 81       	ldd	r31, Y+6	; 0x06
    12e6:	16 8e       	std	Z+30, r1	; 0x1e
    12e8:	0f 90       	pop	r0
    12ea:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    12ec:	ce 01       	movw	r24, r28
    12ee:	02 96       	adiw	r24, 0x02	; 2
    12f0:	9e 01       	movw	r18, r28
    12f2:	27 5f       	subi	r18, 0xF7	; 247
    12f4:	3f 4f       	sbci	r19, 0xFF	; 255
    12f6:	b9 01       	movw	r22, r18
    12f8:	0e 94 e5 11 	call	0x23ca	; 0x23ca <xTaskCheckForTimeOut>
    12fc:	88 23       	and	r24, r24
    12fe:	09 f5       	brne	.+66     	; 0x1342 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1300:	8d 81       	ldd	r24, Y+5	; 0x05
    1302:	9e 81       	ldd	r25, Y+6	; 0x06
    1304:	0e 94 b3 0c 	call	0x1966	; 0x1966 <prvIsQueueFull>
    1308:	88 23       	and	r24, r24
    130a:	a1 f0       	breq	.+40     	; 0x1334 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    130c:	8d 81       	ldd	r24, Y+5	; 0x05
    130e:	9e 81       	ldd	r25, Y+6	; 0x06
    1310:	08 96       	adiw	r24, 0x08	; 8
    1312:	29 85       	ldd	r18, Y+9	; 0x09
    1314:	3a 85       	ldd	r19, Y+10	; 0x0a
    1316:	b9 01       	movw	r22, r18
    1318:	0e 94 2e 11 	call	0x225c	; 0x225c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    131c:	8d 81       	ldd	r24, Y+5	; 0x05
    131e:	9e 81       	ldd	r25, Y+6	; 0x06
    1320:	0e 94 2c 0c 	call	0x1858	; 0x1858 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1324:	0e 94 34 0f 	call	0x1e68	; 0x1e68 <xTaskResumeAll>
    1328:	88 23       	and	r24, r24
    132a:	09 f0       	breq	.+2      	; 0x132e <xQueueGenericSend+0x106>
    132c:	8f cf       	rjmp	.-226    	; 0x124c <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    132e:	0e 94 58 07 	call	0xeb0	; 0xeb0 <vPortYield>
    1332:	8c cf       	rjmp	.-232    	; 0x124c <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1334:	8d 81       	ldd	r24, Y+5	; 0x05
    1336:	9e 81       	ldd	r25, Y+6	; 0x06
    1338:	0e 94 2c 0c 	call	0x1858	; 0x1858 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    133c:	0e 94 34 0f 	call	0x1e68	; 0x1e68 <xTaskResumeAll>
    1340:	85 cf       	rjmp	.-246    	; 0x124c <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1342:	8d 81       	ldd	r24, Y+5	; 0x05
    1344:	9e 81       	ldd	r25, Y+6	; 0x06
    1346:	0e 94 2c 0c 	call	0x1858	; 0x1858 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    134a:	0e 94 34 0f 	call	0x1e68	; 0x1e68 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    134e:	1c 86       	std	Y+12, r1	; 0x0c
    1350:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    1352:	2c 96       	adiw	r28, 0x0c	; 12
    1354:	0f b6       	in	r0, 0x3f	; 63
    1356:	f8 94       	cli
    1358:	de bf       	out	0x3e, r29	; 62
    135a:	0f be       	out	0x3f, r0	; 63
    135c:	cd bf       	out	0x3d, r28	; 61
    135e:	cf 91       	pop	r28
    1360:	df 91       	pop	r29
    1362:	08 95       	ret

00001364 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1364:	df 93       	push	r29
    1366:	cf 93       	push	r28
    1368:	cd b7       	in	r28, 0x3d	; 61
    136a:	de b7       	in	r29, 0x3e	; 62
    136c:	29 97       	sbiw	r28, 0x09	; 9
    136e:	0f b6       	in	r0, 0x3f	; 63
    1370:	f8 94       	cli
    1372:	de bf       	out	0x3e, r29	; 62
    1374:	0f be       	out	0x3f, r0	; 63
    1376:	cd bf       	out	0x3d, r28	; 61
    1378:	9c 83       	std	Y+4, r25	; 0x04
    137a:	8b 83       	std	Y+3, r24	; 0x03
    137c:	7e 83       	std	Y+6, r23	; 0x06
    137e:	6d 83       	std	Y+5, r22	; 0x05
    1380:	58 87       	std	Y+8, r21	; 0x08
    1382:	4f 83       	std	Y+7, r20	; 0x07
    1384:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1386:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1388:	eb 81       	ldd	r30, Y+3	; 0x03
    138a:	fc 81       	ldd	r31, Y+4	; 0x04
    138c:	92 8d       	ldd	r25, Z+26	; 0x1a
    138e:	eb 81       	ldd	r30, Y+3	; 0x03
    1390:	fc 81       	ldd	r31, Y+4	; 0x04
    1392:	83 8d       	ldd	r24, Z+27	; 0x1b
    1394:	98 17       	cp	r25, r24
    1396:	40 f5       	brcc	.+80     	; 0x13e8 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1398:	8b 81       	ldd	r24, Y+3	; 0x03
    139a:	9c 81       	ldd	r25, Y+4	; 0x04
    139c:	2d 81       	ldd	r18, Y+5	; 0x05
    139e:	3e 81       	ldd	r19, Y+6	; 0x06
    13a0:	b9 01       	movw	r22, r18
    13a2:	49 85       	ldd	r20, Y+9	; 0x09
    13a4:	0e 94 4f 0b 	call	0x169e	; 0x169e <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    13a8:	eb 81       	ldd	r30, Y+3	; 0x03
    13aa:	fc 81       	ldd	r31, Y+4	; 0x04
    13ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    13ae:	8f 3f       	cpi	r24, 0xFF	; 255
    13b0:	89 f4       	brne	.+34     	; 0x13d4 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13b2:	eb 81       	ldd	r30, Y+3	; 0x03
    13b4:	fc 81       	ldd	r31, Y+4	; 0x04
    13b6:	81 89       	ldd	r24, Z+17	; 0x11
    13b8:	88 23       	and	r24, r24
    13ba:	99 f0       	breq	.+38     	; 0x13e2 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13bc:	8b 81       	ldd	r24, Y+3	; 0x03
    13be:	9c 81       	ldd	r25, Y+4	; 0x04
    13c0:	41 96       	adiw	r24, 0x11	; 17
    13c2:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xTaskRemoveFromEventList>
    13c6:	88 23       	and	r24, r24
    13c8:	61 f0       	breq	.+24     	; 0x13e2 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    13ca:	ef 81       	ldd	r30, Y+7	; 0x07
    13cc:	f8 85       	ldd	r31, Y+8	; 0x08
    13ce:	81 e0       	ldi	r24, 0x01	; 1
    13d0:	80 83       	st	Z, r24
    13d2:	07 c0       	rjmp	.+14     	; 0x13e2 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    13d4:	eb 81       	ldd	r30, Y+3	; 0x03
    13d6:	fc 81       	ldd	r31, Y+4	; 0x04
    13d8:	86 8d       	ldd	r24, Z+30	; 0x1e
    13da:	8f 5f       	subi	r24, 0xFF	; 255
    13dc:	eb 81       	ldd	r30, Y+3	; 0x03
    13de:	fc 81       	ldd	r31, Y+4	; 0x04
    13e0:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    13e2:	81 e0       	ldi	r24, 0x01	; 1
    13e4:	8a 83       	std	Y+2, r24	; 0x02
    13e6:	01 c0       	rjmp	.+2      	; 0x13ea <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    13e8:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    13ea:	8a 81       	ldd	r24, Y+2	; 0x02
}
    13ec:	29 96       	adiw	r28, 0x09	; 9
    13ee:	0f b6       	in	r0, 0x3f	; 63
    13f0:	f8 94       	cli
    13f2:	de bf       	out	0x3e, r29	; 62
    13f4:	0f be       	out	0x3f, r0	; 63
    13f6:	cd bf       	out	0x3d, r28	; 61
    13f8:	cf 91       	pop	r28
    13fa:	df 91       	pop	r29
    13fc:	08 95       	ret

000013fe <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    13fe:	df 93       	push	r29
    1400:	cf 93       	push	r28
    1402:	cd b7       	in	r28, 0x3d	; 61
    1404:	de b7       	in	r29, 0x3e	; 62
    1406:	2e 97       	sbiw	r28, 0x0e	; 14
    1408:	0f b6       	in	r0, 0x3f	; 63
    140a:	f8 94       	cli
    140c:	de bf       	out	0x3e, r29	; 62
    140e:	0f be       	out	0x3f, r0	; 63
    1410:	cd bf       	out	0x3d, r28	; 61
    1412:	98 87       	std	Y+8, r25	; 0x08
    1414:	8f 83       	std	Y+7, r24	; 0x07
    1416:	7a 87       	std	Y+10, r23	; 0x0a
    1418:	69 87       	std	Y+9, r22	; 0x09
    141a:	5c 87       	std	Y+12, r21	; 0x0c
    141c:	4b 87       	std	Y+11, r20	; 0x0b
    141e:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1420:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1422:	0f b6       	in	r0, 0x3f	; 63
    1424:	f8 94       	cli
    1426:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1428:	ef 81       	ldd	r30, Y+7	; 0x07
    142a:	f8 85       	ldd	r31, Y+8	; 0x08
    142c:	82 8d       	ldd	r24, Z+26	; 0x1a
    142e:	88 23       	and	r24, r24
    1430:	09 f4       	brne	.+2      	; 0x1434 <xQueueGenericReceive+0x36>
    1432:	3f c0       	rjmp	.+126    	; 0x14b2 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1434:	ef 81       	ldd	r30, Y+7	; 0x07
    1436:	f8 85       	ldd	r31, Y+8	; 0x08
    1438:	86 81       	ldd	r24, Z+6	; 0x06
    143a:	97 81       	ldd	r25, Z+7	; 0x07
    143c:	9a 83       	std	Y+2, r25	; 0x02
    143e:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1440:	8f 81       	ldd	r24, Y+7	; 0x07
    1442:	98 85       	ldd	r25, Y+8	; 0x08
    1444:	29 85       	ldd	r18, Y+9	; 0x09
    1446:	3a 85       	ldd	r19, Y+10	; 0x0a
    1448:	b9 01       	movw	r22, r18
    144a:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    144e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1450:	88 23       	and	r24, r24
    1452:	b1 f4       	brne	.+44     	; 0x1480 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1454:	ef 81       	ldd	r30, Y+7	; 0x07
    1456:	f8 85       	ldd	r31, Y+8	; 0x08
    1458:	82 8d       	ldd	r24, Z+26	; 0x1a
    145a:	81 50       	subi	r24, 0x01	; 1
    145c:	ef 81       	ldd	r30, Y+7	; 0x07
    145e:	f8 85       	ldd	r31, Y+8	; 0x08
    1460:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1462:	ef 81       	ldd	r30, Y+7	; 0x07
    1464:	f8 85       	ldd	r31, Y+8	; 0x08
    1466:	80 85       	ldd	r24, Z+8	; 0x08
    1468:	88 23       	and	r24, r24
    146a:	f1 f0       	breq	.+60     	; 0x14a8 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    146c:	8f 81       	ldd	r24, Y+7	; 0x07
    146e:	98 85       	ldd	r25, Y+8	; 0x08
    1470:	08 96       	adiw	r24, 0x08	; 8
    1472:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xTaskRemoveFromEventList>
    1476:	81 30       	cpi	r24, 0x01	; 1
    1478:	b9 f4       	brne	.+46     	; 0x14a8 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    147a:	0e 94 58 07 	call	0xeb0	; 0xeb0 <vPortYield>
    147e:	14 c0       	rjmp	.+40     	; 0x14a8 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1480:	ef 81       	ldd	r30, Y+7	; 0x07
    1482:	f8 85       	ldd	r31, Y+8	; 0x08
    1484:	89 81       	ldd	r24, Y+1	; 0x01
    1486:	9a 81       	ldd	r25, Y+2	; 0x02
    1488:	97 83       	std	Z+7, r25	; 0x07
    148a:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    148c:	ef 81       	ldd	r30, Y+7	; 0x07
    148e:	f8 85       	ldd	r31, Y+8	; 0x08
    1490:	81 89       	ldd	r24, Z+17	; 0x11
    1492:	88 23       	and	r24, r24
    1494:	49 f0       	breq	.+18     	; 0x14a8 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1496:	8f 81       	ldd	r24, Y+7	; 0x07
    1498:	98 85       	ldd	r25, Y+8	; 0x08
    149a:	41 96       	adiw	r24, 0x11	; 17
    149c:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xTaskRemoveFromEventList>
    14a0:	88 23       	and	r24, r24
    14a2:	11 f0       	breq	.+4      	; 0x14a8 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    14a4:	0e 94 58 07 	call	0xeb0	; 0xeb0 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    14a8:	0f 90       	pop	r0
    14aa:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    14ac:	81 e0       	ldi	r24, 0x01	; 1
    14ae:	8e 87       	std	Y+14, r24	; 0x0e
    14b0:	5c c0       	rjmp	.+184    	; 0x156a <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    14b2:	8b 85       	ldd	r24, Y+11	; 0x0b
    14b4:	9c 85       	ldd	r25, Y+12	; 0x0c
    14b6:	00 97       	sbiw	r24, 0x00	; 0
    14b8:	21 f4       	brne	.+8      	; 0x14c2 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    14ba:	0f 90       	pop	r0
    14bc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    14be:	1e 86       	std	Y+14, r1	; 0x0e
    14c0:	54 c0       	rjmp	.+168    	; 0x156a <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    14c2:	8b 81       	ldd	r24, Y+3	; 0x03
    14c4:	88 23       	and	r24, r24
    14c6:	31 f4       	brne	.+12     	; 0x14d4 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    14c8:	ce 01       	movw	r24, r28
    14ca:	04 96       	adiw	r24, 0x04	; 4
    14cc:	0e 94 cc 11 	call	0x2398	; 0x2398 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    14d0:	81 e0       	ldi	r24, 0x01	; 1
    14d2:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    14d4:	0f 90       	pop	r0
    14d6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    14d8:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    14dc:	0f b6       	in	r0, 0x3f	; 63
    14de:	f8 94       	cli
    14e0:	0f 92       	push	r0
    14e2:	ef 81       	ldd	r30, Y+7	; 0x07
    14e4:	f8 85       	ldd	r31, Y+8	; 0x08
    14e6:	85 8d       	ldd	r24, Z+29	; 0x1d
    14e8:	8f 3f       	cpi	r24, 0xFF	; 255
    14ea:	19 f4       	brne	.+6      	; 0x14f2 <xQueueGenericReceive+0xf4>
    14ec:	ef 81       	ldd	r30, Y+7	; 0x07
    14ee:	f8 85       	ldd	r31, Y+8	; 0x08
    14f0:	15 8e       	std	Z+29, r1	; 0x1d
    14f2:	ef 81       	ldd	r30, Y+7	; 0x07
    14f4:	f8 85       	ldd	r31, Y+8	; 0x08
    14f6:	86 8d       	ldd	r24, Z+30	; 0x1e
    14f8:	8f 3f       	cpi	r24, 0xFF	; 255
    14fa:	19 f4       	brne	.+6      	; 0x1502 <xQueueGenericReceive+0x104>
    14fc:	ef 81       	ldd	r30, Y+7	; 0x07
    14fe:	f8 85       	ldd	r31, Y+8	; 0x08
    1500:	16 8e       	std	Z+30, r1	; 0x1e
    1502:	0f 90       	pop	r0
    1504:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1506:	ce 01       	movw	r24, r28
    1508:	04 96       	adiw	r24, 0x04	; 4
    150a:	9e 01       	movw	r18, r28
    150c:	25 5f       	subi	r18, 0xF5	; 245
    150e:	3f 4f       	sbci	r19, 0xFF	; 255
    1510:	b9 01       	movw	r22, r18
    1512:	0e 94 e5 11 	call	0x23ca	; 0x23ca <xTaskCheckForTimeOut>
    1516:	88 23       	and	r24, r24
    1518:	09 f5       	brne	.+66     	; 0x155c <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    151a:	8f 81       	ldd	r24, Y+7	; 0x07
    151c:	98 85       	ldd	r25, Y+8	; 0x08
    151e:	0e 94 80 0c 	call	0x1900	; 0x1900 <prvIsQueueEmpty>
    1522:	88 23       	and	r24, r24
    1524:	a1 f0       	breq	.+40     	; 0x154e <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1526:	8f 81       	ldd	r24, Y+7	; 0x07
    1528:	98 85       	ldd	r25, Y+8	; 0x08
    152a:	41 96       	adiw	r24, 0x11	; 17
    152c:	2b 85       	ldd	r18, Y+11	; 0x0b
    152e:	3c 85       	ldd	r19, Y+12	; 0x0c
    1530:	b9 01       	movw	r22, r18
    1532:	0e 94 2e 11 	call	0x225c	; 0x225c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1536:	8f 81       	ldd	r24, Y+7	; 0x07
    1538:	98 85       	ldd	r25, Y+8	; 0x08
    153a:	0e 94 2c 0c 	call	0x1858	; 0x1858 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    153e:	0e 94 34 0f 	call	0x1e68	; 0x1e68 <xTaskResumeAll>
    1542:	88 23       	and	r24, r24
    1544:	09 f0       	breq	.+2      	; 0x1548 <xQueueGenericReceive+0x14a>
    1546:	6d cf       	rjmp	.-294    	; 0x1422 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1548:	0e 94 58 07 	call	0xeb0	; 0xeb0 <vPortYield>
    154c:	6a cf       	rjmp	.-300    	; 0x1422 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    154e:	8f 81       	ldd	r24, Y+7	; 0x07
    1550:	98 85       	ldd	r25, Y+8	; 0x08
    1552:	0e 94 2c 0c 	call	0x1858	; 0x1858 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1556:	0e 94 34 0f 	call	0x1e68	; 0x1e68 <xTaskResumeAll>
    155a:	63 cf       	rjmp	.-314    	; 0x1422 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    155c:	8f 81       	ldd	r24, Y+7	; 0x07
    155e:	98 85       	ldd	r25, Y+8	; 0x08
    1560:	0e 94 2c 0c 	call	0x1858	; 0x1858 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1564:	0e 94 34 0f 	call	0x1e68	; 0x1e68 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1568:	1e 86       	std	Y+14, r1	; 0x0e
    156a:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    156c:	2e 96       	adiw	r28, 0x0e	; 14
    156e:	0f b6       	in	r0, 0x3f	; 63
    1570:	f8 94       	cli
    1572:	de bf       	out	0x3e, r29	; 62
    1574:	0f be       	out	0x3f, r0	; 63
    1576:	cd bf       	out	0x3d, r28	; 61
    1578:	cf 91       	pop	r28
    157a:	df 91       	pop	r29
    157c:	08 95       	ret

0000157e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    157e:	df 93       	push	r29
    1580:	cf 93       	push	r28
    1582:	cd b7       	in	r28, 0x3d	; 61
    1584:	de b7       	in	r29, 0x3e	; 62
    1586:	28 97       	sbiw	r28, 0x08	; 8
    1588:	0f b6       	in	r0, 0x3f	; 63
    158a:	f8 94       	cli
    158c:	de bf       	out	0x3e, r29	; 62
    158e:	0f be       	out	0x3f, r0	; 63
    1590:	cd bf       	out	0x3d, r28	; 61
    1592:	9c 83       	std	Y+4, r25	; 0x04
    1594:	8b 83       	std	Y+3, r24	; 0x03
    1596:	7e 83       	std	Y+6, r23	; 0x06
    1598:	6d 83       	std	Y+5, r22	; 0x05
    159a:	58 87       	std	Y+8, r21	; 0x08
    159c:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    159e:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    15a0:	eb 81       	ldd	r30, Y+3	; 0x03
    15a2:	fc 81       	ldd	r31, Y+4	; 0x04
    15a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    15a6:	88 23       	and	r24, r24
    15a8:	71 f1       	breq	.+92     	; 0x1606 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    15aa:	8b 81       	ldd	r24, Y+3	; 0x03
    15ac:	9c 81       	ldd	r25, Y+4	; 0x04
    15ae:	2d 81       	ldd	r18, Y+5	; 0x05
    15b0:	3e 81       	ldd	r19, Y+6	; 0x06
    15b2:	b9 01       	movw	r22, r18
    15b4:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    15b8:	eb 81       	ldd	r30, Y+3	; 0x03
    15ba:	fc 81       	ldd	r31, Y+4	; 0x04
    15bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    15be:	81 50       	subi	r24, 0x01	; 1
    15c0:	eb 81       	ldd	r30, Y+3	; 0x03
    15c2:	fc 81       	ldd	r31, Y+4	; 0x04
    15c4:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    15c6:	eb 81       	ldd	r30, Y+3	; 0x03
    15c8:	fc 81       	ldd	r31, Y+4	; 0x04
    15ca:	85 8d       	ldd	r24, Z+29	; 0x1d
    15cc:	8f 3f       	cpi	r24, 0xFF	; 255
    15ce:	89 f4       	brne	.+34     	; 0x15f2 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    15d0:	eb 81       	ldd	r30, Y+3	; 0x03
    15d2:	fc 81       	ldd	r31, Y+4	; 0x04
    15d4:	80 85       	ldd	r24, Z+8	; 0x08
    15d6:	88 23       	and	r24, r24
    15d8:	99 f0       	breq	.+38     	; 0x1600 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    15da:	8b 81       	ldd	r24, Y+3	; 0x03
    15dc:	9c 81       	ldd	r25, Y+4	; 0x04
    15de:	08 96       	adiw	r24, 0x08	; 8
    15e0:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xTaskRemoveFromEventList>
    15e4:	88 23       	and	r24, r24
    15e6:	61 f0       	breq	.+24     	; 0x1600 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    15e8:	ef 81       	ldd	r30, Y+7	; 0x07
    15ea:	f8 85       	ldd	r31, Y+8	; 0x08
    15ec:	81 e0       	ldi	r24, 0x01	; 1
    15ee:	80 83       	st	Z, r24
    15f0:	07 c0       	rjmp	.+14     	; 0x1600 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    15f2:	eb 81       	ldd	r30, Y+3	; 0x03
    15f4:	fc 81       	ldd	r31, Y+4	; 0x04
    15f6:	85 8d       	ldd	r24, Z+29	; 0x1d
    15f8:	8f 5f       	subi	r24, 0xFF	; 255
    15fa:	eb 81       	ldd	r30, Y+3	; 0x03
    15fc:	fc 81       	ldd	r31, Y+4	; 0x04
    15fe:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1600:	81 e0       	ldi	r24, 0x01	; 1
    1602:	8a 83       	std	Y+2, r24	; 0x02
    1604:	01 c0       	rjmp	.+2      	; 0x1608 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    1606:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1608:	8a 81       	ldd	r24, Y+2	; 0x02
}
    160a:	28 96       	adiw	r28, 0x08	; 8
    160c:	0f b6       	in	r0, 0x3f	; 63
    160e:	f8 94       	cli
    1610:	de bf       	out	0x3e, r29	; 62
    1612:	0f be       	out	0x3f, r0	; 63
    1614:	cd bf       	out	0x3d, r28	; 61
    1616:	cf 91       	pop	r28
    1618:	df 91       	pop	r29
    161a:	08 95       	ret

0000161c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    161c:	df 93       	push	r29
    161e:	cf 93       	push	r28
    1620:	00 d0       	rcall	.+0      	; 0x1622 <uxQueueMessagesWaiting+0x6>
    1622:	0f 92       	push	r0
    1624:	cd b7       	in	r28, 0x3d	; 61
    1626:	de b7       	in	r29, 0x3e	; 62
    1628:	9b 83       	std	Y+3, r25	; 0x03
    162a:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    162c:	0f b6       	in	r0, 0x3f	; 63
    162e:	f8 94       	cli
    1630:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1632:	ea 81       	ldd	r30, Y+2	; 0x02
    1634:	fb 81       	ldd	r31, Y+3	; 0x03
    1636:	82 8d       	ldd	r24, Z+26	; 0x1a
    1638:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    163a:	0f 90       	pop	r0
    163c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    163e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1640:	0f 90       	pop	r0
    1642:	0f 90       	pop	r0
    1644:	0f 90       	pop	r0
    1646:	cf 91       	pop	r28
    1648:	df 91       	pop	r29
    164a:	08 95       	ret

0000164c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    164c:	df 93       	push	r29
    164e:	cf 93       	push	r28
    1650:	00 d0       	rcall	.+0      	; 0x1652 <uxQueueMessagesWaitingFromISR+0x6>
    1652:	0f 92       	push	r0
    1654:	cd b7       	in	r28, 0x3d	; 61
    1656:	de b7       	in	r29, 0x3e	; 62
    1658:	9b 83       	std	Y+3, r25	; 0x03
    165a:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    165c:	ea 81       	ldd	r30, Y+2	; 0x02
    165e:	fb 81       	ldd	r31, Y+3	; 0x03
    1660:	82 8d       	ldd	r24, Z+26	; 0x1a
    1662:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1664:	89 81       	ldd	r24, Y+1	; 0x01
}
    1666:	0f 90       	pop	r0
    1668:	0f 90       	pop	r0
    166a:	0f 90       	pop	r0
    166c:	cf 91       	pop	r28
    166e:	df 91       	pop	r29
    1670:	08 95       	ret

00001672 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1672:	df 93       	push	r29
    1674:	cf 93       	push	r28
    1676:	00 d0       	rcall	.+0      	; 0x1678 <vQueueDelete+0x6>
    1678:	cd b7       	in	r28, 0x3d	; 61
    167a:	de b7       	in	r29, 0x3e	; 62
    167c:	9a 83       	std	Y+2, r25	; 0x02
    167e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1680:	e9 81       	ldd	r30, Y+1	; 0x01
    1682:	fa 81       	ldd	r31, Y+2	; 0x02
    1684:	80 81       	ld	r24, Z
    1686:	91 81       	ldd	r25, Z+1	; 0x01
    1688:	0e 94 38 04 	call	0x870	; 0x870 <vPortFree>
	vPortFree( pxQueue );
    168c:	89 81       	ldd	r24, Y+1	; 0x01
    168e:	9a 81       	ldd	r25, Y+2	; 0x02
    1690:	0e 94 38 04 	call	0x870	; 0x870 <vPortFree>
}
    1694:	0f 90       	pop	r0
    1696:	0f 90       	pop	r0
    1698:	cf 91       	pop	r28
    169a:	df 91       	pop	r29
    169c:	08 95       	ret

0000169e <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    169e:	df 93       	push	r29
    16a0:	cf 93       	push	r28
    16a2:	00 d0       	rcall	.+0      	; 0x16a4 <prvCopyDataToQueue+0x6>
    16a4:	00 d0       	rcall	.+0      	; 0x16a6 <prvCopyDataToQueue+0x8>
    16a6:	0f 92       	push	r0
    16a8:	cd b7       	in	r28, 0x3d	; 61
    16aa:	de b7       	in	r29, 0x3e	; 62
    16ac:	9a 83       	std	Y+2, r25	; 0x02
    16ae:	89 83       	std	Y+1, r24	; 0x01
    16b0:	7c 83       	std	Y+4, r23	; 0x04
    16b2:	6b 83       	std	Y+3, r22	; 0x03
    16b4:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    16b6:	e9 81       	ldd	r30, Y+1	; 0x01
    16b8:	fa 81       	ldd	r31, Y+2	; 0x02
    16ba:	84 8d       	ldd	r24, Z+28	; 0x1c
    16bc:	88 23       	and	r24, r24
    16be:	09 f4       	brne	.+2      	; 0x16c2 <prvCopyDataToQueue+0x24>
    16c0:	74 c0       	rjmp	.+232    	; 0x17aa <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    16c2:	8d 81       	ldd	r24, Y+5	; 0x05
    16c4:	88 23       	and	r24, r24
    16c6:	99 f5       	brne	.+102    	; 0x172e <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    16c8:	e9 81       	ldd	r30, Y+1	; 0x01
    16ca:	fa 81       	ldd	r31, Y+2	; 0x02
    16cc:	64 81       	ldd	r22, Z+4	; 0x04
    16ce:	75 81       	ldd	r23, Z+5	; 0x05
    16d0:	e9 81       	ldd	r30, Y+1	; 0x01
    16d2:	fa 81       	ldd	r31, Y+2	; 0x02
    16d4:	84 8d       	ldd	r24, Z+28	; 0x1c
    16d6:	48 2f       	mov	r20, r24
    16d8:	50 e0       	ldi	r21, 0x00	; 0
    16da:	2b 81       	ldd	r18, Y+3	; 0x03
    16dc:	3c 81       	ldd	r19, Y+4	; 0x04
    16de:	cb 01       	movw	r24, r22
    16e0:	b9 01       	movw	r22, r18
    16e2:	0e 94 d7 13 	call	0x27ae	; 0x27ae <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    16e6:	e9 81       	ldd	r30, Y+1	; 0x01
    16e8:	fa 81       	ldd	r31, Y+2	; 0x02
    16ea:	24 81       	ldd	r18, Z+4	; 0x04
    16ec:	35 81       	ldd	r19, Z+5	; 0x05
    16ee:	e9 81       	ldd	r30, Y+1	; 0x01
    16f0:	fa 81       	ldd	r31, Y+2	; 0x02
    16f2:	84 8d       	ldd	r24, Z+28	; 0x1c
    16f4:	88 2f       	mov	r24, r24
    16f6:	90 e0       	ldi	r25, 0x00	; 0
    16f8:	82 0f       	add	r24, r18
    16fa:	93 1f       	adc	r25, r19
    16fc:	e9 81       	ldd	r30, Y+1	; 0x01
    16fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1700:	95 83       	std	Z+5, r25	; 0x05
    1702:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1704:	e9 81       	ldd	r30, Y+1	; 0x01
    1706:	fa 81       	ldd	r31, Y+2	; 0x02
    1708:	24 81       	ldd	r18, Z+4	; 0x04
    170a:	35 81       	ldd	r19, Z+5	; 0x05
    170c:	e9 81       	ldd	r30, Y+1	; 0x01
    170e:	fa 81       	ldd	r31, Y+2	; 0x02
    1710:	82 81       	ldd	r24, Z+2	; 0x02
    1712:	93 81       	ldd	r25, Z+3	; 0x03
    1714:	28 17       	cp	r18, r24
    1716:	39 07       	cpc	r19, r25
    1718:	08 f4       	brcc	.+2      	; 0x171c <prvCopyDataToQueue+0x7e>
    171a:	47 c0       	rjmp	.+142    	; 0x17aa <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    171c:	e9 81       	ldd	r30, Y+1	; 0x01
    171e:	fa 81       	ldd	r31, Y+2	; 0x02
    1720:	80 81       	ld	r24, Z
    1722:	91 81       	ldd	r25, Z+1	; 0x01
    1724:	e9 81       	ldd	r30, Y+1	; 0x01
    1726:	fa 81       	ldd	r31, Y+2	; 0x02
    1728:	95 83       	std	Z+5, r25	; 0x05
    172a:	84 83       	std	Z+4, r24	; 0x04
    172c:	3e c0       	rjmp	.+124    	; 0x17aa <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    172e:	e9 81       	ldd	r30, Y+1	; 0x01
    1730:	fa 81       	ldd	r31, Y+2	; 0x02
    1732:	66 81       	ldd	r22, Z+6	; 0x06
    1734:	77 81       	ldd	r23, Z+7	; 0x07
    1736:	e9 81       	ldd	r30, Y+1	; 0x01
    1738:	fa 81       	ldd	r31, Y+2	; 0x02
    173a:	84 8d       	ldd	r24, Z+28	; 0x1c
    173c:	48 2f       	mov	r20, r24
    173e:	50 e0       	ldi	r21, 0x00	; 0
    1740:	2b 81       	ldd	r18, Y+3	; 0x03
    1742:	3c 81       	ldd	r19, Y+4	; 0x04
    1744:	cb 01       	movw	r24, r22
    1746:	b9 01       	movw	r22, r18
    1748:	0e 94 d7 13 	call	0x27ae	; 0x27ae <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    174c:	e9 81       	ldd	r30, Y+1	; 0x01
    174e:	fa 81       	ldd	r31, Y+2	; 0x02
    1750:	26 81       	ldd	r18, Z+6	; 0x06
    1752:	37 81       	ldd	r19, Z+7	; 0x07
    1754:	e9 81       	ldd	r30, Y+1	; 0x01
    1756:	fa 81       	ldd	r31, Y+2	; 0x02
    1758:	84 8d       	ldd	r24, Z+28	; 0x1c
    175a:	88 2f       	mov	r24, r24
    175c:	90 e0       	ldi	r25, 0x00	; 0
    175e:	90 95       	com	r25
    1760:	81 95       	neg	r24
    1762:	9f 4f       	sbci	r25, 0xFF	; 255
    1764:	82 0f       	add	r24, r18
    1766:	93 1f       	adc	r25, r19
    1768:	e9 81       	ldd	r30, Y+1	; 0x01
    176a:	fa 81       	ldd	r31, Y+2	; 0x02
    176c:	97 83       	std	Z+7, r25	; 0x07
    176e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1770:	e9 81       	ldd	r30, Y+1	; 0x01
    1772:	fa 81       	ldd	r31, Y+2	; 0x02
    1774:	26 81       	ldd	r18, Z+6	; 0x06
    1776:	37 81       	ldd	r19, Z+7	; 0x07
    1778:	e9 81       	ldd	r30, Y+1	; 0x01
    177a:	fa 81       	ldd	r31, Y+2	; 0x02
    177c:	80 81       	ld	r24, Z
    177e:	91 81       	ldd	r25, Z+1	; 0x01
    1780:	28 17       	cp	r18, r24
    1782:	39 07       	cpc	r19, r25
    1784:	90 f4       	brcc	.+36     	; 0x17aa <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1786:	e9 81       	ldd	r30, Y+1	; 0x01
    1788:	fa 81       	ldd	r31, Y+2	; 0x02
    178a:	22 81       	ldd	r18, Z+2	; 0x02
    178c:	33 81       	ldd	r19, Z+3	; 0x03
    178e:	e9 81       	ldd	r30, Y+1	; 0x01
    1790:	fa 81       	ldd	r31, Y+2	; 0x02
    1792:	84 8d       	ldd	r24, Z+28	; 0x1c
    1794:	88 2f       	mov	r24, r24
    1796:	90 e0       	ldi	r25, 0x00	; 0
    1798:	90 95       	com	r25
    179a:	81 95       	neg	r24
    179c:	9f 4f       	sbci	r25, 0xFF	; 255
    179e:	82 0f       	add	r24, r18
    17a0:	93 1f       	adc	r25, r19
    17a2:	e9 81       	ldd	r30, Y+1	; 0x01
    17a4:	fa 81       	ldd	r31, Y+2	; 0x02
    17a6:	97 83       	std	Z+7, r25	; 0x07
    17a8:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    17aa:	e9 81       	ldd	r30, Y+1	; 0x01
    17ac:	fa 81       	ldd	r31, Y+2	; 0x02
    17ae:	82 8d       	ldd	r24, Z+26	; 0x1a
    17b0:	8f 5f       	subi	r24, 0xFF	; 255
    17b2:	e9 81       	ldd	r30, Y+1	; 0x01
    17b4:	fa 81       	ldd	r31, Y+2	; 0x02
    17b6:	82 8f       	std	Z+26, r24	; 0x1a
}
    17b8:	0f 90       	pop	r0
    17ba:	0f 90       	pop	r0
    17bc:	0f 90       	pop	r0
    17be:	0f 90       	pop	r0
    17c0:	0f 90       	pop	r0
    17c2:	cf 91       	pop	r28
    17c4:	df 91       	pop	r29
    17c6:	08 95       	ret

000017c8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    17c8:	df 93       	push	r29
    17ca:	cf 93       	push	r28
    17cc:	00 d0       	rcall	.+0      	; 0x17ce <prvCopyDataFromQueue+0x6>
    17ce:	00 d0       	rcall	.+0      	; 0x17d0 <prvCopyDataFromQueue+0x8>
    17d0:	cd b7       	in	r28, 0x3d	; 61
    17d2:	de b7       	in	r29, 0x3e	; 62
    17d4:	9a 83       	std	Y+2, r25	; 0x02
    17d6:	89 83       	std	Y+1, r24	; 0x01
    17d8:	7c 83       	std	Y+4, r23	; 0x04
    17da:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    17dc:	e9 81       	ldd	r30, Y+1	; 0x01
    17de:	fa 81       	ldd	r31, Y+2	; 0x02
    17e0:	80 81       	ld	r24, Z
    17e2:	91 81       	ldd	r25, Z+1	; 0x01
    17e4:	00 97       	sbiw	r24, 0x00	; 0
    17e6:	89 f1       	breq	.+98     	; 0x184a <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    17e8:	e9 81       	ldd	r30, Y+1	; 0x01
    17ea:	fa 81       	ldd	r31, Y+2	; 0x02
    17ec:	26 81       	ldd	r18, Z+6	; 0x06
    17ee:	37 81       	ldd	r19, Z+7	; 0x07
    17f0:	e9 81       	ldd	r30, Y+1	; 0x01
    17f2:	fa 81       	ldd	r31, Y+2	; 0x02
    17f4:	84 8d       	ldd	r24, Z+28	; 0x1c
    17f6:	88 2f       	mov	r24, r24
    17f8:	90 e0       	ldi	r25, 0x00	; 0
    17fa:	82 0f       	add	r24, r18
    17fc:	93 1f       	adc	r25, r19
    17fe:	e9 81       	ldd	r30, Y+1	; 0x01
    1800:	fa 81       	ldd	r31, Y+2	; 0x02
    1802:	97 83       	std	Z+7, r25	; 0x07
    1804:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1806:	e9 81       	ldd	r30, Y+1	; 0x01
    1808:	fa 81       	ldd	r31, Y+2	; 0x02
    180a:	26 81       	ldd	r18, Z+6	; 0x06
    180c:	37 81       	ldd	r19, Z+7	; 0x07
    180e:	e9 81       	ldd	r30, Y+1	; 0x01
    1810:	fa 81       	ldd	r31, Y+2	; 0x02
    1812:	82 81       	ldd	r24, Z+2	; 0x02
    1814:	93 81       	ldd	r25, Z+3	; 0x03
    1816:	28 17       	cp	r18, r24
    1818:	39 07       	cpc	r19, r25
    181a:	40 f0       	brcs	.+16     	; 0x182c <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    181c:	e9 81       	ldd	r30, Y+1	; 0x01
    181e:	fa 81       	ldd	r31, Y+2	; 0x02
    1820:	80 81       	ld	r24, Z
    1822:	91 81       	ldd	r25, Z+1	; 0x01
    1824:	e9 81       	ldd	r30, Y+1	; 0x01
    1826:	fa 81       	ldd	r31, Y+2	; 0x02
    1828:	97 83       	std	Z+7, r25	; 0x07
    182a:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    182c:	e9 81       	ldd	r30, Y+1	; 0x01
    182e:	fa 81       	ldd	r31, Y+2	; 0x02
    1830:	46 81       	ldd	r20, Z+6	; 0x06
    1832:	57 81       	ldd	r21, Z+7	; 0x07
    1834:	e9 81       	ldd	r30, Y+1	; 0x01
    1836:	fa 81       	ldd	r31, Y+2	; 0x02
    1838:	84 8d       	ldd	r24, Z+28	; 0x1c
    183a:	28 2f       	mov	r18, r24
    183c:	30 e0       	ldi	r19, 0x00	; 0
    183e:	8b 81       	ldd	r24, Y+3	; 0x03
    1840:	9c 81       	ldd	r25, Y+4	; 0x04
    1842:	ba 01       	movw	r22, r20
    1844:	a9 01       	movw	r20, r18
    1846:	0e 94 d7 13 	call	0x27ae	; 0x27ae <memcpy>
	}
}
    184a:	0f 90       	pop	r0
    184c:	0f 90       	pop	r0
    184e:	0f 90       	pop	r0
    1850:	0f 90       	pop	r0
    1852:	cf 91       	pop	r28
    1854:	df 91       	pop	r29
    1856:	08 95       	ret

00001858 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1858:	df 93       	push	r29
    185a:	cf 93       	push	r28
    185c:	00 d0       	rcall	.+0      	; 0x185e <prvUnlockQueue+0x6>
    185e:	cd b7       	in	r28, 0x3d	; 61
    1860:	de b7       	in	r29, 0x3e	; 62
    1862:	9a 83       	std	Y+2, r25	; 0x02
    1864:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1866:	0f b6       	in	r0, 0x3f	; 63
    1868:	f8 94       	cli
    186a:	0f 92       	push	r0
    186c:	15 c0       	rjmp	.+42     	; 0x1898 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    186e:	e9 81       	ldd	r30, Y+1	; 0x01
    1870:	fa 81       	ldd	r31, Y+2	; 0x02
    1872:	81 89       	ldd	r24, Z+17	; 0x11
    1874:	88 23       	and	r24, r24
    1876:	a9 f0       	breq	.+42     	; 0x18a2 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1878:	89 81       	ldd	r24, Y+1	; 0x01
    187a:	9a 81       	ldd	r25, Y+2	; 0x02
    187c:	41 96       	adiw	r24, 0x11	; 17
    187e:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xTaskRemoveFromEventList>
    1882:	88 23       	and	r24, r24
    1884:	11 f0       	breq	.+4      	; 0x188a <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1886:	0e 94 42 12 	call	0x2484	; 0x2484 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    188a:	e9 81       	ldd	r30, Y+1	; 0x01
    188c:	fa 81       	ldd	r31, Y+2	; 0x02
    188e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1890:	81 50       	subi	r24, 0x01	; 1
    1892:	e9 81       	ldd	r30, Y+1	; 0x01
    1894:	fa 81       	ldd	r31, Y+2	; 0x02
    1896:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1898:	e9 81       	ldd	r30, Y+1	; 0x01
    189a:	fa 81       	ldd	r31, Y+2	; 0x02
    189c:	86 8d       	ldd	r24, Z+30	; 0x1e
    189e:	18 16       	cp	r1, r24
    18a0:	34 f3       	brlt	.-52     	; 0x186e <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    18a2:	e9 81       	ldd	r30, Y+1	; 0x01
    18a4:	fa 81       	ldd	r31, Y+2	; 0x02
    18a6:	8f ef       	ldi	r24, 0xFF	; 255
    18a8:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    18aa:	0f 90       	pop	r0
    18ac:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    18ae:	0f b6       	in	r0, 0x3f	; 63
    18b0:	f8 94       	cli
    18b2:	0f 92       	push	r0
    18b4:	15 c0       	rjmp	.+42     	; 0x18e0 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    18b6:	e9 81       	ldd	r30, Y+1	; 0x01
    18b8:	fa 81       	ldd	r31, Y+2	; 0x02
    18ba:	80 85       	ldd	r24, Z+8	; 0x08
    18bc:	88 23       	and	r24, r24
    18be:	a9 f0       	breq	.+42     	; 0x18ea <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    18c0:	89 81       	ldd	r24, Y+1	; 0x01
    18c2:	9a 81       	ldd	r25, Y+2	; 0x02
    18c4:	08 96       	adiw	r24, 0x08	; 8
    18c6:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xTaskRemoveFromEventList>
    18ca:	88 23       	and	r24, r24
    18cc:	11 f0       	breq	.+4      	; 0x18d2 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    18ce:	0e 94 42 12 	call	0x2484	; 0x2484 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    18d2:	e9 81       	ldd	r30, Y+1	; 0x01
    18d4:	fa 81       	ldd	r31, Y+2	; 0x02
    18d6:	85 8d       	ldd	r24, Z+29	; 0x1d
    18d8:	81 50       	subi	r24, 0x01	; 1
    18da:	e9 81       	ldd	r30, Y+1	; 0x01
    18dc:	fa 81       	ldd	r31, Y+2	; 0x02
    18de:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    18e0:	e9 81       	ldd	r30, Y+1	; 0x01
    18e2:	fa 81       	ldd	r31, Y+2	; 0x02
    18e4:	85 8d       	ldd	r24, Z+29	; 0x1d
    18e6:	18 16       	cp	r1, r24
    18e8:	34 f3       	brlt	.-52     	; 0x18b6 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    18ea:	e9 81       	ldd	r30, Y+1	; 0x01
    18ec:	fa 81       	ldd	r31, Y+2	; 0x02
    18ee:	8f ef       	ldi	r24, 0xFF	; 255
    18f0:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    18f2:	0f 90       	pop	r0
    18f4:	0f be       	out	0x3f, r0	; 63
}
    18f6:	0f 90       	pop	r0
    18f8:	0f 90       	pop	r0
    18fa:	cf 91       	pop	r28
    18fc:	df 91       	pop	r29
    18fe:	08 95       	ret

00001900 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    1900:	df 93       	push	r29
    1902:	cf 93       	push	r28
    1904:	00 d0       	rcall	.+0      	; 0x1906 <prvIsQueueEmpty+0x6>
    1906:	0f 92       	push	r0
    1908:	cd b7       	in	r28, 0x3d	; 61
    190a:	de b7       	in	r29, 0x3e	; 62
    190c:	9b 83       	std	Y+3, r25	; 0x03
    190e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1910:	0f b6       	in	r0, 0x3f	; 63
    1912:	f8 94       	cli
    1914:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1916:	ea 81       	ldd	r30, Y+2	; 0x02
    1918:	fb 81       	ldd	r31, Y+3	; 0x03
    191a:	82 8d       	ldd	r24, Z+26	; 0x1a
    191c:	19 82       	std	Y+1, r1	; 0x01
    191e:	88 23       	and	r24, r24
    1920:	11 f4       	brne	.+4      	; 0x1926 <prvIsQueueEmpty+0x26>
    1922:	81 e0       	ldi	r24, 0x01	; 1
    1924:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1926:	0f 90       	pop	r0
    1928:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    192a:	89 81       	ldd	r24, Y+1	; 0x01
}
    192c:	0f 90       	pop	r0
    192e:	0f 90       	pop	r0
    1930:	0f 90       	pop	r0
    1932:	cf 91       	pop	r28
    1934:	df 91       	pop	r29
    1936:	08 95       	ret

00001938 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1938:	df 93       	push	r29
    193a:	cf 93       	push	r28
    193c:	00 d0       	rcall	.+0      	; 0x193e <xQueueIsQueueEmptyFromISR+0x6>
    193e:	0f 92       	push	r0
    1940:	cd b7       	in	r28, 0x3d	; 61
    1942:	de b7       	in	r29, 0x3e	; 62
    1944:	9b 83       	std	Y+3, r25	; 0x03
    1946:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1948:	ea 81       	ldd	r30, Y+2	; 0x02
    194a:	fb 81       	ldd	r31, Y+3	; 0x03
    194c:	82 8d       	ldd	r24, Z+26	; 0x1a
    194e:	19 82       	std	Y+1, r1	; 0x01
    1950:	88 23       	and	r24, r24
    1952:	11 f4       	brne	.+4      	; 0x1958 <xQueueIsQueueEmptyFromISR+0x20>
    1954:	81 e0       	ldi	r24, 0x01	; 1
    1956:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1958:	89 81       	ldd	r24, Y+1	; 0x01
}
    195a:	0f 90       	pop	r0
    195c:	0f 90       	pop	r0
    195e:	0f 90       	pop	r0
    1960:	cf 91       	pop	r28
    1962:	df 91       	pop	r29
    1964:	08 95       	ret

00001966 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    1966:	df 93       	push	r29
    1968:	cf 93       	push	r28
    196a:	00 d0       	rcall	.+0      	; 0x196c <prvIsQueueFull+0x6>
    196c:	0f 92       	push	r0
    196e:	cd b7       	in	r28, 0x3d	; 61
    1970:	de b7       	in	r29, 0x3e	; 62
    1972:	9b 83       	std	Y+3, r25	; 0x03
    1974:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1976:	0f b6       	in	r0, 0x3f	; 63
    1978:	f8 94       	cli
    197a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    197c:	ea 81       	ldd	r30, Y+2	; 0x02
    197e:	fb 81       	ldd	r31, Y+3	; 0x03
    1980:	92 8d       	ldd	r25, Z+26	; 0x1a
    1982:	ea 81       	ldd	r30, Y+2	; 0x02
    1984:	fb 81       	ldd	r31, Y+3	; 0x03
    1986:	83 8d       	ldd	r24, Z+27	; 0x1b
    1988:	19 82       	std	Y+1, r1	; 0x01
    198a:	98 17       	cp	r25, r24
    198c:	11 f4       	brne	.+4      	; 0x1992 <prvIsQueueFull+0x2c>
    198e:	81 e0       	ldi	r24, 0x01	; 1
    1990:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1992:	0f 90       	pop	r0
    1994:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1996:	89 81       	ldd	r24, Y+1	; 0x01
}
    1998:	0f 90       	pop	r0
    199a:	0f 90       	pop	r0
    199c:	0f 90       	pop	r0
    199e:	cf 91       	pop	r28
    19a0:	df 91       	pop	r29
    19a2:	08 95       	ret

000019a4 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    19a4:	df 93       	push	r29
    19a6:	cf 93       	push	r28
    19a8:	00 d0       	rcall	.+0      	; 0x19aa <xQueueIsQueueFullFromISR+0x6>
    19aa:	0f 92       	push	r0
    19ac:	cd b7       	in	r28, 0x3d	; 61
    19ae:	de b7       	in	r29, 0x3e	; 62
    19b0:	9b 83       	std	Y+3, r25	; 0x03
    19b2:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    19b4:	ea 81       	ldd	r30, Y+2	; 0x02
    19b6:	fb 81       	ldd	r31, Y+3	; 0x03
    19b8:	92 8d       	ldd	r25, Z+26	; 0x1a
    19ba:	ea 81       	ldd	r30, Y+2	; 0x02
    19bc:	fb 81       	ldd	r31, Y+3	; 0x03
    19be:	83 8d       	ldd	r24, Z+27	; 0x1b
    19c0:	19 82       	std	Y+1, r1	; 0x01
    19c2:	98 17       	cp	r25, r24
    19c4:	11 f4       	brne	.+4      	; 0x19ca <xQueueIsQueueFullFromISR+0x26>
    19c6:	81 e0       	ldi	r24, 0x01	; 1
    19c8:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    19ca:	89 81       	ldd	r24, Y+1	; 0x01
}
    19cc:	0f 90       	pop	r0
    19ce:	0f 90       	pop	r0
    19d0:	0f 90       	pop	r0
    19d2:	cf 91       	pop	r28
    19d4:	df 91       	pop	r29
    19d6:	08 95       	ret

000019d8 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    19d8:	af 92       	push	r10
    19da:	bf 92       	push	r11
    19dc:	cf 92       	push	r12
    19de:	df 92       	push	r13
    19e0:	ef 92       	push	r14
    19e2:	ff 92       	push	r15
    19e4:	0f 93       	push	r16
    19e6:	1f 93       	push	r17
    19e8:	df 93       	push	r29
    19ea:	cf 93       	push	r28
    19ec:	cd b7       	in	r28, 0x3d	; 61
    19ee:	de b7       	in	r29, 0x3e	; 62
    19f0:	64 97       	sbiw	r28, 0x14	; 20
    19f2:	0f b6       	in	r0, 0x3f	; 63
    19f4:	f8 94       	cli
    19f6:	de bf       	out	0x3e, r29	; 62
    19f8:	0f be       	out	0x3f, r0	; 63
    19fa:	cd bf       	out	0x3d, r28	; 61
    19fc:	9f 83       	std	Y+7, r25	; 0x07
    19fe:	8e 83       	std	Y+6, r24	; 0x06
    1a00:	79 87       	std	Y+9, r23	; 0x09
    1a02:	68 87       	std	Y+8, r22	; 0x08
    1a04:	5b 87       	std	Y+11, r21	; 0x0b
    1a06:	4a 87       	std	Y+10, r20	; 0x0a
    1a08:	3d 87       	std	Y+13, r19	; 0x0d
    1a0a:	2c 87       	std	Y+12, r18	; 0x0c
    1a0c:	0e 87       	std	Y+14, r16	; 0x0e
    1a0e:	f8 8a       	std	Y+16, r15	; 0x10
    1a10:	ef 86       	std	Y+15, r14	; 0x0f
    1a12:	da 8a       	std	Y+18, r13	; 0x12
    1a14:	c9 8a       	std	Y+17, r12	; 0x11
    1a16:	bc 8a       	std	Y+20, r11	; 0x14
    1a18:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    1a1a:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a1c:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a1e:	29 89       	ldd	r18, Y+17	; 0x11
    1a20:	3a 89       	ldd	r19, Y+18	; 0x12
    1a22:	b9 01       	movw	r22, r18
    1a24:	0e 94 71 13 	call	0x26e2	; 0x26e2 <prvAllocateTCBAndStack>
    1a28:	9c 83       	std	Y+4, r25	; 0x04
    1a2a:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    1a2c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a2e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a30:	00 97       	sbiw	r24, 0x00	; 0
    1a32:	09 f4       	brne	.+2      	; 0x1a36 <xTaskGenericCreate+0x5e>
    1a34:	99 c0       	rjmp	.+306    	; 0x1b68 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1a36:	eb 81       	ldd	r30, Y+3	; 0x03
    1a38:	fc 81       	ldd	r31, Y+4	; 0x04
    1a3a:	27 89       	ldd	r18, Z+23	; 0x17
    1a3c:	30 8d       	ldd	r19, Z+24	; 0x18
    1a3e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a40:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a42:	01 97       	sbiw	r24, 0x01	; 1
    1a44:	82 0f       	add	r24, r18
    1a46:	93 1f       	adc	r25, r19
    1a48:	9a 83       	std	Y+2, r25	; 0x02
    1a4a:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    1a4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a50:	28 85       	ldd	r18, Y+8	; 0x08
    1a52:	39 85       	ldd	r19, Y+9	; 0x09
    1a54:	eb 89       	ldd	r30, Y+19	; 0x13
    1a56:	fc 89       	ldd	r31, Y+20	; 0x14
    1a58:	aa 85       	ldd	r26, Y+10	; 0x0a
    1a5a:	bb 85       	ldd	r27, Y+11	; 0x0b
    1a5c:	b9 01       	movw	r22, r18
    1a5e:	4e 85       	ldd	r20, Y+14	; 0x0e
    1a60:	9f 01       	movw	r18, r30
    1a62:	8d 01       	movw	r16, r26
    1a64:	0e 94 56 12 	call	0x24ac	; 0x24ac <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1a68:	89 81       	ldd	r24, Y+1	; 0x01
    1a6a:	9a 81       	ldd	r25, Y+2	; 0x02
    1a6c:	2e 81       	ldd	r18, Y+6	; 0x06
    1a6e:	3f 81       	ldd	r19, Y+7	; 0x07
    1a70:	4c 85       	ldd	r20, Y+12	; 0x0c
    1a72:	5d 85       	ldd	r21, Y+13	; 0x0d
    1a74:	b9 01       	movw	r22, r18
    1a76:	0e 94 99 05 	call	0xb32	; 0xb32 <pxPortInitialiseStack>
    1a7a:	eb 81       	ldd	r30, Y+3	; 0x03
    1a7c:	fc 81       	ldd	r31, Y+4	; 0x04
    1a7e:	91 83       	std	Z+1, r25	; 0x01
    1a80:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    1a82:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a84:	98 89       	ldd	r25, Y+16	; 0x10
    1a86:	00 97       	sbiw	r24, 0x00	; 0
    1a88:	31 f0       	breq	.+12     	; 0x1a96 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1a8a:	ef 85       	ldd	r30, Y+15	; 0x0f
    1a8c:	f8 89       	ldd	r31, Y+16	; 0x10
    1a8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a90:	9c 81       	ldd	r25, Y+4	; 0x04
    1a92:	91 83       	std	Z+1, r25	; 0x01
    1a94:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1a96:	0f b6       	in	r0, 0x3f	; 63
    1a98:	f8 94       	cli
    1a9a:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1a9c:	80 91 12 03 	lds	r24, 0x0312
    1aa0:	8f 5f       	subi	r24, 0xFF	; 255
    1aa2:	80 93 12 03 	sts	0x0312, r24
			if( pxCurrentTCB == NULL )
    1aa6:	80 91 0f 03 	lds	r24, 0x030F
    1aaa:	90 91 10 03 	lds	r25, 0x0310
    1aae:	00 97       	sbiw	r24, 0x00	; 0
    1ab0:	69 f4       	brne	.+26     	; 0x1acc <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1ab2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ab4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ab6:	90 93 10 03 	sts	0x0310, r25
    1aba:	80 93 0f 03 	sts	0x030F, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1abe:	80 91 12 03 	lds	r24, 0x0312
    1ac2:	81 30       	cpi	r24, 0x01	; 1
    1ac4:	a9 f4       	brne	.+42     	; 0x1af0 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    1ac6:	0e 94 ad 12 	call	0x255a	; 0x255a <prvInitialiseTaskLists>
    1aca:	12 c0       	rjmp	.+36     	; 0x1af0 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1acc:	80 91 17 03 	lds	r24, 0x0317
    1ad0:	88 23       	and	r24, r24
    1ad2:	71 f4       	brne	.+28     	; 0x1af0 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1ad4:	e0 91 0f 03 	lds	r30, 0x030F
    1ad8:	f0 91 10 03 	lds	r31, 0x0310
    1adc:	96 89       	ldd	r25, Z+22	; 0x16
    1ade:	8e 85       	ldd	r24, Y+14	; 0x0e
    1ae0:	89 17       	cp	r24, r25
    1ae2:	30 f0       	brcs	.+12     	; 0x1af0 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    1ae4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ae6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ae8:	90 93 10 03 	sts	0x0310, r25
    1aec:	80 93 0f 03 	sts	0x030F, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1af0:	eb 81       	ldd	r30, Y+3	; 0x03
    1af2:	fc 81       	ldd	r31, Y+4	; 0x04
    1af4:	96 89       	ldd	r25, Z+22	; 0x16
    1af6:	80 91 15 03 	lds	r24, 0x0315
    1afa:	89 17       	cp	r24, r25
    1afc:	28 f4       	brcc	.+10     	; 0x1b08 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1afe:	eb 81       	ldd	r30, Y+3	; 0x03
    1b00:	fc 81       	ldd	r31, Y+4	; 0x04
    1b02:	86 89       	ldd	r24, Z+22	; 0x16
    1b04:	80 93 15 03 	sts	0x0315, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1b08:	80 91 1c 03 	lds	r24, 0x031C
    1b0c:	8f 5f       	subi	r24, 0xFF	; 255
    1b0e:	80 93 1c 03 	sts	0x031C, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1b12:	eb 81       	ldd	r30, Y+3	; 0x03
    1b14:	fc 81       	ldd	r31, Y+4	; 0x04
    1b16:	96 89       	ldd	r25, Z+22	; 0x16
    1b18:	80 91 16 03 	lds	r24, 0x0316
    1b1c:	89 17       	cp	r24, r25
    1b1e:	28 f4       	brcc	.+10     	; 0x1b2a <xTaskGenericCreate+0x152>
    1b20:	eb 81       	ldd	r30, Y+3	; 0x03
    1b22:	fc 81       	ldd	r31, Y+4	; 0x04
    1b24:	86 89       	ldd	r24, Z+22	; 0x16
    1b26:	80 93 16 03 	sts	0x0316, r24
    1b2a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b2c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b2e:	86 89       	ldd	r24, Z+22	; 0x16
    1b30:	28 2f       	mov	r18, r24
    1b32:	30 e0       	ldi	r19, 0x00	; 0
    1b34:	c9 01       	movw	r24, r18
    1b36:	88 0f       	add	r24, r24
    1b38:	99 1f       	adc	r25, r25
    1b3a:	88 0f       	add	r24, r24
    1b3c:	99 1f       	adc	r25, r25
    1b3e:	88 0f       	add	r24, r24
    1b40:	99 1f       	adc	r25, r25
    1b42:	82 0f       	add	r24, r18
    1b44:	93 1f       	adc	r25, r19
    1b46:	ac 01       	movw	r20, r24
    1b48:	43 5e       	subi	r20, 0xE3	; 227
    1b4a:	5c 4f       	sbci	r21, 0xFC	; 252
    1b4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1b50:	9c 01       	movw	r18, r24
    1b52:	2e 5f       	subi	r18, 0xFE	; 254
    1b54:	3f 4f       	sbci	r19, 0xFF	; 255
    1b56:	ca 01       	movw	r24, r20
    1b58:	b9 01       	movw	r22, r18
    1b5a:	0e 94 98 04 	call	0x930	; 0x930 <vListInsertEnd>

			xReturn = pdPASS;
    1b5e:	81 e0       	ldi	r24, 0x01	; 1
    1b60:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1b62:	0f 90       	pop	r0
    1b64:	0f be       	out	0x3f, r0	; 63
    1b66:	02 c0       	rjmp	.+4      	; 0x1b6c <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1b68:	8f ef       	ldi	r24, 0xFF	; 255
    1b6a:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    1b6c:	8d 81       	ldd	r24, Y+5	; 0x05
    1b6e:	81 30       	cpi	r24, 0x01	; 1
    1b70:	71 f4       	brne	.+28     	; 0x1b8e <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    1b72:	80 91 17 03 	lds	r24, 0x0317
    1b76:	88 23       	and	r24, r24
    1b78:	51 f0       	breq	.+20     	; 0x1b8e <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1b7a:	e0 91 0f 03 	lds	r30, 0x030F
    1b7e:	f0 91 10 03 	lds	r31, 0x0310
    1b82:	96 89       	ldd	r25, Z+22	; 0x16
    1b84:	8e 85       	ldd	r24, Y+14	; 0x0e
    1b86:	98 17       	cp	r25, r24
    1b88:	10 f4       	brcc	.+4      	; 0x1b8e <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    1b8a:	0e 94 58 07 	call	0xeb0	; 0xeb0 <vPortYield>
			}
		}
	}

	return xReturn;
    1b8e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1b90:	64 96       	adiw	r28, 0x14	; 20
    1b92:	0f b6       	in	r0, 0x3f	; 63
    1b94:	f8 94       	cli
    1b96:	de bf       	out	0x3e, r29	; 62
    1b98:	0f be       	out	0x3f, r0	; 63
    1b9a:	cd bf       	out	0x3d, r28	; 61
    1b9c:	cf 91       	pop	r28
    1b9e:	df 91       	pop	r29
    1ba0:	1f 91       	pop	r17
    1ba2:	0f 91       	pop	r16
    1ba4:	ff 90       	pop	r15
    1ba6:	ef 90       	pop	r14
    1ba8:	df 90       	pop	r13
    1baa:	cf 90       	pop	r12
    1bac:	bf 90       	pop	r11
    1bae:	af 90       	pop	r10
    1bb0:	08 95       	ret

00001bb2 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1bb2:	df 93       	push	r29
    1bb4:	cf 93       	push	r28
    1bb6:	00 d0       	rcall	.+0      	; 0x1bb8 <vTaskDelete+0x6>
    1bb8:	00 d0       	rcall	.+0      	; 0x1bba <vTaskDelete+0x8>
    1bba:	00 d0       	rcall	.+0      	; 0x1bbc <vTaskDelete+0xa>
    1bbc:	cd b7       	in	r28, 0x3d	; 61
    1bbe:	de b7       	in	r29, 0x3e	; 62
    1bc0:	9c 83       	std	Y+4, r25	; 0x04
    1bc2:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1bc4:	0f b6       	in	r0, 0x3f	; 63
    1bc6:	f8 94       	cli
    1bc8:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1bca:	20 91 0f 03 	lds	r18, 0x030F
    1bce:	30 91 10 03 	lds	r19, 0x0310
    1bd2:	8b 81       	ldd	r24, Y+3	; 0x03
    1bd4:	9c 81       	ldd	r25, Y+4	; 0x04
    1bd6:	82 17       	cp	r24, r18
    1bd8:	93 07       	cpc	r25, r19
    1bda:	11 f4       	brne	.+4      	; 0x1be0 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    1bdc:	1c 82       	std	Y+4, r1	; 0x04
    1bde:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1be0:	8b 81       	ldd	r24, Y+3	; 0x03
    1be2:	9c 81       	ldd	r25, Y+4	; 0x04
    1be4:	00 97       	sbiw	r24, 0x00	; 0
    1be6:	39 f4       	brne	.+14     	; 0x1bf6 <vTaskDelete+0x44>
    1be8:	80 91 0f 03 	lds	r24, 0x030F
    1bec:	90 91 10 03 	lds	r25, 0x0310
    1bf0:	9e 83       	std	Y+6, r25	; 0x06
    1bf2:	8d 83       	std	Y+5, r24	; 0x05
    1bf4:	04 c0       	rjmp	.+8      	; 0x1bfe <vTaskDelete+0x4c>
    1bf6:	8b 81       	ldd	r24, Y+3	; 0x03
    1bf8:	9c 81       	ldd	r25, Y+4	; 0x04
    1bfa:	9e 83       	std	Y+6, r25	; 0x06
    1bfc:	8d 83       	std	Y+5, r24	; 0x05
    1bfe:	8d 81       	ldd	r24, Y+5	; 0x05
    1c00:	9e 81       	ldd	r25, Y+6	; 0x06
    1c02:	9a 83       	std	Y+2, r25	; 0x02
    1c04:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1c06:	89 81       	ldd	r24, Y+1	; 0x01
    1c08:	9a 81       	ldd	r25, Y+2	; 0x02
    1c0a:	02 96       	adiw	r24, 0x02	; 2
    1c0c:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1c10:	e9 81       	ldd	r30, Y+1	; 0x01
    1c12:	fa 81       	ldd	r31, Y+2	; 0x02
    1c14:	84 89       	ldd	r24, Z+20	; 0x14
    1c16:	95 89       	ldd	r25, Z+21	; 0x15
    1c18:	00 97       	sbiw	r24, 0x00	; 0
    1c1a:	29 f0       	breq	.+10     	; 0x1c26 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1c1c:	89 81       	ldd	r24, Y+1	; 0x01
    1c1e:	9a 81       	ldd	r25, Y+2	; 0x02
    1c20:	0c 96       	adiw	r24, 0x0c	; 12
    1c22:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1c26:	89 81       	ldd	r24, Y+1	; 0x01
    1c28:	9a 81       	ldd	r25, Y+2	; 0x02
    1c2a:	9c 01       	movw	r18, r24
    1c2c:	2e 5f       	subi	r18, 0xFE	; 254
    1c2e:	3f 4f       	sbci	r19, 0xFF	; 255
    1c30:	89 e6       	ldi	r24, 0x69	; 105
    1c32:	93 e0       	ldi	r25, 0x03	; 3
    1c34:	b9 01       	movw	r22, r18
    1c36:	0e 94 98 04 	call	0x930	; 0x930 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1c3a:	80 91 11 03 	lds	r24, 0x0311
    1c3e:	8f 5f       	subi	r24, 0xFF	; 255
    1c40:	80 93 11 03 	sts	0x0311, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1c44:	80 91 1c 03 	lds	r24, 0x031C
    1c48:	8f 5f       	subi	r24, 0xFF	; 255
    1c4a:	80 93 1c 03 	sts	0x031C, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1c4e:	0f 90       	pop	r0
    1c50:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1c52:	80 91 17 03 	lds	r24, 0x0317
    1c56:	88 23       	and	r24, r24
    1c58:	31 f0       	breq	.+12     	; 0x1c66 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1c5a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c5c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c5e:	00 97       	sbiw	r24, 0x00	; 0
    1c60:	11 f4       	brne	.+4      	; 0x1c66 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    1c62:	0e 94 58 07 	call	0xeb0	; 0xeb0 <vPortYield>
			}
		}
	}
    1c66:	26 96       	adiw	r28, 0x06	; 6
    1c68:	0f b6       	in	r0, 0x3f	; 63
    1c6a:	f8 94       	cli
    1c6c:	de bf       	out	0x3e, r29	; 62
    1c6e:	0f be       	out	0x3f, r0	; 63
    1c70:	cd bf       	out	0x3d, r28	; 61
    1c72:	cf 91       	pop	r28
    1c74:	df 91       	pop	r29
    1c76:	08 95       	ret

00001c78 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1c78:	df 93       	push	r29
    1c7a:	cf 93       	push	r28
    1c7c:	cd b7       	in	r28, 0x3d	; 61
    1c7e:	de b7       	in	r29, 0x3e	; 62
    1c80:	28 97       	sbiw	r28, 0x08	; 8
    1c82:	0f b6       	in	r0, 0x3f	; 63
    1c84:	f8 94       	cli
    1c86:	de bf       	out	0x3e, r29	; 62
    1c88:	0f be       	out	0x3f, r0	; 63
    1c8a:	cd bf       	out	0x3d, r28	; 61
    1c8c:	9e 83       	std	Y+6, r25	; 0x06
    1c8e:	8d 83       	std	Y+5, r24	; 0x05
    1c90:	78 87       	std	Y+8, r23	; 0x08
    1c92:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    1c94:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1c96:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1c9a:	ed 81       	ldd	r30, Y+5	; 0x05
    1c9c:	fe 81       	ldd	r31, Y+6	; 0x06
    1c9e:	20 81       	ld	r18, Z
    1ca0:	31 81       	ldd	r19, Z+1	; 0x01
    1ca2:	8f 81       	ldd	r24, Y+7	; 0x07
    1ca4:	98 85       	ldd	r25, Y+8	; 0x08
    1ca6:	82 0f       	add	r24, r18
    1ca8:	93 1f       	adc	r25, r19
    1caa:	9c 83       	std	Y+4, r25	; 0x04
    1cac:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    1cae:	ed 81       	ldd	r30, Y+5	; 0x05
    1cb0:	fe 81       	ldd	r31, Y+6	; 0x06
    1cb2:	20 81       	ld	r18, Z
    1cb4:	31 81       	ldd	r19, Z+1	; 0x01
    1cb6:	80 91 13 03 	lds	r24, 0x0313
    1cba:	90 91 14 03 	lds	r25, 0x0314
    1cbe:	82 17       	cp	r24, r18
    1cc0:	93 07       	cpc	r25, r19
    1cc2:	a8 f4       	brcc	.+42     	; 0x1cee <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1cc4:	ed 81       	ldd	r30, Y+5	; 0x05
    1cc6:	fe 81       	ldd	r31, Y+6	; 0x06
    1cc8:	20 81       	ld	r18, Z
    1cca:	31 81       	ldd	r19, Z+1	; 0x01
    1ccc:	8b 81       	ldd	r24, Y+3	; 0x03
    1cce:	9c 81       	ldd	r25, Y+4	; 0x04
    1cd0:	82 17       	cp	r24, r18
    1cd2:	93 07       	cpc	r25, r19
    1cd4:	00 f5       	brcc	.+64     	; 0x1d16 <vTaskDelayUntil+0x9e>
    1cd6:	20 91 13 03 	lds	r18, 0x0313
    1cda:	30 91 14 03 	lds	r19, 0x0314
    1cde:	8b 81       	ldd	r24, Y+3	; 0x03
    1ce0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ce2:	28 17       	cp	r18, r24
    1ce4:	39 07       	cpc	r19, r25
    1ce6:	b8 f4       	brcc	.+46     	; 0x1d16 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1ce8:	81 e0       	ldi	r24, 0x01	; 1
    1cea:	89 83       	std	Y+1, r24	; 0x01
    1cec:	14 c0       	rjmp	.+40     	; 0x1d16 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1cee:	ed 81       	ldd	r30, Y+5	; 0x05
    1cf0:	fe 81       	ldd	r31, Y+6	; 0x06
    1cf2:	20 81       	ld	r18, Z
    1cf4:	31 81       	ldd	r19, Z+1	; 0x01
    1cf6:	8b 81       	ldd	r24, Y+3	; 0x03
    1cf8:	9c 81       	ldd	r25, Y+4	; 0x04
    1cfa:	82 17       	cp	r24, r18
    1cfc:	93 07       	cpc	r25, r19
    1cfe:	48 f0       	brcs	.+18     	; 0x1d12 <vTaskDelayUntil+0x9a>
    1d00:	20 91 13 03 	lds	r18, 0x0313
    1d04:	30 91 14 03 	lds	r19, 0x0314
    1d08:	8b 81       	ldd	r24, Y+3	; 0x03
    1d0a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d0c:	28 17       	cp	r18, r24
    1d0e:	39 07       	cpc	r19, r25
    1d10:	10 f4       	brcc	.+4      	; 0x1d16 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1d12:	81 e0       	ldi	r24, 0x01	; 1
    1d14:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1d16:	ed 81       	ldd	r30, Y+5	; 0x05
    1d18:	fe 81       	ldd	r31, Y+6	; 0x06
    1d1a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d1c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d1e:	91 83       	std	Z+1, r25	; 0x01
    1d20:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1d22:	89 81       	ldd	r24, Y+1	; 0x01
    1d24:	88 23       	and	r24, r24
    1d26:	59 f0       	breq	.+22     	; 0x1d3e <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1d28:	80 91 0f 03 	lds	r24, 0x030F
    1d2c:	90 91 10 03 	lds	r25, 0x0310
    1d30:	02 96       	adiw	r24, 0x02	; 2
    1d32:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1d36:	8b 81       	ldd	r24, Y+3	; 0x03
    1d38:	9c 81       	ldd	r25, Y+4	; 0x04
    1d3a:	0e 94 28 13 	call	0x2650	; 0x2650 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1d3e:	0e 94 34 0f 	call	0x1e68	; 0x1e68 <xTaskResumeAll>
    1d42:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1d44:	8a 81       	ldd	r24, Y+2	; 0x02
    1d46:	88 23       	and	r24, r24
    1d48:	11 f4       	brne	.+4      	; 0x1d4e <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    1d4a:	0e 94 58 07 	call	0xeb0	; 0xeb0 <vPortYield>
		}
	}
    1d4e:	28 96       	adiw	r28, 0x08	; 8
    1d50:	0f b6       	in	r0, 0x3f	; 63
    1d52:	f8 94       	cli
    1d54:	de bf       	out	0x3e, r29	; 62
    1d56:	0f be       	out	0x3f, r0	; 63
    1d58:	cd bf       	out	0x3d, r28	; 61
    1d5a:	cf 91       	pop	r28
    1d5c:	df 91       	pop	r29
    1d5e:	08 95       	ret

00001d60 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1d60:	df 93       	push	r29
    1d62:	cf 93       	push	r28
    1d64:	00 d0       	rcall	.+0      	; 0x1d66 <vTaskDelay+0x6>
    1d66:	00 d0       	rcall	.+0      	; 0x1d68 <vTaskDelay+0x8>
    1d68:	0f 92       	push	r0
    1d6a:	cd b7       	in	r28, 0x3d	; 61
    1d6c:	de b7       	in	r29, 0x3e	; 62
    1d6e:	9d 83       	std	Y+5, r25	; 0x05
    1d70:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1d72:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1d74:	8c 81       	ldd	r24, Y+4	; 0x04
    1d76:	9d 81       	ldd	r25, Y+5	; 0x05
    1d78:	00 97       	sbiw	r24, 0x00	; 0
    1d7a:	d1 f0       	breq	.+52     	; 0x1db0 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    1d7c:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1d80:	20 91 13 03 	lds	r18, 0x0313
    1d84:	30 91 14 03 	lds	r19, 0x0314
    1d88:	8c 81       	ldd	r24, Y+4	; 0x04
    1d8a:	9d 81       	ldd	r25, Y+5	; 0x05
    1d8c:	82 0f       	add	r24, r18
    1d8e:	93 1f       	adc	r25, r19
    1d90:	9b 83       	std	Y+3, r25	; 0x03
    1d92:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1d94:	80 91 0f 03 	lds	r24, 0x030F
    1d98:	90 91 10 03 	lds	r25, 0x0310
    1d9c:	02 96       	adiw	r24, 0x02	; 2
    1d9e:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1da2:	8a 81       	ldd	r24, Y+2	; 0x02
    1da4:	9b 81       	ldd	r25, Y+3	; 0x03
    1da6:	0e 94 28 13 	call	0x2650	; 0x2650 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1daa:	0e 94 34 0f 	call	0x1e68	; 0x1e68 <xTaskResumeAll>
    1dae:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1db0:	89 81       	ldd	r24, Y+1	; 0x01
    1db2:	88 23       	and	r24, r24
    1db4:	11 f4       	brne	.+4      	; 0x1dba <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    1db6:	0e 94 58 07 	call	0xeb0	; 0xeb0 <vPortYield>
		}
	}
    1dba:	0f 90       	pop	r0
    1dbc:	0f 90       	pop	r0
    1dbe:	0f 90       	pop	r0
    1dc0:	0f 90       	pop	r0
    1dc2:	0f 90       	pop	r0
    1dc4:	cf 91       	pop	r28
    1dc6:	df 91       	pop	r29
    1dc8:	08 95       	ret

00001dca <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1dca:	af 92       	push	r10
    1dcc:	bf 92       	push	r11
    1dce:	cf 92       	push	r12
    1dd0:	df 92       	push	r13
    1dd2:	ef 92       	push	r14
    1dd4:	ff 92       	push	r15
    1dd6:	0f 93       	push	r16
    1dd8:	df 93       	push	r29
    1dda:	cf 93       	push	r28
    1ddc:	0f 92       	push	r0
    1dde:	cd b7       	in	r28, 0x3d	; 61
    1de0:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1de2:	21 e7       	ldi	r18, 0x71	; 113
    1de4:	30 e0       	ldi	r19, 0x00	; 0
    1de6:	8c e4       	ldi	r24, 0x4C	; 76
    1de8:	92 e1       	ldi	r25, 0x12	; 18
    1dea:	b9 01       	movw	r22, r18
    1dec:	45 e5       	ldi	r20, 0x55	; 85
    1dee:	50 e0       	ldi	r21, 0x00	; 0
    1df0:	20 e0       	ldi	r18, 0x00	; 0
    1df2:	30 e0       	ldi	r19, 0x00	; 0
    1df4:	00 e0       	ldi	r16, 0x00	; 0
    1df6:	ee 24       	eor	r14, r14
    1df8:	ff 24       	eor	r15, r15
    1dfa:	cc 24       	eor	r12, r12
    1dfc:	dd 24       	eor	r13, r13
    1dfe:	aa 24       	eor	r10, r10
    1e00:	bb 24       	eor	r11, r11
    1e02:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <xTaskGenericCreate>
    1e06:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1e08:	89 81       	ldd	r24, Y+1	; 0x01
    1e0a:	81 30       	cpi	r24, 0x01	; 1
    1e0c:	51 f4       	brne	.+20     	; 0x1e22 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1e0e:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1e10:	81 e0       	ldi	r24, 0x01	; 1
    1e12:	80 93 17 03 	sts	0x0317, r24
		xTickCount = ( portTickType ) 0U;
    1e16:	10 92 14 03 	sts	0x0314, r1
    1e1a:	10 92 13 03 	sts	0x0313, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1e1e:	0e 94 1c 07 	call	0xe38	; 0xe38 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1e22:	0f 90       	pop	r0
    1e24:	cf 91       	pop	r28
    1e26:	df 91       	pop	r29
    1e28:	0f 91       	pop	r16
    1e2a:	ff 90       	pop	r15
    1e2c:	ef 90       	pop	r14
    1e2e:	df 90       	pop	r13
    1e30:	cf 90       	pop	r12
    1e32:	bf 90       	pop	r11
    1e34:	af 90       	pop	r10
    1e36:	08 95       	ret

00001e38 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    1e38:	df 93       	push	r29
    1e3a:	cf 93       	push	r28
    1e3c:	cd b7       	in	r28, 0x3d	; 61
    1e3e:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1e40:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1e42:	10 92 17 03 	sts	0x0317, r1
	vPortEndScheduler();
    1e46:	0e 94 51 07 	call	0xea2	; 0xea2 <vPortEndScheduler>
}
    1e4a:	cf 91       	pop	r28
    1e4c:	df 91       	pop	r29
    1e4e:	08 95       	ret

00001e50 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    1e50:	df 93       	push	r29
    1e52:	cf 93       	push	r28
    1e54:	cd b7       	in	r28, 0x3d	; 61
    1e56:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1e58:	80 91 18 03 	lds	r24, 0x0318
    1e5c:	8f 5f       	subi	r24, 0xFF	; 255
    1e5e:	80 93 18 03 	sts	0x0318, r24
}
    1e62:	cf 91       	pop	r28
    1e64:	df 91       	pop	r29
    1e66:	08 95       	ret

00001e68 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1e68:	df 93       	push	r29
    1e6a:	cf 93       	push	r28
    1e6c:	00 d0       	rcall	.+0      	; 0x1e6e <xTaskResumeAll+0x6>
    1e6e:	00 d0       	rcall	.+0      	; 0x1e70 <xTaskResumeAll+0x8>
    1e70:	cd b7       	in	r28, 0x3d	; 61
    1e72:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1e74:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1e76:	0f b6       	in	r0, 0x3f	; 63
    1e78:	f8 94       	cli
    1e7a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1e7c:	80 91 18 03 	lds	r24, 0x0318
    1e80:	81 50       	subi	r24, 0x01	; 1
    1e82:	80 93 18 03 	sts	0x0318, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1e86:	80 91 18 03 	lds	r24, 0x0318
    1e8a:	88 23       	and	r24, r24
    1e8c:	09 f0       	breq	.+2      	; 0x1e90 <xTaskResumeAll+0x28>
    1e8e:	6c c0       	rjmp	.+216    	; 0x1f68 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1e90:	80 91 12 03 	lds	r24, 0x0312
    1e94:	88 23       	and	r24, r24
    1e96:	09 f4       	brne	.+2      	; 0x1e9a <xTaskResumeAll+0x32>
    1e98:	67 c0       	rjmp	.+206    	; 0x1f68 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    1e9a:	19 82       	std	Y+1, r1	; 0x01
    1e9c:	41 c0       	rjmp	.+130    	; 0x1f20 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1e9e:	e0 91 65 03 	lds	r30, 0x0365
    1ea2:	f0 91 66 03 	lds	r31, 0x0366
    1ea6:	86 81       	ldd	r24, Z+6	; 0x06
    1ea8:	97 81       	ldd	r25, Z+7	; 0x07
    1eaa:	9c 83       	std	Y+4, r25	; 0x04
    1eac:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    1eae:	8b 81       	ldd	r24, Y+3	; 0x03
    1eb0:	9c 81       	ldd	r25, Y+4	; 0x04
    1eb2:	0c 96       	adiw	r24, 0x0c	; 12
    1eb4:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1eb8:	8b 81       	ldd	r24, Y+3	; 0x03
    1eba:	9c 81       	ldd	r25, Y+4	; 0x04
    1ebc:	02 96       	adiw	r24, 0x02	; 2
    1ebe:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1ec2:	eb 81       	ldd	r30, Y+3	; 0x03
    1ec4:	fc 81       	ldd	r31, Y+4	; 0x04
    1ec6:	96 89       	ldd	r25, Z+22	; 0x16
    1ec8:	80 91 16 03 	lds	r24, 0x0316
    1ecc:	89 17       	cp	r24, r25
    1ece:	28 f4       	brcc	.+10     	; 0x1eda <xTaskResumeAll+0x72>
    1ed0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ed2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ed4:	86 89       	ldd	r24, Z+22	; 0x16
    1ed6:	80 93 16 03 	sts	0x0316, r24
    1eda:	eb 81       	ldd	r30, Y+3	; 0x03
    1edc:	fc 81       	ldd	r31, Y+4	; 0x04
    1ede:	86 89       	ldd	r24, Z+22	; 0x16
    1ee0:	28 2f       	mov	r18, r24
    1ee2:	30 e0       	ldi	r19, 0x00	; 0
    1ee4:	c9 01       	movw	r24, r18
    1ee6:	88 0f       	add	r24, r24
    1ee8:	99 1f       	adc	r25, r25
    1eea:	88 0f       	add	r24, r24
    1eec:	99 1f       	adc	r25, r25
    1eee:	88 0f       	add	r24, r24
    1ef0:	99 1f       	adc	r25, r25
    1ef2:	82 0f       	add	r24, r18
    1ef4:	93 1f       	adc	r25, r19
    1ef6:	83 5e       	subi	r24, 0xE3	; 227
    1ef8:	9c 4f       	sbci	r25, 0xFC	; 252
    1efa:	2b 81       	ldd	r18, Y+3	; 0x03
    1efc:	3c 81       	ldd	r19, Y+4	; 0x04
    1efe:	2e 5f       	subi	r18, 0xFE	; 254
    1f00:	3f 4f       	sbci	r19, 0xFF	; 255
    1f02:	b9 01       	movw	r22, r18
    1f04:	0e 94 98 04 	call	0x930	; 0x930 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1f08:	eb 81       	ldd	r30, Y+3	; 0x03
    1f0a:	fc 81       	ldd	r31, Y+4	; 0x04
    1f0c:	96 89       	ldd	r25, Z+22	; 0x16
    1f0e:	e0 91 0f 03 	lds	r30, 0x030F
    1f12:	f0 91 10 03 	lds	r31, 0x0310
    1f16:	86 89       	ldd	r24, Z+22	; 0x16
    1f18:	98 17       	cp	r25, r24
    1f1a:	10 f0       	brcs	.+4      	; 0x1f20 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    1f1c:	81 e0       	ldi	r24, 0x01	; 1
    1f1e:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1f20:	80 91 60 03 	lds	r24, 0x0360
    1f24:	88 23       	and	r24, r24
    1f26:	09 f0       	breq	.+2      	; 0x1f2a <xTaskResumeAll+0xc2>
    1f28:	ba cf       	rjmp	.-140    	; 0x1e9e <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1f2a:	80 91 19 03 	lds	r24, 0x0319
    1f2e:	88 23       	and	r24, r24
    1f30:	71 f0       	breq	.+28     	; 0x1f4e <xTaskResumeAll+0xe6>
    1f32:	07 c0       	rjmp	.+14     	; 0x1f42 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    1f34:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <vTaskIncrementTick>
						--uxMissedTicks;
    1f38:	80 91 19 03 	lds	r24, 0x0319
    1f3c:	81 50       	subi	r24, 0x01	; 1
    1f3e:	80 93 19 03 	sts	0x0319, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1f42:	80 91 19 03 	lds	r24, 0x0319
    1f46:	88 23       	and	r24, r24
    1f48:	a9 f7       	brne	.-22     	; 0x1f34 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    1f4a:	81 e0       	ldi	r24, 0x01	; 1
    1f4c:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1f4e:	89 81       	ldd	r24, Y+1	; 0x01
    1f50:	81 30       	cpi	r24, 0x01	; 1
    1f52:	21 f0       	breq	.+8      	; 0x1f5c <xTaskResumeAll+0xf4>
    1f54:	80 91 1a 03 	lds	r24, 0x031A
    1f58:	81 30       	cpi	r24, 0x01	; 1
    1f5a:	31 f4       	brne	.+12     	; 0x1f68 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    1f5c:	81 e0       	ldi	r24, 0x01	; 1
    1f5e:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    1f60:	10 92 1a 03 	sts	0x031A, r1
					portYIELD_WITHIN_API();
    1f64:	0e 94 58 07 	call	0xeb0	; 0xeb0 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1f68:	0f 90       	pop	r0
    1f6a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    1f6c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1f6e:	0f 90       	pop	r0
    1f70:	0f 90       	pop	r0
    1f72:	0f 90       	pop	r0
    1f74:	0f 90       	pop	r0
    1f76:	cf 91       	pop	r28
    1f78:	df 91       	pop	r29
    1f7a:	08 95       	ret

00001f7c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    1f7c:	df 93       	push	r29
    1f7e:	cf 93       	push	r28
    1f80:	00 d0       	rcall	.+0      	; 0x1f82 <xTaskGetTickCount+0x6>
    1f82:	cd b7       	in	r28, 0x3d	; 61
    1f84:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1f86:	0f b6       	in	r0, 0x3f	; 63
    1f88:	f8 94       	cli
    1f8a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1f8c:	80 91 13 03 	lds	r24, 0x0313
    1f90:	90 91 14 03 	lds	r25, 0x0314
    1f94:	9a 83       	std	Y+2, r25	; 0x02
    1f96:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1f98:	0f 90       	pop	r0
    1f9a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    1f9c:	89 81       	ldd	r24, Y+1	; 0x01
    1f9e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1fa0:	0f 90       	pop	r0
    1fa2:	0f 90       	pop	r0
    1fa4:	cf 91       	pop	r28
    1fa6:	df 91       	pop	r29
    1fa8:	08 95       	ret

00001faa <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    1faa:	df 93       	push	r29
    1fac:	cf 93       	push	r28
    1fae:	00 d0       	rcall	.+0      	; 0x1fb0 <xTaskGetTickCountFromISR+0x6>
    1fb0:	0f 92       	push	r0
    1fb2:	cd b7       	in	r28, 0x3d	; 61
    1fb4:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1fb6:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    1fb8:	80 91 13 03 	lds	r24, 0x0313
    1fbc:	90 91 14 03 	lds	r25, 0x0314
    1fc0:	9b 83       	std	Y+3, r25	; 0x03
    1fc2:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1fc4:	8a 81       	ldd	r24, Y+2	; 0x02
    1fc6:	9b 81       	ldd	r25, Y+3	; 0x03
}
    1fc8:	0f 90       	pop	r0
    1fca:	0f 90       	pop	r0
    1fcc:	0f 90       	pop	r0
    1fce:	cf 91       	pop	r28
    1fd0:	df 91       	pop	r29
    1fd2:	08 95       	ret

00001fd4 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    1fd4:	df 93       	push	r29
    1fd6:	cf 93       	push	r28
    1fd8:	cd b7       	in	r28, 0x3d	; 61
    1fda:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1fdc:	80 91 12 03 	lds	r24, 0x0312
}
    1fe0:	cf 91       	pop	r28
    1fe2:	df 91       	pop	r29
    1fe4:	08 95       	ret

00001fe6 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1fe6:	df 93       	push	r29
    1fe8:	cf 93       	push	r28
    1fea:	00 d0       	rcall	.+0      	; 0x1fec <vTaskIncrementTick+0x6>
    1fec:	00 d0       	rcall	.+0      	; 0x1fee <vTaskIncrementTick+0x8>
    1fee:	00 d0       	rcall	.+0      	; 0x1ff0 <vTaskIncrementTick+0xa>
    1ff0:	cd b7       	in	r28, 0x3d	; 61
    1ff2:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1ff4:	80 91 18 03 	lds	r24, 0x0318
    1ff8:	88 23       	and	r24, r24
    1ffa:	09 f0       	breq	.+2      	; 0x1ffe <vTaskIncrementTick+0x18>
    1ffc:	bb c0       	rjmp	.+374    	; 0x2174 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    1ffe:	80 91 13 03 	lds	r24, 0x0313
    2002:	90 91 14 03 	lds	r25, 0x0314
    2006:	01 96       	adiw	r24, 0x01	; 1
    2008:	90 93 14 03 	sts	0x0314, r25
    200c:	80 93 13 03 	sts	0x0313, r24
		if( xTickCount == ( portTickType ) 0U )
    2010:	80 91 13 03 	lds	r24, 0x0313
    2014:	90 91 14 03 	lds	r25, 0x0314
    2018:	00 97       	sbiw	r24, 0x00	; 0
    201a:	d1 f5       	brne	.+116    	; 0x2090 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    201c:	80 91 5c 03 	lds	r24, 0x035C
    2020:	90 91 5d 03 	lds	r25, 0x035D
    2024:	9c 83       	std	Y+4, r25	; 0x04
    2026:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2028:	80 91 5e 03 	lds	r24, 0x035E
    202c:	90 91 5f 03 	lds	r25, 0x035F
    2030:	90 93 5d 03 	sts	0x035D, r25
    2034:	80 93 5c 03 	sts	0x035C, r24
			pxOverflowDelayedTaskList = pxTemp;
    2038:	8b 81       	ldd	r24, Y+3	; 0x03
    203a:	9c 81       	ldd	r25, Y+4	; 0x04
    203c:	90 93 5f 03 	sts	0x035F, r25
    2040:	80 93 5e 03 	sts	0x035E, r24
			xNumOfOverflows++;
    2044:	80 91 1b 03 	lds	r24, 0x031B
    2048:	8f 5f       	subi	r24, 0xFF	; 255
    204a:	80 93 1b 03 	sts	0x031B, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    204e:	e0 91 5c 03 	lds	r30, 0x035C
    2052:	f0 91 5d 03 	lds	r31, 0x035D
    2056:	80 81       	ld	r24, Z
    2058:	88 23       	and	r24, r24
    205a:	39 f4       	brne	.+14     	; 0x206a <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    205c:	8f ef       	ldi	r24, 0xFF	; 255
    205e:	9f ef       	ldi	r25, 0xFF	; 255
    2060:	90 93 78 00 	sts	0x0078, r25
    2064:	80 93 77 00 	sts	0x0077, r24
    2068:	13 c0       	rjmp	.+38     	; 0x2090 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    206a:	e0 91 5c 03 	lds	r30, 0x035C
    206e:	f0 91 5d 03 	lds	r31, 0x035D
    2072:	05 80       	ldd	r0, Z+5	; 0x05
    2074:	f6 81       	ldd	r31, Z+6	; 0x06
    2076:	e0 2d       	mov	r30, r0
    2078:	86 81       	ldd	r24, Z+6	; 0x06
    207a:	97 81       	ldd	r25, Z+7	; 0x07
    207c:	9e 83       	std	Y+6, r25	; 0x06
    207e:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2080:	ed 81       	ldd	r30, Y+5	; 0x05
    2082:	fe 81       	ldd	r31, Y+6	; 0x06
    2084:	82 81       	ldd	r24, Z+2	; 0x02
    2086:	93 81       	ldd	r25, Z+3	; 0x03
    2088:	90 93 78 00 	sts	0x0078, r25
    208c:	80 93 77 00 	sts	0x0077, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2090:	20 91 13 03 	lds	r18, 0x0313
    2094:	30 91 14 03 	lds	r19, 0x0314
    2098:	80 91 77 00 	lds	r24, 0x0077
    209c:	90 91 78 00 	lds	r25, 0x0078
    20a0:	28 17       	cp	r18, r24
    20a2:	39 07       	cpc	r19, r25
    20a4:	08 f4       	brcc	.+2      	; 0x20a8 <vTaskIncrementTick+0xc2>
    20a6:	6b c0       	rjmp	.+214    	; 0x217e <vTaskIncrementTick+0x198>
    20a8:	e0 91 5c 03 	lds	r30, 0x035C
    20ac:	f0 91 5d 03 	lds	r31, 0x035D
    20b0:	80 81       	ld	r24, Z
    20b2:	88 23       	and	r24, r24
    20b4:	39 f4       	brne	.+14     	; 0x20c4 <vTaskIncrementTick+0xde>
    20b6:	8f ef       	ldi	r24, 0xFF	; 255
    20b8:	9f ef       	ldi	r25, 0xFF	; 255
    20ba:	90 93 78 00 	sts	0x0078, r25
    20be:	80 93 77 00 	sts	0x0077, r24
    20c2:	5d c0       	rjmp	.+186    	; 0x217e <vTaskIncrementTick+0x198>
    20c4:	e0 91 5c 03 	lds	r30, 0x035C
    20c8:	f0 91 5d 03 	lds	r31, 0x035D
    20cc:	05 80       	ldd	r0, Z+5	; 0x05
    20ce:	f6 81       	ldd	r31, Z+6	; 0x06
    20d0:	e0 2d       	mov	r30, r0
    20d2:	86 81       	ldd	r24, Z+6	; 0x06
    20d4:	97 81       	ldd	r25, Z+7	; 0x07
    20d6:	9e 83       	std	Y+6, r25	; 0x06
    20d8:	8d 83       	std	Y+5, r24	; 0x05
    20da:	ed 81       	ldd	r30, Y+5	; 0x05
    20dc:	fe 81       	ldd	r31, Y+6	; 0x06
    20de:	82 81       	ldd	r24, Z+2	; 0x02
    20e0:	93 81       	ldd	r25, Z+3	; 0x03
    20e2:	9a 83       	std	Y+2, r25	; 0x02
    20e4:	89 83       	std	Y+1, r24	; 0x01
    20e6:	20 91 13 03 	lds	r18, 0x0313
    20ea:	30 91 14 03 	lds	r19, 0x0314
    20ee:	89 81       	ldd	r24, Y+1	; 0x01
    20f0:	9a 81       	ldd	r25, Y+2	; 0x02
    20f2:	28 17       	cp	r18, r24
    20f4:	39 07       	cpc	r19, r25
    20f6:	38 f4       	brcc	.+14     	; 0x2106 <vTaskIncrementTick+0x120>
    20f8:	89 81       	ldd	r24, Y+1	; 0x01
    20fa:	9a 81       	ldd	r25, Y+2	; 0x02
    20fc:	90 93 78 00 	sts	0x0078, r25
    2100:	80 93 77 00 	sts	0x0077, r24
    2104:	3c c0       	rjmp	.+120    	; 0x217e <vTaskIncrementTick+0x198>
    2106:	8d 81       	ldd	r24, Y+5	; 0x05
    2108:	9e 81       	ldd	r25, Y+6	; 0x06
    210a:	02 96       	adiw	r24, 0x02	; 2
    210c:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vListRemove>
    2110:	ed 81       	ldd	r30, Y+5	; 0x05
    2112:	fe 81       	ldd	r31, Y+6	; 0x06
    2114:	84 89       	ldd	r24, Z+20	; 0x14
    2116:	95 89       	ldd	r25, Z+21	; 0x15
    2118:	00 97       	sbiw	r24, 0x00	; 0
    211a:	29 f0       	breq	.+10     	; 0x2126 <vTaskIncrementTick+0x140>
    211c:	8d 81       	ldd	r24, Y+5	; 0x05
    211e:	9e 81       	ldd	r25, Y+6	; 0x06
    2120:	0c 96       	adiw	r24, 0x0c	; 12
    2122:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vListRemove>
    2126:	ed 81       	ldd	r30, Y+5	; 0x05
    2128:	fe 81       	ldd	r31, Y+6	; 0x06
    212a:	96 89       	ldd	r25, Z+22	; 0x16
    212c:	80 91 16 03 	lds	r24, 0x0316
    2130:	89 17       	cp	r24, r25
    2132:	28 f4       	brcc	.+10     	; 0x213e <vTaskIncrementTick+0x158>
    2134:	ed 81       	ldd	r30, Y+5	; 0x05
    2136:	fe 81       	ldd	r31, Y+6	; 0x06
    2138:	86 89       	ldd	r24, Z+22	; 0x16
    213a:	80 93 16 03 	sts	0x0316, r24
    213e:	ed 81       	ldd	r30, Y+5	; 0x05
    2140:	fe 81       	ldd	r31, Y+6	; 0x06
    2142:	86 89       	ldd	r24, Z+22	; 0x16
    2144:	28 2f       	mov	r18, r24
    2146:	30 e0       	ldi	r19, 0x00	; 0
    2148:	c9 01       	movw	r24, r18
    214a:	88 0f       	add	r24, r24
    214c:	99 1f       	adc	r25, r25
    214e:	88 0f       	add	r24, r24
    2150:	99 1f       	adc	r25, r25
    2152:	88 0f       	add	r24, r24
    2154:	99 1f       	adc	r25, r25
    2156:	82 0f       	add	r24, r18
    2158:	93 1f       	adc	r25, r19
    215a:	ac 01       	movw	r20, r24
    215c:	43 5e       	subi	r20, 0xE3	; 227
    215e:	5c 4f       	sbci	r21, 0xFC	; 252
    2160:	8d 81       	ldd	r24, Y+5	; 0x05
    2162:	9e 81       	ldd	r25, Y+6	; 0x06
    2164:	9c 01       	movw	r18, r24
    2166:	2e 5f       	subi	r18, 0xFE	; 254
    2168:	3f 4f       	sbci	r19, 0xFF	; 255
    216a:	ca 01       	movw	r24, r20
    216c:	b9 01       	movw	r22, r18
    216e:	0e 94 98 04 	call	0x930	; 0x930 <vListInsertEnd>
    2172:	9a cf       	rjmp	.-204    	; 0x20a8 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    2174:	80 91 19 03 	lds	r24, 0x0319
    2178:	8f 5f       	subi	r24, 0xFF	; 255
    217a:	80 93 19 03 	sts	0x0319, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    217e:	26 96       	adiw	r28, 0x06	; 6
    2180:	0f b6       	in	r0, 0x3f	; 63
    2182:	f8 94       	cli
    2184:	de bf       	out	0x3e, r29	; 62
    2186:	0f be       	out	0x3f, r0	; 63
    2188:	cd bf       	out	0x3d, r28	; 61
    218a:	cf 91       	pop	r28
    218c:	df 91       	pop	r29
    218e:	08 95       	ret

00002190 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2190:	df 93       	push	r29
    2192:	cf 93       	push	r28
    2194:	00 d0       	rcall	.+0      	; 0x2196 <vTaskSwitchContext+0x6>
    2196:	cd b7       	in	r28, 0x3d	; 61
    2198:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    219a:	80 91 18 03 	lds	r24, 0x0318
    219e:	88 23       	and	r24, r24
    21a0:	49 f0       	breq	.+18     	; 0x21b4 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    21a2:	81 e0       	ldi	r24, 0x01	; 1
    21a4:	80 93 1a 03 	sts	0x031A, r24
    21a8:	54 c0       	rjmp	.+168    	; 0x2252 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    21aa:	80 91 16 03 	lds	r24, 0x0316
    21ae:	81 50       	subi	r24, 0x01	; 1
    21b0:	80 93 16 03 	sts	0x0316, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    21b4:	80 91 16 03 	lds	r24, 0x0316
    21b8:	28 2f       	mov	r18, r24
    21ba:	30 e0       	ldi	r19, 0x00	; 0
    21bc:	c9 01       	movw	r24, r18
    21be:	88 0f       	add	r24, r24
    21c0:	99 1f       	adc	r25, r25
    21c2:	88 0f       	add	r24, r24
    21c4:	99 1f       	adc	r25, r25
    21c6:	88 0f       	add	r24, r24
    21c8:	99 1f       	adc	r25, r25
    21ca:	82 0f       	add	r24, r18
    21cc:	93 1f       	adc	r25, r19
    21ce:	fc 01       	movw	r30, r24
    21d0:	e3 5e       	subi	r30, 0xE3	; 227
    21d2:	fc 4f       	sbci	r31, 0xFC	; 252
    21d4:	80 81       	ld	r24, Z
    21d6:	88 23       	and	r24, r24
    21d8:	41 f3       	breq	.-48     	; 0x21aa <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    21da:	80 91 16 03 	lds	r24, 0x0316
    21de:	28 2f       	mov	r18, r24
    21e0:	30 e0       	ldi	r19, 0x00	; 0
    21e2:	c9 01       	movw	r24, r18
    21e4:	88 0f       	add	r24, r24
    21e6:	99 1f       	adc	r25, r25
    21e8:	88 0f       	add	r24, r24
    21ea:	99 1f       	adc	r25, r25
    21ec:	88 0f       	add	r24, r24
    21ee:	99 1f       	adc	r25, r25
    21f0:	82 0f       	add	r24, r18
    21f2:	93 1f       	adc	r25, r19
    21f4:	83 5e       	subi	r24, 0xE3	; 227
    21f6:	9c 4f       	sbci	r25, 0xFC	; 252
    21f8:	9a 83       	std	Y+2, r25	; 0x02
    21fa:	89 83       	std	Y+1, r24	; 0x01
    21fc:	e9 81       	ldd	r30, Y+1	; 0x01
    21fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2200:	01 80       	ldd	r0, Z+1	; 0x01
    2202:	f2 81       	ldd	r31, Z+2	; 0x02
    2204:	e0 2d       	mov	r30, r0
    2206:	82 81       	ldd	r24, Z+2	; 0x02
    2208:	93 81       	ldd	r25, Z+3	; 0x03
    220a:	e9 81       	ldd	r30, Y+1	; 0x01
    220c:	fa 81       	ldd	r31, Y+2	; 0x02
    220e:	92 83       	std	Z+2, r25	; 0x02
    2210:	81 83       	std	Z+1, r24	; 0x01
    2212:	e9 81       	ldd	r30, Y+1	; 0x01
    2214:	fa 81       	ldd	r31, Y+2	; 0x02
    2216:	21 81       	ldd	r18, Z+1	; 0x01
    2218:	32 81       	ldd	r19, Z+2	; 0x02
    221a:	89 81       	ldd	r24, Y+1	; 0x01
    221c:	9a 81       	ldd	r25, Y+2	; 0x02
    221e:	03 96       	adiw	r24, 0x03	; 3
    2220:	28 17       	cp	r18, r24
    2222:	39 07       	cpc	r19, r25
    2224:	59 f4       	brne	.+22     	; 0x223c <vTaskSwitchContext+0xac>
    2226:	e9 81       	ldd	r30, Y+1	; 0x01
    2228:	fa 81       	ldd	r31, Y+2	; 0x02
    222a:	01 80       	ldd	r0, Z+1	; 0x01
    222c:	f2 81       	ldd	r31, Z+2	; 0x02
    222e:	e0 2d       	mov	r30, r0
    2230:	82 81       	ldd	r24, Z+2	; 0x02
    2232:	93 81       	ldd	r25, Z+3	; 0x03
    2234:	e9 81       	ldd	r30, Y+1	; 0x01
    2236:	fa 81       	ldd	r31, Y+2	; 0x02
    2238:	92 83       	std	Z+2, r25	; 0x02
    223a:	81 83       	std	Z+1, r24	; 0x01
    223c:	e9 81       	ldd	r30, Y+1	; 0x01
    223e:	fa 81       	ldd	r31, Y+2	; 0x02
    2240:	01 80       	ldd	r0, Z+1	; 0x01
    2242:	f2 81       	ldd	r31, Z+2	; 0x02
    2244:	e0 2d       	mov	r30, r0
    2246:	86 81       	ldd	r24, Z+6	; 0x06
    2248:	97 81       	ldd	r25, Z+7	; 0x07
    224a:	90 93 10 03 	sts	0x0310, r25
    224e:	80 93 0f 03 	sts	0x030F, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    2252:	0f 90       	pop	r0
    2254:	0f 90       	pop	r0
    2256:	cf 91       	pop	r28
    2258:	df 91       	pop	r29
    225a:	08 95       	ret

0000225c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    225c:	df 93       	push	r29
    225e:	cf 93       	push	r28
    2260:	00 d0       	rcall	.+0      	; 0x2262 <vTaskPlaceOnEventList+0x6>
    2262:	00 d0       	rcall	.+0      	; 0x2264 <vTaskPlaceOnEventList+0x8>
    2264:	00 d0       	rcall	.+0      	; 0x2266 <vTaskPlaceOnEventList+0xa>
    2266:	cd b7       	in	r28, 0x3d	; 61
    2268:	de b7       	in	r29, 0x3e	; 62
    226a:	9c 83       	std	Y+4, r25	; 0x04
    226c:	8b 83       	std	Y+3, r24	; 0x03
    226e:	7e 83       	std	Y+6, r23	; 0x06
    2270:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2272:	4b 81       	ldd	r20, Y+3	; 0x03
    2274:	5c 81       	ldd	r21, Y+4	; 0x04
    2276:	80 91 0f 03 	lds	r24, 0x030F
    227a:	90 91 10 03 	lds	r25, 0x0310
    227e:	9c 01       	movw	r18, r24
    2280:	24 5f       	subi	r18, 0xF4	; 244
    2282:	3f 4f       	sbci	r19, 0xFF	; 255
    2284:	ca 01       	movw	r24, r20
    2286:	b9 01       	movw	r22, r18
    2288:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    228c:	80 91 0f 03 	lds	r24, 0x030F
    2290:	90 91 10 03 	lds	r25, 0x0310
    2294:	02 96       	adiw	r24, 0x02	; 2
    2296:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    229a:	20 91 13 03 	lds	r18, 0x0313
    229e:	30 91 14 03 	lds	r19, 0x0314
    22a2:	8d 81       	ldd	r24, Y+5	; 0x05
    22a4:	9e 81       	ldd	r25, Y+6	; 0x06
    22a6:	82 0f       	add	r24, r18
    22a8:	93 1f       	adc	r25, r19
    22aa:	9a 83       	std	Y+2, r25	; 0x02
    22ac:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    22ae:	89 81       	ldd	r24, Y+1	; 0x01
    22b0:	9a 81       	ldd	r25, Y+2	; 0x02
    22b2:	0e 94 28 13 	call	0x2650	; 0x2650 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    22b6:	26 96       	adiw	r28, 0x06	; 6
    22b8:	0f b6       	in	r0, 0x3f	; 63
    22ba:	f8 94       	cli
    22bc:	de bf       	out	0x3e, r29	; 62
    22be:	0f be       	out	0x3f, r0	; 63
    22c0:	cd bf       	out	0x3d, r28	; 61
    22c2:	cf 91       	pop	r28
    22c4:	df 91       	pop	r29
    22c6:	08 95       	ret

000022c8 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    22c8:	df 93       	push	r29
    22ca:	cf 93       	push	r28
    22cc:	00 d0       	rcall	.+0      	; 0x22ce <xTaskRemoveFromEventList+0x6>
    22ce:	00 d0       	rcall	.+0      	; 0x22d0 <xTaskRemoveFromEventList+0x8>
    22d0:	0f 92       	push	r0
    22d2:	cd b7       	in	r28, 0x3d	; 61
    22d4:	de b7       	in	r29, 0x3e	; 62
    22d6:	9d 83       	std	Y+5, r25	; 0x05
    22d8:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    22da:	ec 81       	ldd	r30, Y+4	; 0x04
    22dc:	fd 81       	ldd	r31, Y+5	; 0x05
    22de:	05 80       	ldd	r0, Z+5	; 0x05
    22e0:	f6 81       	ldd	r31, Z+6	; 0x06
    22e2:	e0 2d       	mov	r30, r0
    22e4:	86 81       	ldd	r24, Z+6	; 0x06
    22e6:	97 81       	ldd	r25, Z+7	; 0x07
    22e8:	9b 83       	std	Y+3, r25	; 0x03
    22ea:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    22ec:	8a 81       	ldd	r24, Y+2	; 0x02
    22ee:	9b 81       	ldd	r25, Y+3	; 0x03
    22f0:	0c 96       	adiw	r24, 0x0c	; 12
    22f2:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    22f6:	80 91 18 03 	lds	r24, 0x0318
    22fa:	88 23       	and	r24, r24
    22fc:	61 f5       	brne	.+88     	; 0x2356 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    22fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2300:	9b 81       	ldd	r25, Y+3	; 0x03
    2302:	02 96       	adiw	r24, 0x02	; 2
    2304:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2308:	ea 81       	ldd	r30, Y+2	; 0x02
    230a:	fb 81       	ldd	r31, Y+3	; 0x03
    230c:	96 89       	ldd	r25, Z+22	; 0x16
    230e:	80 91 16 03 	lds	r24, 0x0316
    2312:	89 17       	cp	r24, r25
    2314:	28 f4       	brcc	.+10     	; 0x2320 <xTaskRemoveFromEventList+0x58>
    2316:	ea 81       	ldd	r30, Y+2	; 0x02
    2318:	fb 81       	ldd	r31, Y+3	; 0x03
    231a:	86 89       	ldd	r24, Z+22	; 0x16
    231c:	80 93 16 03 	sts	0x0316, r24
    2320:	ea 81       	ldd	r30, Y+2	; 0x02
    2322:	fb 81       	ldd	r31, Y+3	; 0x03
    2324:	86 89       	ldd	r24, Z+22	; 0x16
    2326:	28 2f       	mov	r18, r24
    2328:	30 e0       	ldi	r19, 0x00	; 0
    232a:	c9 01       	movw	r24, r18
    232c:	88 0f       	add	r24, r24
    232e:	99 1f       	adc	r25, r25
    2330:	88 0f       	add	r24, r24
    2332:	99 1f       	adc	r25, r25
    2334:	88 0f       	add	r24, r24
    2336:	99 1f       	adc	r25, r25
    2338:	82 0f       	add	r24, r18
    233a:	93 1f       	adc	r25, r19
    233c:	ac 01       	movw	r20, r24
    233e:	43 5e       	subi	r20, 0xE3	; 227
    2340:	5c 4f       	sbci	r21, 0xFC	; 252
    2342:	8a 81       	ldd	r24, Y+2	; 0x02
    2344:	9b 81       	ldd	r25, Y+3	; 0x03
    2346:	9c 01       	movw	r18, r24
    2348:	2e 5f       	subi	r18, 0xFE	; 254
    234a:	3f 4f       	sbci	r19, 0xFF	; 255
    234c:	ca 01       	movw	r24, r20
    234e:	b9 01       	movw	r22, r18
    2350:	0e 94 98 04 	call	0x930	; 0x930 <vListInsertEnd>
    2354:	0a c0       	rjmp	.+20     	; 0x236a <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2356:	8a 81       	ldd	r24, Y+2	; 0x02
    2358:	9b 81       	ldd	r25, Y+3	; 0x03
    235a:	9c 01       	movw	r18, r24
    235c:	24 5f       	subi	r18, 0xF4	; 244
    235e:	3f 4f       	sbci	r19, 0xFF	; 255
    2360:	80 e6       	ldi	r24, 0x60	; 96
    2362:	93 e0       	ldi	r25, 0x03	; 3
    2364:	b9 01       	movw	r22, r18
    2366:	0e 94 98 04 	call	0x930	; 0x930 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    236a:	ea 81       	ldd	r30, Y+2	; 0x02
    236c:	fb 81       	ldd	r31, Y+3	; 0x03
    236e:	96 89       	ldd	r25, Z+22	; 0x16
    2370:	e0 91 0f 03 	lds	r30, 0x030F
    2374:	f0 91 10 03 	lds	r31, 0x0310
    2378:	86 89       	ldd	r24, Z+22	; 0x16
    237a:	98 17       	cp	r25, r24
    237c:	18 f0       	brcs	.+6      	; 0x2384 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    237e:	81 e0       	ldi	r24, 0x01	; 1
    2380:	89 83       	std	Y+1, r24	; 0x01
    2382:	01 c0       	rjmp	.+2      	; 0x2386 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    2384:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2386:	89 81       	ldd	r24, Y+1	; 0x01
}
    2388:	0f 90       	pop	r0
    238a:	0f 90       	pop	r0
    238c:	0f 90       	pop	r0
    238e:	0f 90       	pop	r0
    2390:	0f 90       	pop	r0
    2392:	cf 91       	pop	r28
    2394:	df 91       	pop	r29
    2396:	08 95       	ret

00002398 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2398:	df 93       	push	r29
    239a:	cf 93       	push	r28
    239c:	00 d0       	rcall	.+0      	; 0x239e <vTaskSetTimeOutState+0x6>
    239e:	cd b7       	in	r28, 0x3d	; 61
    23a0:	de b7       	in	r29, 0x3e	; 62
    23a2:	9a 83       	std	Y+2, r25	; 0x02
    23a4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    23a6:	80 91 1b 03 	lds	r24, 0x031B
    23aa:	e9 81       	ldd	r30, Y+1	; 0x01
    23ac:	fa 81       	ldd	r31, Y+2	; 0x02
    23ae:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    23b0:	80 91 13 03 	lds	r24, 0x0313
    23b4:	90 91 14 03 	lds	r25, 0x0314
    23b8:	e9 81       	ldd	r30, Y+1	; 0x01
    23ba:	fa 81       	ldd	r31, Y+2	; 0x02
    23bc:	92 83       	std	Z+2, r25	; 0x02
    23be:	81 83       	std	Z+1, r24	; 0x01
}
    23c0:	0f 90       	pop	r0
    23c2:	0f 90       	pop	r0
    23c4:	cf 91       	pop	r28
    23c6:	df 91       	pop	r29
    23c8:	08 95       	ret

000023ca <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    23ca:	df 93       	push	r29
    23cc:	cf 93       	push	r28
    23ce:	00 d0       	rcall	.+0      	; 0x23d0 <xTaskCheckForTimeOut+0x6>
    23d0:	00 d0       	rcall	.+0      	; 0x23d2 <xTaskCheckForTimeOut+0x8>
    23d2:	0f 92       	push	r0
    23d4:	cd b7       	in	r28, 0x3d	; 61
    23d6:	de b7       	in	r29, 0x3e	; 62
    23d8:	9b 83       	std	Y+3, r25	; 0x03
    23da:	8a 83       	std	Y+2, r24	; 0x02
    23dc:	7d 83       	std	Y+5, r23	; 0x05
    23de:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    23e0:	0f b6       	in	r0, 0x3f	; 63
    23e2:	f8 94       	cli
    23e4:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    23e6:	ea 81       	ldd	r30, Y+2	; 0x02
    23e8:	fb 81       	ldd	r31, Y+3	; 0x03
    23ea:	90 81       	ld	r25, Z
    23ec:	80 91 1b 03 	lds	r24, 0x031B
    23f0:	98 17       	cp	r25, r24
    23f2:	71 f0       	breq	.+28     	; 0x2410 <xTaskCheckForTimeOut+0x46>
    23f4:	ea 81       	ldd	r30, Y+2	; 0x02
    23f6:	fb 81       	ldd	r31, Y+3	; 0x03
    23f8:	21 81       	ldd	r18, Z+1	; 0x01
    23fa:	32 81       	ldd	r19, Z+2	; 0x02
    23fc:	80 91 13 03 	lds	r24, 0x0313
    2400:	90 91 14 03 	lds	r25, 0x0314
    2404:	82 17       	cp	r24, r18
    2406:	93 07       	cpc	r25, r19
    2408:	18 f0       	brcs	.+6      	; 0x2410 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    240a:	81 e0       	ldi	r24, 0x01	; 1
    240c:	89 83       	std	Y+1, r24	; 0x01
    240e:	2f c0       	rjmp	.+94     	; 0x246e <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2410:	20 91 13 03 	lds	r18, 0x0313
    2414:	30 91 14 03 	lds	r19, 0x0314
    2418:	ea 81       	ldd	r30, Y+2	; 0x02
    241a:	fb 81       	ldd	r31, Y+3	; 0x03
    241c:	81 81       	ldd	r24, Z+1	; 0x01
    241e:	92 81       	ldd	r25, Z+2	; 0x02
    2420:	28 1b       	sub	r18, r24
    2422:	39 0b       	sbc	r19, r25
    2424:	ec 81       	ldd	r30, Y+4	; 0x04
    2426:	fd 81       	ldd	r31, Y+5	; 0x05
    2428:	80 81       	ld	r24, Z
    242a:	91 81       	ldd	r25, Z+1	; 0x01
    242c:	28 17       	cp	r18, r24
    242e:	39 07       	cpc	r19, r25
    2430:	e0 f4       	brcc	.+56     	; 0x246a <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2432:	ec 81       	ldd	r30, Y+4	; 0x04
    2434:	fd 81       	ldd	r31, Y+5	; 0x05
    2436:	40 81       	ld	r20, Z
    2438:	51 81       	ldd	r21, Z+1	; 0x01
    243a:	ea 81       	ldd	r30, Y+2	; 0x02
    243c:	fb 81       	ldd	r31, Y+3	; 0x03
    243e:	21 81       	ldd	r18, Z+1	; 0x01
    2440:	32 81       	ldd	r19, Z+2	; 0x02
    2442:	80 91 13 03 	lds	r24, 0x0313
    2446:	90 91 14 03 	lds	r25, 0x0314
    244a:	b9 01       	movw	r22, r18
    244c:	68 1b       	sub	r22, r24
    244e:	79 0b       	sbc	r23, r25
    2450:	cb 01       	movw	r24, r22
    2452:	84 0f       	add	r24, r20
    2454:	95 1f       	adc	r25, r21
    2456:	ec 81       	ldd	r30, Y+4	; 0x04
    2458:	fd 81       	ldd	r31, Y+5	; 0x05
    245a:	91 83       	std	Z+1, r25	; 0x01
    245c:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    245e:	8a 81       	ldd	r24, Y+2	; 0x02
    2460:	9b 81       	ldd	r25, Y+3	; 0x03
    2462:	0e 94 cc 11 	call	0x2398	; 0x2398 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2466:	19 82       	std	Y+1, r1	; 0x01
    2468:	02 c0       	rjmp	.+4      	; 0x246e <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    246a:	81 e0       	ldi	r24, 0x01	; 1
    246c:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    246e:	0f 90       	pop	r0
    2470:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2472:	89 81       	ldd	r24, Y+1	; 0x01
}
    2474:	0f 90       	pop	r0
    2476:	0f 90       	pop	r0
    2478:	0f 90       	pop	r0
    247a:	0f 90       	pop	r0
    247c:	0f 90       	pop	r0
    247e:	cf 91       	pop	r28
    2480:	df 91       	pop	r29
    2482:	08 95       	ret

00002484 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2484:	df 93       	push	r29
    2486:	cf 93       	push	r28
    2488:	cd b7       	in	r28, 0x3d	; 61
    248a:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    248c:	81 e0       	ldi	r24, 0x01	; 1
    248e:	80 93 1a 03 	sts	0x031A, r24
}
    2492:	cf 91       	pop	r28
    2494:	df 91       	pop	r29
    2496:	08 95       	ret

00002498 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2498:	df 93       	push	r29
    249a:	cf 93       	push	r28
    249c:	00 d0       	rcall	.+0      	; 0x249e <prvIdleTask+0x6>
    249e:	cd b7       	in	r28, 0x3d	; 61
    24a0:	de b7       	in	r29, 0x3e	; 62
    24a2:	9a 83       	std	Y+2, r25	; 0x02
    24a4:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    24a6:	0e 94 ea 12 	call	0x25d4	; 0x25d4 <prvCheckTasksWaitingTermination>
    24aa:	fd cf       	rjmp	.-6      	; 0x24a6 <prvIdleTask+0xe>

000024ac <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    24ac:	0f 93       	push	r16
    24ae:	1f 93       	push	r17
    24b0:	df 93       	push	r29
    24b2:	cf 93       	push	r28
    24b4:	cd b7       	in	r28, 0x3d	; 61
    24b6:	de b7       	in	r29, 0x3e	; 62
    24b8:	29 97       	sbiw	r28, 0x09	; 9
    24ba:	0f b6       	in	r0, 0x3f	; 63
    24bc:	f8 94       	cli
    24be:	de bf       	out	0x3e, r29	; 62
    24c0:	0f be       	out	0x3f, r0	; 63
    24c2:	cd bf       	out	0x3d, r28	; 61
    24c4:	9a 83       	std	Y+2, r25	; 0x02
    24c6:	89 83       	std	Y+1, r24	; 0x01
    24c8:	7c 83       	std	Y+4, r23	; 0x04
    24ca:	6b 83       	std	Y+3, r22	; 0x03
    24cc:	4d 83       	std	Y+5, r20	; 0x05
    24ce:	3f 83       	std	Y+7, r19	; 0x07
    24d0:	2e 83       	std	Y+6, r18	; 0x06
    24d2:	19 87       	std	Y+9, r17	; 0x09
    24d4:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    24d6:	89 81       	ldd	r24, Y+1	; 0x01
    24d8:	9a 81       	ldd	r25, Y+2	; 0x02
    24da:	49 96       	adiw	r24, 0x19	; 25
    24dc:	2b 81       	ldd	r18, Y+3	; 0x03
    24de:	3c 81       	ldd	r19, Y+4	; 0x04
    24e0:	b9 01       	movw	r22, r18
    24e2:	48 e0       	ldi	r20, 0x08	; 8
    24e4:	50 e0       	ldi	r21, 0x00	; 0
    24e6:	0e 94 e7 13 	call	0x27ce	; 0x27ce <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    24ea:	e9 81       	ldd	r30, Y+1	; 0x01
    24ec:	fa 81       	ldd	r31, Y+2	; 0x02
    24ee:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    24f0:	8d 81       	ldd	r24, Y+5	; 0x05
    24f2:	85 30       	cpi	r24, 0x05	; 5
    24f4:	10 f0       	brcs	.+4      	; 0x24fa <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    24f6:	84 e0       	ldi	r24, 0x04	; 4
    24f8:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    24fa:	e9 81       	ldd	r30, Y+1	; 0x01
    24fc:	fa 81       	ldd	r31, Y+2	; 0x02
    24fe:	8d 81       	ldd	r24, Y+5	; 0x05
    2500:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2502:	89 81       	ldd	r24, Y+1	; 0x01
    2504:	9a 81       	ldd	r25, Y+2	; 0x02
    2506:	02 96       	adiw	r24, 0x02	; 2
    2508:	0e 94 88 04 	call	0x910	; 0x910 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    250c:	89 81       	ldd	r24, Y+1	; 0x01
    250e:	9a 81       	ldd	r25, Y+2	; 0x02
    2510:	0c 96       	adiw	r24, 0x0c	; 12
    2512:	0e 94 88 04 	call	0x910	; 0x910 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2516:	e9 81       	ldd	r30, Y+1	; 0x01
    2518:	fa 81       	ldd	r31, Y+2	; 0x02
    251a:	89 81       	ldd	r24, Y+1	; 0x01
    251c:	9a 81       	ldd	r25, Y+2	; 0x02
    251e:	91 87       	std	Z+9, r25	; 0x09
    2520:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2522:	8d 81       	ldd	r24, Y+5	; 0x05
    2524:	28 2f       	mov	r18, r24
    2526:	30 e0       	ldi	r19, 0x00	; 0
    2528:	85 e0       	ldi	r24, 0x05	; 5
    252a:	90 e0       	ldi	r25, 0x00	; 0
    252c:	82 1b       	sub	r24, r18
    252e:	93 0b       	sbc	r25, r19
    2530:	e9 81       	ldd	r30, Y+1	; 0x01
    2532:	fa 81       	ldd	r31, Y+2	; 0x02
    2534:	95 87       	std	Z+13, r25	; 0x0d
    2536:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2538:	e9 81       	ldd	r30, Y+1	; 0x01
    253a:	fa 81       	ldd	r31, Y+2	; 0x02
    253c:	89 81       	ldd	r24, Y+1	; 0x01
    253e:	9a 81       	ldd	r25, Y+2	; 0x02
    2540:	93 8b       	std	Z+19, r25	; 0x13
    2542:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    2544:	29 96       	adiw	r28, 0x09	; 9
    2546:	0f b6       	in	r0, 0x3f	; 63
    2548:	f8 94       	cli
    254a:	de bf       	out	0x3e, r29	; 62
    254c:	0f be       	out	0x3f, r0	; 63
    254e:	cd bf       	out	0x3d, r28	; 61
    2550:	cf 91       	pop	r28
    2552:	df 91       	pop	r29
    2554:	1f 91       	pop	r17
    2556:	0f 91       	pop	r16
    2558:	08 95       	ret

0000255a <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    255a:	df 93       	push	r29
    255c:	cf 93       	push	r28
    255e:	0f 92       	push	r0
    2560:	cd b7       	in	r28, 0x3d	; 61
    2562:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2564:	19 82       	std	Y+1, r1	; 0x01
    2566:	13 c0       	rjmp	.+38     	; 0x258e <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2568:	89 81       	ldd	r24, Y+1	; 0x01
    256a:	28 2f       	mov	r18, r24
    256c:	30 e0       	ldi	r19, 0x00	; 0
    256e:	c9 01       	movw	r24, r18
    2570:	88 0f       	add	r24, r24
    2572:	99 1f       	adc	r25, r25
    2574:	88 0f       	add	r24, r24
    2576:	99 1f       	adc	r25, r25
    2578:	88 0f       	add	r24, r24
    257a:	99 1f       	adc	r25, r25
    257c:	82 0f       	add	r24, r18
    257e:	93 1f       	adc	r25, r19
    2580:	83 5e       	subi	r24, 0xE3	; 227
    2582:	9c 4f       	sbci	r25, 0xFC	; 252
    2584:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2588:	89 81       	ldd	r24, Y+1	; 0x01
    258a:	8f 5f       	subi	r24, 0xFF	; 255
    258c:	89 83       	std	Y+1, r24	; 0x01
    258e:	89 81       	ldd	r24, Y+1	; 0x01
    2590:	85 30       	cpi	r24, 0x05	; 5
    2592:	50 f3       	brcs	.-44     	; 0x2568 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2594:	8a e4       	ldi	r24, 0x4A	; 74
    2596:	93 e0       	ldi	r25, 0x03	; 3
    2598:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    259c:	83 e5       	ldi	r24, 0x53	; 83
    259e:	93 e0       	ldi	r25, 0x03	; 3
    25a0:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    25a4:	80 e6       	ldi	r24, 0x60	; 96
    25a6:	93 e0       	ldi	r25, 0x03	; 3
    25a8:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    25ac:	89 e6       	ldi	r24, 0x69	; 105
    25ae:	93 e0       	ldi	r25, 0x03	; 3
    25b0:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    25b4:	8a e4       	ldi	r24, 0x4A	; 74
    25b6:	93 e0       	ldi	r25, 0x03	; 3
    25b8:	90 93 5d 03 	sts	0x035D, r25
    25bc:	80 93 5c 03 	sts	0x035C, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    25c0:	83 e5       	ldi	r24, 0x53	; 83
    25c2:	93 e0       	ldi	r25, 0x03	; 3
    25c4:	90 93 5f 03 	sts	0x035F, r25
    25c8:	80 93 5e 03 	sts	0x035E, r24
}
    25cc:	0f 90       	pop	r0
    25ce:	cf 91       	pop	r28
    25d0:	df 91       	pop	r29
    25d2:	08 95       	ret

000025d4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    25d4:	df 93       	push	r29
    25d6:	cf 93       	push	r28
    25d8:	00 d0       	rcall	.+0      	; 0x25da <prvCheckTasksWaitingTermination+0x6>
    25da:	0f 92       	push	r0
    25dc:	cd b7       	in	r28, 0x3d	; 61
    25de:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    25e0:	80 91 11 03 	lds	r24, 0x0311
    25e4:	88 23       	and	r24, r24
    25e6:	71 f1       	breq	.+92     	; 0x2644 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    25e8:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    25ec:	80 91 69 03 	lds	r24, 0x0369
    25f0:	1b 82       	std	Y+3, r1	; 0x03
    25f2:	88 23       	and	r24, r24
    25f4:	11 f4       	brne	.+4      	; 0x25fa <prvCheckTasksWaitingTermination+0x26>
    25f6:	81 e0       	ldi	r24, 0x01	; 1
    25f8:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    25fa:	0e 94 34 0f 	call	0x1e68	; 0x1e68 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    25fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2600:	88 23       	and	r24, r24
    2602:	01 f5       	brne	.+64     	; 0x2644 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    2604:	0f b6       	in	r0, 0x3f	; 63
    2606:	f8 94       	cli
    2608:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    260a:	e0 91 6e 03 	lds	r30, 0x036E
    260e:	f0 91 6f 03 	lds	r31, 0x036F
    2612:	86 81       	ldd	r24, Z+6	; 0x06
    2614:	97 81       	ldd	r25, Z+7	; 0x07
    2616:	9a 83       	std	Y+2, r25	; 0x02
    2618:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    261a:	89 81       	ldd	r24, Y+1	; 0x01
    261c:	9a 81       	ldd	r25, Y+2	; 0x02
    261e:	02 96       	adiw	r24, 0x02	; 2
    2620:	0e 94 50 05 	call	0xaa0	; 0xaa0 <vListRemove>
					--uxCurrentNumberOfTasks;
    2624:	80 91 12 03 	lds	r24, 0x0312
    2628:	81 50       	subi	r24, 0x01	; 1
    262a:	80 93 12 03 	sts	0x0312, r24
					--uxTasksDeleted;
    262e:	80 91 11 03 	lds	r24, 0x0311
    2632:	81 50       	subi	r24, 0x01	; 1
    2634:	80 93 11 03 	sts	0x0311, r24
				}
				taskEXIT_CRITICAL();
    2638:	0f 90       	pop	r0
    263a:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    263c:	89 81       	ldd	r24, Y+1	; 0x01
    263e:	9a 81       	ldd	r25, Y+2	; 0x02
    2640:	0e 94 c1 13 	call	0x2782	; 0x2782 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    2644:	0f 90       	pop	r0
    2646:	0f 90       	pop	r0
    2648:	0f 90       	pop	r0
    264a:	cf 91       	pop	r28
    264c:	df 91       	pop	r29
    264e:	08 95       	ret

00002650 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    2650:	df 93       	push	r29
    2652:	cf 93       	push	r28
    2654:	00 d0       	rcall	.+0      	; 0x2656 <prvAddCurrentTaskToDelayedList+0x6>
    2656:	cd b7       	in	r28, 0x3d	; 61
    2658:	de b7       	in	r29, 0x3e	; 62
    265a:	9a 83       	std	Y+2, r25	; 0x02
    265c:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    265e:	e0 91 0f 03 	lds	r30, 0x030F
    2662:	f0 91 10 03 	lds	r31, 0x0310
    2666:	89 81       	ldd	r24, Y+1	; 0x01
    2668:	9a 81       	ldd	r25, Y+2	; 0x02
    266a:	93 83       	std	Z+3, r25	; 0x03
    266c:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    266e:	20 91 13 03 	lds	r18, 0x0313
    2672:	30 91 14 03 	lds	r19, 0x0314
    2676:	89 81       	ldd	r24, Y+1	; 0x01
    2678:	9a 81       	ldd	r25, Y+2	; 0x02
    267a:	82 17       	cp	r24, r18
    267c:	93 07       	cpc	r25, r19
    267e:	70 f4       	brcc	.+28     	; 0x269c <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2680:	80 91 5e 03 	lds	r24, 0x035E
    2684:	90 91 5f 03 	lds	r25, 0x035F
    2688:	20 91 0f 03 	lds	r18, 0x030F
    268c:	30 91 10 03 	lds	r19, 0x0310
    2690:	2e 5f       	subi	r18, 0xFE	; 254
    2692:	3f 4f       	sbci	r19, 0xFF	; 255
    2694:	b9 01       	movw	r22, r18
    2696:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <vListInsert>
    269a:	1e c0       	rjmp	.+60     	; 0x26d8 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    269c:	40 91 5c 03 	lds	r20, 0x035C
    26a0:	50 91 5d 03 	lds	r21, 0x035D
    26a4:	80 91 0f 03 	lds	r24, 0x030F
    26a8:	90 91 10 03 	lds	r25, 0x0310
    26ac:	9c 01       	movw	r18, r24
    26ae:	2e 5f       	subi	r18, 0xFE	; 254
    26b0:	3f 4f       	sbci	r19, 0xFF	; 255
    26b2:	ca 01       	movw	r24, r20
    26b4:	b9 01       	movw	r22, r18
    26b6:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    26ba:	20 91 77 00 	lds	r18, 0x0077
    26be:	30 91 78 00 	lds	r19, 0x0078
    26c2:	89 81       	ldd	r24, Y+1	; 0x01
    26c4:	9a 81       	ldd	r25, Y+2	; 0x02
    26c6:	82 17       	cp	r24, r18
    26c8:	93 07       	cpc	r25, r19
    26ca:	30 f4       	brcc	.+12     	; 0x26d8 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    26cc:	89 81       	ldd	r24, Y+1	; 0x01
    26ce:	9a 81       	ldd	r25, Y+2	; 0x02
    26d0:	90 93 78 00 	sts	0x0078, r25
    26d4:	80 93 77 00 	sts	0x0077, r24
		}
	}
}
    26d8:	0f 90       	pop	r0
    26da:	0f 90       	pop	r0
    26dc:	cf 91       	pop	r28
    26de:	df 91       	pop	r29
    26e0:	08 95       	ret

000026e2 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    26e2:	df 93       	push	r29
    26e4:	cf 93       	push	r28
    26e6:	cd b7       	in	r28, 0x3d	; 61
    26e8:	de b7       	in	r29, 0x3e	; 62
    26ea:	28 97       	sbiw	r28, 0x08	; 8
    26ec:	0f b6       	in	r0, 0x3f	; 63
    26ee:	f8 94       	cli
    26f0:	de bf       	out	0x3e, r29	; 62
    26f2:	0f be       	out	0x3f, r0	; 63
    26f4:	cd bf       	out	0x3d, r28	; 61
    26f6:	9c 83       	std	Y+4, r25	; 0x04
    26f8:	8b 83       	std	Y+3, r24	; 0x03
    26fa:	7e 83       	std	Y+6, r23	; 0x06
    26fc:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    26fe:	81 e2       	ldi	r24, 0x21	; 33
    2700:	90 e0       	ldi	r25, 0x00	; 0
    2702:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <pvPortMalloc>
    2706:	9a 83       	std	Y+2, r25	; 0x02
    2708:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    270a:	89 81       	ldd	r24, Y+1	; 0x01
    270c:	9a 81       	ldd	r25, Y+2	; 0x02
    270e:	00 97       	sbiw	r24, 0x00	; 0
    2710:	69 f1       	breq	.+90     	; 0x276c <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2712:	8d 81       	ldd	r24, Y+5	; 0x05
    2714:	9e 81       	ldd	r25, Y+6	; 0x06
    2716:	00 97       	sbiw	r24, 0x00	; 0
    2718:	39 f4       	brne	.+14     	; 0x2728 <prvAllocateTCBAndStack+0x46>
    271a:	8b 81       	ldd	r24, Y+3	; 0x03
    271c:	9c 81       	ldd	r25, Y+4	; 0x04
    271e:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <pvPortMalloc>
    2722:	98 87       	std	Y+8, r25	; 0x08
    2724:	8f 83       	std	Y+7, r24	; 0x07
    2726:	04 c0       	rjmp	.+8      	; 0x2730 <prvAllocateTCBAndStack+0x4e>
    2728:	8d 81       	ldd	r24, Y+5	; 0x05
    272a:	9e 81       	ldd	r25, Y+6	; 0x06
    272c:	98 87       	std	Y+8, r25	; 0x08
    272e:	8f 83       	std	Y+7, r24	; 0x07
    2730:	e9 81       	ldd	r30, Y+1	; 0x01
    2732:	fa 81       	ldd	r31, Y+2	; 0x02
    2734:	8f 81       	ldd	r24, Y+7	; 0x07
    2736:	98 85       	ldd	r25, Y+8	; 0x08
    2738:	90 8f       	std	Z+24, r25	; 0x18
    273a:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    273c:	e9 81       	ldd	r30, Y+1	; 0x01
    273e:	fa 81       	ldd	r31, Y+2	; 0x02
    2740:	87 89       	ldd	r24, Z+23	; 0x17
    2742:	90 8d       	ldd	r25, Z+24	; 0x18
    2744:	00 97       	sbiw	r24, 0x00	; 0
    2746:	39 f4       	brne	.+14     	; 0x2756 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2748:	89 81       	ldd	r24, Y+1	; 0x01
    274a:	9a 81       	ldd	r25, Y+2	; 0x02
    274c:	0e 94 38 04 	call	0x870	; 0x870 <vPortFree>
			pxNewTCB = NULL;
    2750:	1a 82       	std	Y+2, r1	; 0x02
    2752:	19 82       	std	Y+1, r1	; 0x01
    2754:	0b c0       	rjmp	.+22     	; 0x276c <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    2756:	e9 81       	ldd	r30, Y+1	; 0x01
    2758:	fa 81       	ldd	r31, Y+2	; 0x02
    275a:	87 89       	ldd	r24, Z+23	; 0x17
    275c:	90 8d       	ldd	r25, Z+24	; 0x18
    275e:	2b 81       	ldd	r18, Y+3	; 0x03
    2760:	3c 81       	ldd	r19, Y+4	; 0x04
    2762:	65 ea       	ldi	r22, 0xA5	; 165
    2764:	70 e0       	ldi	r23, 0x00	; 0
    2766:	a9 01       	movw	r20, r18
    2768:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <memset>
		}
	}

	return pxNewTCB;
    276c:	89 81       	ldd	r24, Y+1	; 0x01
    276e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2770:	28 96       	adiw	r28, 0x08	; 8
    2772:	0f b6       	in	r0, 0x3f	; 63
    2774:	f8 94       	cli
    2776:	de bf       	out	0x3e, r29	; 62
    2778:	0f be       	out	0x3f, r0	; 63
    277a:	cd bf       	out	0x3d, r28	; 61
    277c:	cf 91       	pop	r28
    277e:	df 91       	pop	r29
    2780:	08 95       	ret

00002782 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    2782:	df 93       	push	r29
    2784:	cf 93       	push	r28
    2786:	00 d0       	rcall	.+0      	; 0x2788 <prvDeleteTCB+0x6>
    2788:	cd b7       	in	r28, 0x3d	; 61
    278a:	de b7       	in	r29, 0x3e	; 62
    278c:	9a 83       	std	Y+2, r25	; 0x02
    278e:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2790:	e9 81       	ldd	r30, Y+1	; 0x01
    2792:	fa 81       	ldd	r31, Y+2	; 0x02
    2794:	87 89       	ldd	r24, Z+23	; 0x17
    2796:	90 8d       	ldd	r25, Z+24	; 0x18
    2798:	0e 94 38 04 	call	0x870	; 0x870 <vPortFree>
		vPortFree( pxTCB );
    279c:	89 81       	ldd	r24, Y+1	; 0x01
    279e:	9a 81       	ldd	r25, Y+2	; 0x02
    27a0:	0e 94 38 04 	call	0x870	; 0x870 <vPortFree>
	}
    27a4:	0f 90       	pop	r0
    27a6:	0f 90       	pop	r0
    27a8:	cf 91       	pop	r28
    27aa:	df 91       	pop	r29
    27ac:	08 95       	ret

000027ae <memcpy>:
    27ae:	fb 01       	movw	r30, r22
    27b0:	dc 01       	movw	r26, r24
    27b2:	02 c0       	rjmp	.+4      	; 0x27b8 <memcpy+0xa>
    27b4:	01 90       	ld	r0, Z+
    27b6:	0d 92       	st	X+, r0
    27b8:	41 50       	subi	r20, 0x01	; 1
    27ba:	50 40       	sbci	r21, 0x00	; 0
    27bc:	d8 f7       	brcc	.-10     	; 0x27b4 <memcpy+0x6>
    27be:	08 95       	ret

000027c0 <memset>:
    27c0:	dc 01       	movw	r26, r24
    27c2:	01 c0       	rjmp	.+2      	; 0x27c6 <memset+0x6>
    27c4:	6d 93       	st	X+, r22
    27c6:	41 50       	subi	r20, 0x01	; 1
    27c8:	50 40       	sbci	r21, 0x00	; 0
    27ca:	e0 f7       	brcc	.-8      	; 0x27c4 <memset+0x4>
    27cc:	08 95       	ret

000027ce <strncpy>:
    27ce:	fb 01       	movw	r30, r22
    27d0:	dc 01       	movw	r26, r24
    27d2:	41 50       	subi	r20, 0x01	; 1
    27d4:	50 40       	sbci	r21, 0x00	; 0
    27d6:	48 f0       	brcs	.+18     	; 0x27ea <strncpy+0x1c>
    27d8:	01 90       	ld	r0, Z+
    27da:	0d 92       	st	X+, r0
    27dc:	00 20       	and	r0, r0
    27de:	c9 f7       	brne	.-14     	; 0x27d2 <strncpy+0x4>
    27e0:	01 c0       	rjmp	.+2      	; 0x27e4 <strncpy+0x16>
    27e2:	1d 92       	st	X+, r1
    27e4:	41 50       	subi	r20, 0x01	; 1
    27e6:	50 40       	sbci	r21, 0x00	; 0
    27e8:	e0 f7       	brcc	.-8      	; 0x27e2 <strncpy+0x14>
    27ea:	08 95       	ret

000027ec <_exit>:
    27ec:	f8 94       	cli

000027ee <__stop_program>:
    27ee:	ff cf       	rjmp	.-2      	; 0x27ee <__stop_program>
