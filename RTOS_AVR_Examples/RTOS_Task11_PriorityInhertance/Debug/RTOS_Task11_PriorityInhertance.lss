
RTOS_Task11_PriorityInhertance.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002a8a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000020  00800060  00002a8a  00002b1e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002ff  00800080  00800080  00002b3e  2**0
                  ALLOC
  3 .stab         000048c0  00000000  00000000  00002b40  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002be7  00000000  00000000  00007400  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 d6 08 	jmp	0x11ac	; 0x11ac <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e8       	ldi	r30, 0x8A	; 138
      68:	fa e2       	ldi	r31, 0x2A	; 42
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a0 38       	cpi	r26, 0x80	; 128
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a0 e8       	ldi	r26, 0x80	; 128
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	af 37       	cpi	r26, 0x7F	; 127
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 49 00 	call	0x92	; 0x92 <main>
      8a:	0c 94 43 15 	jmp	0x2a86	; 0x2a86 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <main>:
      92:	af 92       	push	r10
      94:	bf 92       	push	r11
      96:	cf 92       	push	r12
      98:	df 92       	push	r13
      9a:	ef 92       	push	r14
      9c:	ff 92       	push	r15
      9e:	0f 93       	push	r16
      a0:	df 93       	push	r29
      a2:	cf 93       	push	r28
      a4:	cd b7       	in	r28, 0x3d	; 61
      a6:	de b7       	in	r29, 0x3e	; 62
      a8:	20 e6       	ldi	r18, 0x60	; 96
      aa:	30 e0       	ldi	r19, 0x00	; 0
      ac:	88 ec       	ldi	r24, 0xC8	; 200
      ae:	90 e0       	ldi	r25, 0x00	; 0
      b0:	e2 e8       	ldi	r30, 0x82	; 130
      b2:	f0 e0       	ldi	r31, 0x00	; 0
      b4:	b9 01       	movw	r22, r18
      b6:	45 e5       	ldi	r20, 0x55	; 85
      b8:	50 e0       	ldi	r21, 0x00	; 0
      ba:	20 e0       	ldi	r18, 0x00	; 0
      bc:	30 e0       	ldi	r19, 0x00	; 0
      be:	03 e0       	ldi	r16, 0x03	; 3
      c0:	7f 01       	movw	r14, r30
      c2:	cc 24       	eor	r12, r12
      c4:	dd 24       	eor	r13, r13
      c6:	aa 24       	eor	r10, r10
      c8:	bb 24       	eor	r11, r11
      ca:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <xTaskGenericCreate>
      ce:	26 e6       	ldi	r18, 0x66	; 102
      d0:	30 e0       	ldi	r19, 0x00	; 0
      d2:	8c e1       	ldi	r24, 0x1C	; 28
      d4:	91 e0       	ldi	r25, 0x01	; 1
      d6:	e6 e8       	ldi	r30, 0x86	; 134
      d8:	f0 e0       	ldi	r31, 0x00	; 0
      da:	b9 01       	movw	r22, r18
      dc:	45 e5       	ldi	r20, 0x55	; 85
      de:	50 e0       	ldi	r21, 0x00	; 0
      e0:	20 e0       	ldi	r18, 0x00	; 0
      e2:	30 e0       	ldi	r19, 0x00	; 0
      e4:	02 e0       	ldi	r16, 0x02	; 2
      e6:	7f 01       	movw	r14, r30
      e8:	cc 24       	eor	r12, r12
      ea:	dd 24       	eor	r13, r13
      ec:	aa 24       	eor	r10, r10
      ee:	bb 24       	eor	r11, r11
      f0:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <xTaskGenericCreate>
      f4:	24 e7       	ldi	r18, 0x74	; 116
      f6:	30 e0       	ldi	r19, 0x00	; 0
      f8:	83 e6       	ldi	r24, 0x63	; 99
      fa:	91 e0       	ldi	r25, 0x01	; 1
      fc:	e4 e8       	ldi	r30, 0x84	; 132
      fe:	f0 e0       	ldi	r31, 0x00	; 0
     100:	b9 01       	movw	r22, r18
     102:	45 e5       	ldi	r20, 0x55	; 85
     104:	50 e0       	ldi	r21, 0x00	; 0
     106:	20 e0       	ldi	r18, 0x00	; 0
     108:	30 e0       	ldi	r19, 0x00	; 0
     10a:	01 e0       	ldi	r16, 0x01	; 1
     10c:	7f 01       	movw	r14, r30
     10e:	cc 24       	eor	r12, r12
     110:	dd 24       	eor	r13, r13
     112:	aa 24       	eor	r10, r10
     114:	bb 24       	eor	r11, r11
     116:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <xTaskGenericCreate>
     11a:	0e 94 b6 00 	call	0x16c	; 0x16c <init>
     11e:	81 e0       	ldi	r24, 0x01	; 1
     120:	60 e0       	ldi	r22, 0x00	; 0
     122:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <xQueueCreate>
     126:	90 93 81 00 	sts	0x0081, r25
     12a:	80 93 80 00 	sts	0x0080, r24
     12e:	80 91 80 00 	lds	r24, 0x0080
     132:	90 91 81 00 	lds	r25, 0x0081
     136:	00 97       	sbiw	r24, 0x00	; 0
     138:	59 f0       	breq	.+22     	; 0x150 <main+0xbe>
     13a:	80 91 80 00 	lds	r24, 0x0080
     13e:	90 91 81 00 	lds	r25, 0x0081
     142:	60 e0       	ldi	r22, 0x00	; 0
     144:	70 e0       	ldi	r23, 0x00	; 0
     146:	40 e0       	ldi	r20, 0x00	; 0
     148:	50 e0       	ldi	r21, 0x00	; 0
     14a:	20 e0       	ldi	r18, 0x00	; 0
     14c:	0e 94 82 09 	call	0x1304	; 0x1304 <xQueueGenericSend>
     150:	0e 94 32 10 	call	0x2064	; 0x2064 <vTaskStartScheduler>
     154:	80 e0       	ldi	r24, 0x00	; 0
     156:	90 e0       	ldi	r25, 0x00	; 0
     158:	cf 91       	pop	r28
     15a:	df 91       	pop	r29
     15c:	0f 91       	pop	r16
     15e:	ff 90       	pop	r15
     160:	ef 90       	pop	r14
     162:	df 90       	pop	r13
     164:	cf 90       	pop	r12
     166:	bf 90       	pop	r11
     168:	af 90       	pop	r10
     16a:	08 95       	ret

0000016c <init>:

	/*Never Enter Here */
	return 0;
}

void init(void){
     16c:	df 93       	push	r29
     16e:	cf 93       	push	r28
     170:	cd b7       	in	r28, 0x3d	; 61
     172:	de b7       	in	r29, 0x3e	; 62

	DDRB = 0xFF;
     174:	e7 e3       	ldi	r30, 0x37	; 55
     176:	f0 e0       	ldi	r31, 0x00	; 0
     178:	8f ef       	ldi	r24, 0xFF	; 255
     17a:	80 83       	st	Z, r24

	DDRC = 0x00;
     17c:	e4 e3       	ldi	r30, 0x34	; 52
     17e:	f0 e0       	ldi	r31, 0x00	; 0
     180:	10 82       	st	Z, r1

	PORTC = 0xFF;
     182:	e5 e3       	ldi	r30, 0x35	; 53
     184:	f0 e0       	ldi	r31, 0x00	; 0
     186:	8f ef       	ldi	r24, 0xFF	; 255
     188:	80 83       	st	Z, r24

}
     18a:	cf 91       	pop	r28
     18c:	df 91       	pop	r29
     18e:	08 95       	ret

00000190 <Led2>:
 void Led2(void * pvparam){
     190:	df 93       	push	r29
     192:	cf 93       	push	r28
     194:	00 d0       	rcall	.+0      	; 0x196 <Led2+0x6>
     196:	00 d0       	rcall	.+0      	; 0x198 <Led2+0x8>
     198:	00 d0       	rcall	.+0      	; 0x19a <Led2+0xa>
     19a:	cd b7       	in	r28, 0x3d	; 61
     19c:	de b7       	in	r29, 0x3e	; 62
     19e:	9e 83       	std	Y+6, r25	; 0x06
     1a0:	8d 83       	std	Y+5, r24	; 0x05

	 portTickType Freq = 1000;
     1a2:	88 ee       	ldi	r24, 0xE8	; 232
     1a4:	93 e0       	ldi	r25, 0x03	; 3
     1a6:	9a 83       	std	Y+2, r25	; 0x02
     1a8:	89 83       	std	Y+1, r24	; 0x01
	 portTickType Start = xTaskGetTickCount();
     1aa:	0e 94 0b 11 	call	0x2216	; 0x2216 <xTaskGetTickCount>
     1ae:	9c 83       	std	Y+4, r25	; 0x04
     1b0:	8b 83       	std	Y+3, r24	; 0x03
	 vTaskDelay(20);
     1b2:	84 e1       	ldi	r24, 0x14	; 20
     1b4:	90 e0       	ldi	r25, 0x00	; 0
     1b6:	0e 94 1e 0f 	call	0x1e3c	; 0x1e3c <vTaskDelay>
     1ba:	0c c0       	rjmp	.+24     	; 0x1d4 <Led2+0x44>
	 while (1){

			 /* If the Resource No One is Using so Take the Semaphore  **/
			 while(pdFALSE == xSemaphoreTake(ButtonSemaphore,100)){
				 vTaskDelay(100);
     1bc:	84 e6       	ldi	r24, 0x64	; 100
     1be:	90 e0       	ldi	r25, 0x00	; 0
     1c0:	0e 94 1e 0f 	call	0x1e3c	; 0x1e3c <vTaskDelay>
				 PORTB ^= 0x02;
     1c4:	a8 e3       	ldi	r26, 0x38	; 56
     1c6:	b0 e0       	ldi	r27, 0x00	; 0
     1c8:	e8 e3       	ldi	r30, 0x38	; 56
     1ca:	f0 e0       	ldi	r31, 0x00	; 0
     1cc:	90 81       	ld	r25, Z
     1ce:	82 e0       	ldi	r24, 0x02	; 2
     1d0:	89 27       	eor	r24, r25
     1d2:	8c 93       	st	X, r24
	 portTickType Start = xTaskGetTickCount();
	 vTaskDelay(20);
	 while (1){

			 /* If the Resource No One is Using so Take the Semaphore  **/
			 while(pdFALSE == xSemaphoreTake(ButtonSemaphore,100)){
     1d4:	80 91 80 00 	lds	r24, 0x0080
     1d8:	90 91 81 00 	lds	r25, 0x0081
     1dc:	60 e0       	ldi	r22, 0x00	; 0
     1de:	70 e0       	ldi	r23, 0x00	; 0
     1e0:	44 e6       	ldi	r20, 0x64	; 100
     1e2:	50 e0       	ldi	r21, 0x00	; 0
     1e4:	20 e0       	ldi	r18, 0x00	; 0
     1e6:	0e 94 6d 0a 	call	0x14da	; 0x14da <xQueueGenericReceive>
     1ea:	88 23       	and	r24, r24
     1ec:	39 f3       	breq	.-50     	; 0x1bc <Led2+0x2c>
				 vTaskDelay(100);
				 PORTB ^= 0x02;
			 }
			 vTaskPrioritySet(Led2Handle,MAX_USINGSEMAPHORE);
     1ee:	80 91 82 00 	lds	r24, 0x0082
     1f2:	90 91 83 00 	lds	r25, 0x0083
     1f6:	63 e0       	ldi	r22, 0x03	; 3
     1f8:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vTaskPrioritySet>

			 vTaskDelay(10000);
     1fc:	80 e1       	ldi	r24, 0x10	; 16
     1fe:	97 e2       	ldi	r25, 0x27	; 39
     200:	0e 94 1e 0f 	call	0x1e3c	; 0x1e3c <vTaskDelay>

			 xSemaphoreGive(ButtonSemaphore);
     204:	80 91 80 00 	lds	r24, 0x0080
     208:	90 91 81 00 	lds	r25, 0x0081
     20c:	60 e0       	ldi	r22, 0x00	; 0
     20e:	70 e0       	ldi	r23, 0x00	; 0
     210:	40 e0       	ldi	r20, 0x00	; 0
     212:	50 e0       	ldi	r21, 0x00	; 0
     214:	20 e0       	ldi	r18, 0x00	; 0
     216:	0e 94 82 09 	call	0x1304	; 0x1304 <xQueueGenericSend>
			 vTaskPrioritySet(Led2Handle,Led2Pr);
     21a:	80 91 82 00 	lds	r24, 0x0082
     21e:	90 91 83 00 	lds	r25, 0x0083
     222:	63 e0       	ldi	r22, 0x03	; 3
     224:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vTaskPrioritySet>

		 /*Make the Task Periodic with Period 50 Tick */
		 vTaskDelayUntil(&Start,Freq);
     228:	ce 01       	movw	r24, r28
     22a:	03 96       	adiw	r24, 0x03	; 3
     22c:	29 81       	ldd	r18, Y+1	; 0x01
     22e:	3a 81       	ldd	r19, Y+2	; 0x02
     230:	b9 01       	movw	r22, r18
     232:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <vTaskDelayUntil>
     236:	ce cf       	rjmp	.-100    	; 0x1d4 <Led2+0x44>

00000238 <PushButton2>:
	 }

 }


 void PushButton2(void * pvparam){
     238:	df 93       	push	r29
     23a:	cf 93       	push	r28
     23c:	00 d0       	rcall	.+0      	; 0x23e <PushButton2+0x6>
     23e:	00 d0       	rcall	.+0      	; 0x240 <PushButton2+0x8>
     240:	00 d0       	rcall	.+0      	; 0x242 <PushButton2+0xa>
     242:	cd b7       	in	r28, 0x3d	; 61
     244:	de b7       	in	r29, 0x3e	; 62
     246:	9e 83       	std	Y+6, r25	; 0x06
     248:	8d 83       	std	Y+5, r24	; 0x05
	 portTickType Freq = 100;
     24a:	84 e6       	ldi	r24, 0x64	; 100
     24c:	90 e0       	ldi	r25, 0x00	; 0
     24e:	9a 83       	std	Y+2, r25	; 0x02
     250:	89 83       	std	Y+1, r24	; 0x01
	 portTickType Start = xTaskGetTickCount();
     252:	0e 94 0b 11 	call	0x2216	; 0x2216 <xTaskGetTickCount>
     256:	9c 83       	std	Y+4, r25	; 0x04
     258:	8b 83       	std	Y+3, r24	; 0x03
	 while (1){

				 while(pdFALSE == xSemaphoreTake(ButtonSemaphore,100));
     25a:	80 91 80 00 	lds	r24, 0x0080
     25e:	90 91 81 00 	lds	r25, 0x0081
     262:	60 e0       	ldi	r22, 0x00	; 0
     264:	70 e0       	ldi	r23, 0x00	; 0
     266:	44 e6       	ldi	r20, 0x64	; 100
     268:	50 e0       	ldi	r21, 0x00	; 0
     26a:	20 e0       	ldi	r18, 0x00	; 0
     26c:	0e 94 6d 0a 	call	0x14da	; 0x14da <xQueueGenericReceive>
     270:	88 23       	and	r24, r24
     272:	99 f3       	breq	.-26     	; 0x25a <PushButton2+0x22>
				 vTaskPrioritySet(PushButton2,MAX_USINGSEMAPHORE);
     274:	8c e1       	ldi	r24, 0x1C	; 28
     276:	91 e0       	ldi	r25, 0x01	; 1
     278:	63 e0       	ldi	r22, 0x03	; 3
     27a:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vTaskPrioritySet>

				 /*Change the State **/
				 PORTB ^= 0x04;
     27e:	a8 e3       	ldi	r26, 0x38	; 56
     280:	b0 e0       	ldi	r27, 0x00	; 0
     282:	e8 e3       	ldi	r30, 0x38	; 56
     284:	f0 e0       	ldi	r31, 0x00	; 0
     286:	90 81       	ld	r25, Z
     288:	84 e0       	ldi	r24, 0x04	; 4
     28a:	89 27       	eor	r24, r25
     28c:	8c 93       	st	X, r24

				 vTaskDelay(1000);
     28e:	88 ee       	ldi	r24, 0xE8	; 232
     290:	93 e0       	ldi	r25, 0x03	; 3
     292:	0e 94 1e 0f 	call	0x1e3c	; 0x1e3c <vTaskDelay>

				 /**Give the Semaphore */
				 xSemaphoreGive(ButtonSemaphore);
     296:	80 91 80 00 	lds	r24, 0x0080
     29a:	90 91 81 00 	lds	r25, 0x0081
     29e:	60 e0       	ldi	r22, 0x00	; 0
     2a0:	70 e0       	ldi	r23, 0x00	; 0
     2a2:	40 e0       	ldi	r20, 0x00	; 0
     2a4:	50 e0       	ldi	r21, 0x00	; 0
     2a6:	20 e0       	ldi	r18, 0x00	; 0
     2a8:	0e 94 82 09 	call	0x1304	; 0x1304 <xQueueGenericSend>
				 vTaskPrioritySet(PushButton2,PushButton2Pr);
     2ac:	8c e1       	ldi	r24, 0x1C	; 28
     2ae:	91 e0       	ldi	r25, 0x01	; 1
     2b0:	62 e0       	ldi	r22, 0x02	; 2
     2b2:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vTaskPrioritySet>

		 /*Make the Task Periodic with Period 50 Tick */
		 vTaskDelayUntil(&Start,Freq);
     2b6:	ce 01       	movw	r24, r28
     2b8:	03 96       	adiw	r24, 0x03	; 3
     2ba:	29 81       	ldd	r18, Y+1	; 0x01
     2bc:	3a 81       	ldd	r19, Y+2	; 0x02
     2be:	b9 01       	movw	r22, r18
     2c0:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <vTaskDelayUntil>
     2c4:	ca cf       	rjmp	.-108    	; 0x25a <PushButton2+0x22>

000002c6 <Led>:

 }



 void Led(void * pvparam){
     2c6:	df 93       	push	r29
     2c8:	cf 93       	push	r28
     2ca:	00 d0       	rcall	.+0      	; 0x2cc <Led+0x6>
     2cc:	00 d0       	rcall	.+0      	; 0x2ce <Led+0x8>
     2ce:	00 d0       	rcall	.+0      	; 0x2d0 <Led+0xa>
     2d0:	cd b7       	in	r28, 0x3d	; 61
     2d2:	de b7       	in	r29, 0x3e	; 62
     2d4:	9e 83       	std	Y+6, r25	; 0x06
     2d6:	8d 83       	std	Y+5, r24	; 0x05
	 portTickType Freq = 100;
     2d8:	84 e6       	ldi	r24, 0x64	; 100
     2da:	90 e0       	ldi	r25, 0x00	; 0
     2dc:	9a 83       	std	Y+2, r25	; 0x02
     2de:	89 83       	std	Y+1, r24	; 0x01
	 portTickType Start = xTaskGetTickCount();
     2e0:	0e 94 0b 11 	call	0x2216	; 0x2216 <xTaskGetTickCount>
     2e4:	9c 83       	std	Y+4, r25	; 0x04
     2e6:	8b 83       	std	Y+3, r24	; 0x03
	 vTaskDelay(30);
     2e8:	8e e1       	ldi	r24, 0x1E	; 30
     2ea:	90 e0       	ldi	r25, 0x00	; 0
     2ec:	0e 94 1e 0f 	call	0x1e3c	; 0x1e3c <vTaskDelay>
	 while (1){

		 PORTB ^= 0x01;
     2f0:	a8 e3       	ldi	r26, 0x38	; 56
     2f2:	b0 e0       	ldi	r27, 0x00	; 0
     2f4:	e8 e3       	ldi	r30, 0x38	; 56
     2f6:	f0 e0       	ldi	r31, 0x00	; 0
     2f8:	90 81       	ld	r25, Z
     2fa:	81 e0       	ldi	r24, 0x01	; 1
     2fc:	89 27       	eor	r24, r25
     2fe:	8c 93       	st	X, r24

		 /*Make the Task Periodic with Period 50 Tick */
		 vTaskDelayUntil(&Start,Freq);
     300:	ce 01       	movw	r24, r28
     302:	03 96       	adiw	r24, 0x03	; 3
     304:	29 81       	ldd	r18, Y+1	; 0x01
     306:	3a 81       	ldd	r19, Y+2	; 0x02
     308:	b9 01       	movw	r22, r18
     30a:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <vTaskDelayUntil>
     30e:	f0 cf       	rjmp	.-32     	; 0x2f0 <Led+0x2a>

00000310 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     310:	df 93       	push	r29
     312:	cf 93       	push	r28
     314:	cd b7       	in	r28, 0x3d	; 61
     316:	de b7       	in	r29, 0x3e	; 62
     318:	27 97       	sbiw	r28, 0x07	; 7
     31a:	0f b6       	in	r0, 0x3f	; 63
     31c:	f8 94       	cli
     31e:	de bf       	out	0x3e, r29	; 62
     320:	0f be       	out	0x3f, r0	; 63
     322:	cd bf       	out	0x3d, r28	; 61
     324:	9d 83       	std	Y+5, r25	; 0x05
     326:	8c 83       	std	Y+4, r24	; 0x04
     328:	6e 83       	std	Y+6, r22	; 0x06
     32a:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     32c:	8a e1       	ldi	r24, 0x1A	; 26
     32e:	90 e0       	ldi	r25, 0x00	; 0
     330:	0e 94 60 04 	call	0x8c0	; 0x8c0 <pvPortMalloc>
     334:	9a 83       	std	Y+2, r25	; 0x02
     336:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     338:	89 81       	ldd	r24, Y+1	; 0x01
     33a:	9a 81       	ldd	r25, Y+2	; 0x02
     33c:	00 97       	sbiw	r24, 0x00	; 0
     33e:	09 f4       	brne	.+2      	; 0x342 <xCoRoutineCreate+0x32>
     340:	6f c0       	rjmp	.+222    	; 0x420 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     342:	80 91 88 00 	lds	r24, 0x0088
     346:	90 91 89 00 	lds	r25, 0x0089
     34a:	00 97       	sbiw	r24, 0x00	; 0
     34c:	41 f4       	brne	.+16     	; 0x35e <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     34e:	89 81       	ldd	r24, Y+1	; 0x01
     350:	9a 81       	ldd	r25, Y+2	; 0x02
     352:	90 93 89 00 	sts	0x0089, r25
     356:	80 93 88 00 	sts	0x0088, r24
			prvInitialiseCoRoutineLists();
     35a:	0e 94 ef 03 	call	0x7de	; 0x7de <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     35e:	8e 81       	ldd	r24, Y+6	; 0x06
     360:	82 30       	cpi	r24, 0x02	; 2
     362:	10 f0       	brcs	.+4      	; 0x368 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     364:	81 e0       	ldi	r24, 0x01	; 1
     366:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     368:	e9 81       	ldd	r30, Y+1	; 0x01
     36a:	fa 81       	ldd	r31, Y+2	; 0x02
     36c:	11 8e       	std	Z+25, r1	; 0x19
     36e:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     370:	e9 81       	ldd	r30, Y+1	; 0x01
     372:	fa 81       	ldd	r31, Y+2	; 0x02
     374:	8e 81       	ldd	r24, Y+6	; 0x06
     376:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     378:	e9 81       	ldd	r30, Y+1	; 0x01
     37a:	fa 81       	ldd	r31, Y+2	; 0x02
     37c:	8f 81       	ldd	r24, Y+7	; 0x07
     37e:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     380:	e9 81       	ldd	r30, Y+1	; 0x01
     382:	fa 81       	ldd	r31, Y+2	; 0x02
     384:	8c 81       	ldd	r24, Y+4	; 0x04
     386:	9d 81       	ldd	r25, Y+5	; 0x05
     388:	91 83       	std	Z+1, r25	; 0x01
     38a:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     38c:	89 81       	ldd	r24, Y+1	; 0x01
     38e:	9a 81       	ldd	r25, Y+2	; 0x02
     390:	02 96       	adiw	r24, 0x02	; 2
     392:	0e 94 f6 04 	call	0x9ec	; 0x9ec <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     396:	89 81       	ldd	r24, Y+1	; 0x01
     398:	9a 81       	ldd	r25, Y+2	; 0x02
     39a:	0c 96       	adiw	r24, 0x0c	; 12
     39c:	0e 94 f6 04 	call	0x9ec	; 0x9ec <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     3a0:	e9 81       	ldd	r30, Y+1	; 0x01
     3a2:	fa 81       	ldd	r31, Y+2	; 0x02
     3a4:	89 81       	ldd	r24, Y+1	; 0x01
     3a6:	9a 81       	ldd	r25, Y+2	; 0x02
     3a8:	91 87       	std	Z+9, r25	; 0x09
     3aa:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     3ac:	e9 81       	ldd	r30, Y+1	; 0x01
     3ae:	fa 81       	ldd	r31, Y+2	; 0x02
     3b0:	89 81       	ldd	r24, Y+1	; 0x01
     3b2:	9a 81       	ldd	r25, Y+2	; 0x02
     3b4:	93 8b       	std	Z+19, r25	; 0x13
     3b6:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     3b8:	8e 81       	ldd	r24, Y+6	; 0x06
     3ba:	28 2f       	mov	r18, r24
     3bc:	30 e0       	ldi	r19, 0x00	; 0
     3be:	85 e0       	ldi	r24, 0x05	; 5
     3c0:	90 e0       	ldi	r25, 0x00	; 0
     3c2:	82 1b       	sub	r24, r18
     3c4:	93 0b       	sbc	r25, r19
     3c6:	e9 81       	ldd	r30, Y+1	; 0x01
     3c8:	fa 81       	ldd	r31, Y+2	; 0x02
     3ca:	95 87       	std	Z+13, r25	; 0x0d
     3cc:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     3ce:	e9 81       	ldd	r30, Y+1	; 0x01
     3d0:	fa 81       	ldd	r31, Y+2	; 0x02
     3d2:	96 89       	ldd	r25, Z+22	; 0x16
     3d4:	80 91 8a 00 	lds	r24, 0x008A
     3d8:	89 17       	cp	r24, r25
     3da:	28 f4       	brcc	.+10     	; 0x3e6 <xCoRoutineCreate+0xd6>
     3dc:	e9 81       	ldd	r30, Y+1	; 0x01
     3de:	fa 81       	ldd	r31, Y+2	; 0x02
     3e0:	86 89       	ldd	r24, Z+22	; 0x16
     3e2:	80 93 8a 00 	sts	0x008A, r24
     3e6:	e9 81       	ldd	r30, Y+1	; 0x01
     3e8:	fa 81       	ldd	r31, Y+2	; 0x02
     3ea:	86 89       	ldd	r24, Z+22	; 0x16
     3ec:	28 2f       	mov	r18, r24
     3ee:	30 e0       	ldi	r19, 0x00	; 0
     3f0:	c9 01       	movw	r24, r18
     3f2:	88 0f       	add	r24, r24
     3f4:	99 1f       	adc	r25, r25
     3f6:	88 0f       	add	r24, r24
     3f8:	99 1f       	adc	r25, r25
     3fa:	88 0f       	add	r24, r24
     3fc:	99 1f       	adc	r25, r25
     3fe:	82 0f       	add	r24, r18
     400:	93 1f       	adc	r25, r19
     402:	ac 01       	movw	r20, r24
     404:	4f 56       	subi	r20, 0x6F	; 111
     406:	5f 4f       	sbci	r21, 0xFF	; 255
     408:	89 81       	ldd	r24, Y+1	; 0x01
     40a:	9a 81       	ldd	r25, Y+2	; 0x02
     40c:	9c 01       	movw	r18, r24
     40e:	2e 5f       	subi	r18, 0xFE	; 254
     410:	3f 4f       	sbci	r19, 0xFF	; 255
     412:	ca 01       	movw	r24, r20
     414:	b9 01       	movw	r22, r18
     416:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListInsertEnd>

		xReturn = pdPASS;
     41a:	81 e0       	ldi	r24, 0x01	; 1
     41c:	8b 83       	std	Y+3, r24	; 0x03
     41e:	02 c0       	rjmp	.+4      	; 0x424 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     420:	8f ef       	ldi	r24, 0xFF	; 255
     422:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     424:	8b 81       	ldd	r24, Y+3	; 0x03
}
     426:	27 96       	adiw	r28, 0x07	; 7
     428:	0f b6       	in	r0, 0x3f	; 63
     42a:	f8 94       	cli
     42c:	de bf       	out	0x3e, r29	; 62
     42e:	0f be       	out	0x3f, r0	; 63
     430:	cd bf       	out	0x3d, r28	; 61
     432:	cf 91       	pop	r28
     434:	df 91       	pop	r29
     436:	08 95       	ret

00000438 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     438:	df 93       	push	r29
     43a:	cf 93       	push	r28
     43c:	00 d0       	rcall	.+0      	; 0x43e <vCoRoutineAddToDelayedList+0x6>
     43e:	00 d0       	rcall	.+0      	; 0x440 <vCoRoutineAddToDelayedList+0x8>
     440:	00 d0       	rcall	.+0      	; 0x442 <vCoRoutineAddToDelayedList+0xa>
     442:	cd b7       	in	r28, 0x3d	; 61
     444:	de b7       	in	r29, 0x3e	; 62
     446:	9c 83       	std	Y+4, r25	; 0x04
     448:	8b 83       	std	Y+3, r24	; 0x03
     44a:	7e 83       	std	Y+6, r23	; 0x06
     44c:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     44e:	20 91 8b 00 	lds	r18, 0x008B
     452:	30 91 8c 00 	lds	r19, 0x008C
     456:	8b 81       	ldd	r24, Y+3	; 0x03
     458:	9c 81       	ldd	r25, Y+4	; 0x04
     45a:	82 0f       	add	r24, r18
     45c:	93 1f       	adc	r25, r19
     45e:	9a 83       	std	Y+2, r25	; 0x02
     460:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     462:	80 91 88 00 	lds	r24, 0x0088
     466:	90 91 89 00 	lds	r25, 0x0089
     46a:	02 96       	adiw	r24, 0x02	; 2
     46c:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     470:	e0 91 88 00 	lds	r30, 0x0088
     474:	f0 91 89 00 	lds	r31, 0x0089
     478:	89 81       	ldd	r24, Y+1	; 0x01
     47a:	9a 81       	ldd	r25, Y+2	; 0x02
     47c:	93 83       	std	Z+3, r25	; 0x03
     47e:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     480:	20 91 8b 00 	lds	r18, 0x008B
     484:	30 91 8c 00 	lds	r19, 0x008C
     488:	89 81       	ldd	r24, Y+1	; 0x01
     48a:	9a 81       	ldd	r25, Y+2	; 0x02
     48c:	82 17       	cp	r24, r18
     48e:	93 07       	cpc	r25, r19
     490:	70 f4       	brcc	.+28     	; 0x4ae <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     492:	80 91 b7 00 	lds	r24, 0x00B7
     496:	90 91 b8 00 	lds	r25, 0x00B8
     49a:	20 91 88 00 	lds	r18, 0x0088
     49e:	30 91 89 00 	lds	r19, 0x0089
     4a2:	2e 5f       	subi	r18, 0xFE	; 254
     4a4:	3f 4f       	sbci	r19, 0xFF	; 255
     4a6:	b9 01       	movw	r22, r18
     4a8:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vListInsert>
     4ac:	0d c0       	rjmp	.+26     	; 0x4c8 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     4ae:	80 91 b5 00 	lds	r24, 0x00B5
     4b2:	90 91 b6 00 	lds	r25, 0x00B6
     4b6:	20 91 88 00 	lds	r18, 0x0088
     4ba:	30 91 89 00 	lds	r19, 0x0089
     4be:	2e 5f       	subi	r18, 0xFE	; 254
     4c0:	3f 4f       	sbci	r19, 0xFF	; 255
     4c2:	b9 01       	movw	r22, r18
     4c4:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vListInsert>
	}

	if( pxEventList )
     4c8:	8d 81       	ldd	r24, Y+5	; 0x05
     4ca:	9e 81       	ldd	r25, Y+6	; 0x06
     4cc:	00 97       	sbiw	r24, 0x00	; 0
     4ce:	61 f0       	breq	.+24     	; 0x4e8 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     4d0:	80 91 88 00 	lds	r24, 0x0088
     4d4:	90 91 89 00 	lds	r25, 0x0089
     4d8:	9c 01       	movw	r18, r24
     4da:	24 5f       	subi	r18, 0xF4	; 244
     4dc:	3f 4f       	sbci	r19, 0xFF	; 255
     4de:	8d 81       	ldd	r24, Y+5	; 0x05
     4e0:	9e 81       	ldd	r25, Y+6	; 0x06
     4e2:	b9 01       	movw	r22, r18
     4e4:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vListInsert>
	}
}
     4e8:	26 96       	adiw	r28, 0x06	; 6
     4ea:	0f b6       	in	r0, 0x3f	; 63
     4ec:	f8 94       	cli
     4ee:	de bf       	out	0x3e, r29	; 62
     4f0:	0f be       	out	0x3f, r0	; 63
     4f2:	cd bf       	out	0x3d, r28	; 61
     4f4:	cf 91       	pop	r28
     4f6:	df 91       	pop	r29
     4f8:	08 95       	ret

000004fa <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     4fa:	df 93       	push	r29
     4fc:	cf 93       	push	r28
     4fe:	00 d0       	rcall	.+0      	; 0x500 <prvCheckPendingReadyList+0x6>
     500:	cd b7       	in	r28, 0x3d	; 61
     502:	de b7       	in	r29, 0x3e	; 62
     504:	3a c0       	rjmp	.+116    	; 0x57a <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     506:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     508:	e0 91 be 00 	lds	r30, 0x00BE
     50c:	f0 91 bf 00 	lds	r31, 0x00BF
     510:	86 81       	ldd	r24, Z+6	; 0x06
     512:	97 81       	ldd	r25, Z+7	; 0x07
     514:	9a 83       	std	Y+2, r25	; 0x02
     516:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     518:	89 81       	ldd	r24, Y+1	; 0x01
     51a:	9a 81       	ldd	r25, Y+2	; 0x02
     51c:	0c 96       	adiw	r24, 0x0c	; 12
     51e:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>
		}
		portENABLE_INTERRUPTS();
     522:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     524:	89 81       	ldd	r24, Y+1	; 0x01
     526:	9a 81       	ldd	r25, Y+2	; 0x02
     528:	02 96       	adiw	r24, 0x02	; 2
     52a:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     52e:	e9 81       	ldd	r30, Y+1	; 0x01
     530:	fa 81       	ldd	r31, Y+2	; 0x02
     532:	96 89       	ldd	r25, Z+22	; 0x16
     534:	80 91 8a 00 	lds	r24, 0x008A
     538:	89 17       	cp	r24, r25
     53a:	28 f4       	brcc	.+10     	; 0x546 <prvCheckPendingReadyList+0x4c>
     53c:	e9 81       	ldd	r30, Y+1	; 0x01
     53e:	fa 81       	ldd	r31, Y+2	; 0x02
     540:	86 89       	ldd	r24, Z+22	; 0x16
     542:	80 93 8a 00 	sts	0x008A, r24
     546:	e9 81       	ldd	r30, Y+1	; 0x01
     548:	fa 81       	ldd	r31, Y+2	; 0x02
     54a:	86 89       	ldd	r24, Z+22	; 0x16
     54c:	28 2f       	mov	r18, r24
     54e:	30 e0       	ldi	r19, 0x00	; 0
     550:	c9 01       	movw	r24, r18
     552:	88 0f       	add	r24, r24
     554:	99 1f       	adc	r25, r25
     556:	88 0f       	add	r24, r24
     558:	99 1f       	adc	r25, r25
     55a:	88 0f       	add	r24, r24
     55c:	99 1f       	adc	r25, r25
     55e:	82 0f       	add	r24, r18
     560:	93 1f       	adc	r25, r19
     562:	ac 01       	movw	r20, r24
     564:	4f 56       	subi	r20, 0x6F	; 111
     566:	5f 4f       	sbci	r21, 0xFF	; 255
     568:	89 81       	ldd	r24, Y+1	; 0x01
     56a:	9a 81       	ldd	r25, Y+2	; 0x02
     56c:	9c 01       	movw	r18, r24
     56e:	2e 5f       	subi	r18, 0xFE	; 254
     570:	3f 4f       	sbci	r19, 0xFF	; 255
     572:	ca 01       	movw	r24, r20
     574:	b9 01       	movw	r22, r18
     576:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     57a:	80 91 b9 00 	lds	r24, 0x00B9
     57e:	88 23       	and	r24, r24
     580:	09 f0       	breq	.+2      	; 0x584 <prvCheckPendingReadyList+0x8a>
     582:	c1 cf       	rjmp	.-126    	; 0x506 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     584:	0f 90       	pop	r0
     586:	0f 90       	pop	r0
     588:	cf 91       	pop	r28
     58a:	df 91       	pop	r29
     58c:	08 95       	ret

0000058e <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     58e:	df 93       	push	r29
     590:	cf 93       	push	r28
     592:	00 d0       	rcall	.+0      	; 0x594 <prvCheckDelayedList+0x6>
     594:	00 d0       	rcall	.+0      	; 0x596 <prvCheckDelayedList+0x8>
     596:	cd b7       	in	r28, 0x3d	; 61
     598:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     59a:	0e 94 0b 11 	call	0x2216	; 0x2216 <xTaskGetTickCount>
     59e:	20 91 8d 00 	lds	r18, 0x008D
     5a2:	30 91 8e 00 	lds	r19, 0x008E
     5a6:	82 1b       	sub	r24, r18
     5a8:	93 0b       	sbc	r25, r19
     5aa:	90 93 90 00 	sts	0x0090, r25
     5ae:	80 93 8f 00 	sts	0x008F, r24
     5b2:	85 c0       	rjmp	.+266    	; 0x6be <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     5b4:	80 91 8b 00 	lds	r24, 0x008B
     5b8:	90 91 8c 00 	lds	r25, 0x008C
     5bc:	01 96       	adiw	r24, 0x01	; 1
     5be:	90 93 8c 00 	sts	0x008C, r25
     5c2:	80 93 8b 00 	sts	0x008B, r24
		xPassedTicks--;
     5c6:	80 91 8f 00 	lds	r24, 0x008F
     5ca:	90 91 90 00 	lds	r25, 0x0090
     5ce:	01 97       	sbiw	r24, 0x01	; 1
     5d0:	90 93 90 00 	sts	0x0090, r25
     5d4:	80 93 8f 00 	sts	0x008F, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     5d8:	80 91 8b 00 	lds	r24, 0x008B
     5dc:	90 91 8c 00 	lds	r25, 0x008C
     5e0:	00 97       	sbiw	r24, 0x00	; 0
     5e2:	09 f0       	breq	.+2      	; 0x5e6 <prvCheckDelayedList+0x58>
     5e4:	64 c0       	rjmp	.+200    	; 0x6ae <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     5e6:	80 91 b5 00 	lds	r24, 0x00B5
     5ea:	90 91 b6 00 	lds	r25, 0x00B6
     5ee:	9a 83       	std	Y+2, r25	; 0x02
     5f0:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     5f2:	80 91 b7 00 	lds	r24, 0x00B7
     5f6:	90 91 b8 00 	lds	r25, 0x00B8
     5fa:	90 93 b6 00 	sts	0x00B6, r25
     5fe:	80 93 b5 00 	sts	0x00B5, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     602:	89 81       	ldd	r24, Y+1	; 0x01
     604:	9a 81       	ldd	r25, Y+2	; 0x02
     606:	90 93 b8 00 	sts	0x00B8, r25
     60a:	80 93 b7 00 	sts	0x00B7, r24
     60e:	4f c0       	rjmp	.+158    	; 0x6ae <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     610:	e0 91 b5 00 	lds	r30, 0x00B5
     614:	f0 91 b6 00 	lds	r31, 0x00B6
     618:	05 80       	ldd	r0, Z+5	; 0x05
     61a:	f6 81       	ldd	r31, Z+6	; 0x06
     61c:	e0 2d       	mov	r30, r0
     61e:	86 81       	ldd	r24, Z+6	; 0x06
     620:	97 81       	ldd	r25, Z+7	; 0x07
     622:	9c 83       	std	Y+4, r25	; 0x04
     624:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     626:	eb 81       	ldd	r30, Y+3	; 0x03
     628:	fc 81       	ldd	r31, Y+4	; 0x04
     62a:	22 81       	ldd	r18, Z+2	; 0x02
     62c:	33 81       	ldd	r19, Z+3	; 0x03
     62e:	80 91 8b 00 	lds	r24, 0x008B
     632:	90 91 8c 00 	lds	r25, 0x008C
     636:	82 17       	cp	r24, r18
     638:	93 07       	cpc	r25, r19
     63a:	08 f4       	brcc	.+2      	; 0x63e <prvCheckDelayedList+0xb0>
     63c:	40 c0       	rjmp	.+128    	; 0x6be <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     63e:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     640:	8b 81       	ldd	r24, Y+3	; 0x03
     642:	9c 81       	ldd	r25, Y+4	; 0x04
     644:	02 96       	adiw	r24, 0x02	; 2
     646:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     64a:	eb 81       	ldd	r30, Y+3	; 0x03
     64c:	fc 81       	ldd	r31, Y+4	; 0x04
     64e:	84 89       	ldd	r24, Z+20	; 0x14
     650:	95 89       	ldd	r25, Z+21	; 0x15
     652:	00 97       	sbiw	r24, 0x00	; 0
     654:	29 f0       	breq	.+10     	; 0x660 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     656:	8b 81       	ldd	r24, Y+3	; 0x03
     658:	9c 81       	ldd	r25, Y+4	; 0x04
     65a:	0c 96       	adiw	r24, 0x0c	; 12
     65c:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     660:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     662:	eb 81       	ldd	r30, Y+3	; 0x03
     664:	fc 81       	ldd	r31, Y+4	; 0x04
     666:	96 89       	ldd	r25, Z+22	; 0x16
     668:	80 91 8a 00 	lds	r24, 0x008A
     66c:	89 17       	cp	r24, r25
     66e:	28 f4       	brcc	.+10     	; 0x67a <prvCheckDelayedList+0xec>
     670:	eb 81       	ldd	r30, Y+3	; 0x03
     672:	fc 81       	ldd	r31, Y+4	; 0x04
     674:	86 89       	ldd	r24, Z+22	; 0x16
     676:	80 93 8a 00 	sts	0x008A, r24
     67a:	eb 81       	ldd	r30, Y+3	; 0x03
     67c:	fc 81       	ldd	r31, Y+4	; 0x04
     67e:	86 89       	ldd	r24, Z+22	; 0x16
     680:	28 2f       	mov	r18, r24
     682:	30 e0       	ldi	r19, 0x00	; 0
     684:	c9 01       	movw	r24, r18
     686:	88 0f       	add	r24, r24
     688:	99 1f       	adc	r25, r25
     68a:	88 0f       	add	r24, r24
     68c:	99 1f       	adc	r25, r25
     68e:	88 0f       	add	r24, r24
     690:	99 1f       	adc	r25, r25
     692:	82 0f       	add	r24, r18
     694:	93 1f       	adc	r25, r19
     696:	ac 01       	movw	r20, r24
     698:	4f 56       	subi	r20, 0x6F	; 111
     69a:	5f 4f       	sbci	r21, 0xFF	; 255
     69c:	8b 81       	ldd	r24, Y+3	; 0x03
     69e:	9c 81       	ldd	r25, Y+4	; 0x04
     6a0:	9c 01       	movw	r18, r24
     6a2:	2e 5f       	subi	r18, 0xFE	; 254
     6a4:	3f 4f       	sbci	r19, 0xFF	; 255
     6a6:	ca 01       	movw	r24, r20
     6a8:	b9 01       	movw	r22, r18
     6aa:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     6ae:	e0 91 b5 00 	lds	r30, 0x00B5
     6b2:	f0 91 b6 00 	lds	r31, 0x00B6
     6b6:	80 81       	ld	r24, Z
     6b8:	88 23       	and	r24, r24
     6ba:	09 f0       	breq	.+2      	; 0x6be <prvCheckDelayedList+0x130>
     6bc:	a9 cf       	rjmp	.-174    	; 0x610 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     6be:	80 91 8f 00 	lds	r24, 0x008F
     6c2:	90 91 90 00 	lds	r25, 0x0090
     6c6:	00 97       	sbiw	r24, 0x00	; 0
     6c8:	09 f0       	breq	.+2      	; 0x6cc <prvCheckDelayedList+0x13e>
     6ca:	74 cf       	rjmp	.-280    	; 0x5b4 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     6cc:	80 91 8b 00 	lds	r24, 0x008B
     6d0:	90 91 8c 00 	lds	r25, 0x008C
     6d4:	90 93 8e 00 	sts	0x008E, r25
     6d8:	80 93 8d 00 	sts	0x008D, r24
}
     6dc:	0f 90       	pop	r0
     6de:	0f 90       	pop	r0
     6e0:	0f 90       	pop	r0
     6e2:	0f 90       	pop	r0
     6e4:	cf 91       	pop	r28
     6e6:	df 91       	pop	r29
     6e8:	08 95       	ret

000006ea <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     6ea:	df 93       	push	r29
     6ec:	cf 93       	push	r28
     6ee:	00 d0       	rcall	.+0      	; 0x6f0 <vCoRoutineSchedule+0x6>
     6f0:	cd b7       	in	r28, 0x3d	; 61
     6f2:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     6f4:	0e 94 7d 02 	call	0x4fa	; 0x4fa <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     6f8:	0e 94 c7 02 	call	0x58e	; 0x58e <prvCheckDelayedList>
     6fc:	0a c0       	rjmp	.+20     	; 0x712 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     6fe:	80 91 8a 00 	lds	r24, 0x008A
     702:	88 23       	and	r24, r24
     704:	09 f4       	brne	.+2      	; 0x708 <vCoRoutineSchedule+0x1e>
     706:	66 c0       	rjmp	.+204    	; 0x7d4 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     708:	80 91 8a 00 	lds	r24, 0x008A
     70c:	81 50       	subi	r24, 0x01	; 1
     70e:	80 93 8a 00 	sts	0x008A, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     712:	80 91 8a 00 	lds	r24, 0x008A
     716:	28 2f       	mov	r18, r24
     718:	30 e0       	ldi	r19, 0x00	; 0
     71a:	c9 01       	movw	r24, r18
     71c:	88 0f       	add	r24, r24
     71e:	99 1f       	adc	r25, r25
     720:	88 0f       	add	r24, r24
     722:	99 1f       	adc	r25, r25
     724:	88 0f       	add	r24, r24
     726:	99 1f       	adc	r25, r25
     728:	82 0f       	add	r24, r18
     72a:	93 1f       	adc	r25, r19
     72c:	fc 01       	movw	r30, r24
     72e:	ef 56       	subi	r30, 0x6F	; 111
     730:	ff 4f       	sbci	r31, 0xFF	; 255
     732:	80 81       	ld	r24, Z
     734:	88 23       	and	r24, r24
     736:	19 f3       	breq	.-58     	; 0x6fe <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     738:	80 91 8a 00 	lds	r24, 0x008A
     73c:	28 2f       	mov	r18, r24
     73e:	30 e0       	ldi	r19, 0x00	; 0
     740:	c9 01       	movw	r24, r18
     742:	88 0f       	add	r24, r24
     744:	99 1f       	adc	r25, r25
     746:	88 0f       	add	r24, r24
     748:	99 1f       	adc	r25, r25
     74a:	88 0f       	add	r24, r24
     74c:	99 1f       	adc	r25, r25
     74e:	82 0f       	add	r24, r18
     750:	93 1f       	adc	r25, r19
     752:	8f 56       	subi	r24, 0x6F	; 111
     754:	9f 4f       	sbci	r25, 0xFF	; 255
     756:	9a 83       	std	Y+2, r25	; 0x02
     758:	89 83       	std	Y+1, r24	; 0x01
     75a:	e9 81       	ldd	r30, Y+1	; 0x01
     75c:	fa 81       	ldd	r31, Y+2	; 0x02
     75e:	01 80       	ldd	r0, Z+1	; 0x01
     760:	f2 81       	ldd	r31, Z+2	; 0x02
     762:	e0 2d       	mov	r30, r0
     764:	82 81       	ldd	r24, Z+2	; 0x02
     766:	93 81       	ldd	r25, Z+3	; 0x03
     768:	e9 81       	ldd	r30, Y+1	; 0x01
     76a:	fa 81       	ldd	r31, Y+2	; 0x02
     76c:	92 83       	std	Z+2, r25	; 0x02
     76e:	81 83       	std	Z+1, r24	; 0x01
     770:	e9 81       	ldd	r30, Y+1	; 0x01
     772:	fa 81       	ldd	r31, Y+2	; 0x02
     774:	21 81       	ldd	r18, Z+1	; 0x01
     776:	32 81       	ldd	r19, Z+2	; 0x02
     778:	89 81       	ldd	r24, Y+1	; 0x01
     77a:	9a 81       	ldd	r25, Y+2	; 0x02
     77c:	03 96       	adiw	r24, 0x03	; 3
     77e:	28 17       	cp	r18, r24
     780:	39 07       	cpc	r19, r25
     782:	59 f4       	brne	.+22     	; 0x79a <vCoRoutineSchedule+0xb0>
     784:	e9 81       	ldd	r30, Y+1	; 0x01
     786:	fa 81       	ldd	r31, Y+2	; 0x02
     788:	01 80       	ldd	r0, Z+1	; 0x01
     78a:	f2 81       	ldd	r31, Z+2	; 0x02
     78c:	e0 2d       	mov	r30, r0
     78e:	82 81       	ldd	r24, Z+2	; 0x02
     790:	93 81       	ldd	r25, Z+3	; 0x03
     792:	e9 81       	ldd	r30, Y+1	; 0x01
     794:	fa 81       	ldd	r31, Y+2	; 0x02
     796:	92 83       	std	Z+2, r25	; 0x02
     798:	81 83       	std	Z+1, r24	; 0x01
     79a:	e9 81       	ldd	r30, Y+1	; 0x01
     79c:	fa 81       	ldd	r31, Y+2	; 0x02
     79e:	01 80       	ldd	r0, Z+1	; 0x01
     7a0:	f2 81       	ldd	r31, Z+2	; 0x02
     7a2:	e0 2d       	mov	r30, r0
     7a4:	86 81       	ldd	r24, Z+6	; 0x06
     7a6:	97 81       	ldd	r25, Z+7	; 0x07
     7a8:	90 93 89 00 	sts	0x0089, r25
     7ac:	80 93 88 00 	sts	0x0088, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     7b0:	e0 91 88 00 	lds	r30, 0x0088
     7b4:	f0 91 89 00 	lds	r31, 0x0089
     7b8:	40 81       	ld	r20, Z
     7ba:	51 81       	ldd	r21, Z+1	; 0x01
     7bc:	80 91 88 00 	lds	r24, 0x0088
     7c0:	90 91 89 00 	lds	r25, 0x0089
     7c4:	e0 91 88 00 	lds	r30, 0x0088
     7c8:	f0 91 89 00 	lds	r31, 0x0089
     7cc:	27 89       	ldd	r18, Z+23	; 0x17
     7ce:	62 2f       	mov	r22, r18
     7d0:	fa 01       	movw	r30, r20
     7d2:	09 95       	icall

	return;
}
     7d4:	0f 90       	pop	r0
     7d6:	0f 90       	pop	r0
     7d8:	cf 91       	pop	r28
     7da:	df 91       	pop	r29
     7dc:	08 95       	ret

000007de <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     7de:	df 93       	push	r29
     7e0:	cf 93       	push	r28
     7e2:	0f 92       	push	r0
     7e4:	cd b7       	in	r28, 0x3d	; 61
     7e6:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     7e8:	19 82       	std	Y+1, r1	; 0x01
     7ea:	13 c0       	rjmp	.+38     	; 0x812 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     7ec:	89 81       	ldd	r24, Y+1	; 0x01
     7ee:	28 2f       	mov	r18, r24
     7f0:	30 e0       	ldi	r19, 0x00	; 0
     7f2:	c9 01       	movw	r24, r18
     7f4:	88 0f       	add	r24, r24
     7f6:	99 1f       	adc	r25, r25
     7f8:	88 0f       	add	r24, r24
     7fa:	99 1f       	adc	r25, r25
     7fc:	88 0f       	add	r24, r24
     7fe:	99 1f       	adc	r25, r25
     800:	82 0f       	add	r24, r18
     802:	93 1f       	adc	r25, r19
     804:	8f 56       	subi	r24, 0x6F	; 111
     806:	9f 4f       	sbci	r25, 0xFF	; 255
     808:	0e 94 cc 04 	call	0x998	; 0x998 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     80c:	89 81       	ldd	r24, Y+1	; 0x01
     80e:	8f 5f       	subi	r24, 0xFF	; 255
     810:	89 83       	std	Y+1, r24	; 0x01
     812:	89 81       	ldd	r24, Y+1	; 0x01
     814:	82 30       	cpi	r24, 0x02	; 2
     816:	50 f3       	brcs	.-44     	; 0x7ec <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     818:	83 ea       	ldi	r24, 0xA3	; 163
     81a:	90 e0       	ldi	r25, 0x00	; 0
     81c:	0e 94 cc 04 	call	0x998	; 0x998 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     820:	8c ea       	ldi	r24, 0xAC	; 172
     822:	90 e0       	ldi	r25, 0x00	; 0
     824:	0e 94 cc 04 	call	0x998	; 0x998 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     828:	89 eb       	ldi	r24, 0xB9	; 185
     82a:	90 e0       	ldi	r25, 0x00	; 0
     82c:	0e 94 cc 04 	call	0x998	; 0x998 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     830:	83 ea       	ldi	r24, 0xA3	; 163
     832:	90 e0       	ldi	r25, 0x00	; 0
     834:	90 93 b6 00 	sts	0x00B6, r25
     838:	80 93 b5 00 	sts	0x00B5, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     83c:	8c ea       	ldi	r24, 0xAC	; 172
     83e:	90 e0       	ldi	r25, 0x00	; 0
     840:	90 93 b8 00 	sts	0x00B8, r25
     844:	80 93 b7 00 	sts	0x00B7, r24
}
     848:	0f 90       	pop	r0
     84a:	cf 91       	pop	r28
     84c:	df 91       	pop	r29
     84e:	08 95       	ret

00000850 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     850:	df 93       	push	r29
     852:	cf 93       	push	r28
     854:	00 d0       	rcall	.+0      	; 0x856 <xCoRoutineRemoveFromEventList+0x6>
     856:	00 d0       	rcall	.+0      	; 0x858 <xCoRoutineRemoveFromEventList+0x8>
     858:	0f 92       	push	r0
     85a:	cd b7       	in	r28, 0x3d	; 61
     85c:	de b7       	in	r29, 0x3e	; 62
     85e:	9d 83       	std	Y+5, r25	; 0x05
     860:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     862:	ec 81       	ldd	r30, Y+4	; 0x04
     864:	fd 81       	ldd	r31, Y+5	; 0x05
     866:	05 80       	ldd	r0, Z+5	; 0x05
     868:	f6 81       	ldd	r31, Z+6	; 0x06
     86a:	e0 2d       	mov	r30, r0
     86c:	86 81       	ldd	r24, Z+6	; 0x06
     86e:	97 81       	ldd	r25, Z+7	; 0x07
     870:	9b 83       	std	Y+3, r25	; 0x03
     872:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     874:	8a 81       	ldd	r24, Y+2	; 0x02
     876:	9b 81       	ldd	r25, Y+3	; 0x03
     878:	0c 96       	adiw	r24, 0x0c	; 12
     87a:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     87e:	8a 81       	ldd	r24, Y+2	; 0x02
     880:	9b 81       	ldd	r25, Y+3	; 0x03
     882:	9c 01       	movw	r18, r24
     884:	24 5f       	subi	r18, 0xF4	; 244
     886:	3f 4f       	sbci	r19, 0xFF	; 255
     888:	89 eb       	ldi	r24, 0xB9	; 185
     88a:	90 e0       	ldi	r25, 0x00	; 0
     88c:	b9 01       	movw	r22, r18
     88e:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     892:	ea 81       	ldd	r30, Y+2	; 0x02
     894:	fb 81       	ldd	r31, Y+3	; 0x03
     896:	96 89       	ldd	r25, Z+22	; 0x16
     898:	e0 91 88 00 	lds	r30, 0x0088
     89c:	f0 91 89 00 	lds	r31, 0x0089
     8a0:	86 89       	ldd	r24, Z+22	; 0x16
     8a2:	98 17       	cp	r25, r24
     8a4:	18 f0       	brcs	.+6      	; 0x8ac <__stack+0x4d>
	{
		xReturn = pdTRUE;
     8a6:	81 e0       	ldi	r24, 0x01	; 1
     8a8:	89 83       	std	Y+1, r24	; 0x01
     8aa:	01 c0       	rjmp	.+2      	; 0x8ae <__stack+0x4f>
	}
	else
	{
		xReturn = pdFALSE;
     8ac:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     8ae:	89 81       	ldd	r24, Y+1	; 0x01
}
     8b0:	0f 90       	pop	r0
     8b2:	0f 90       	pop	r0
     8b4:	0f 90       	pop	r0
     8b6:	0f 90       	pop	r0
     8b8:	0f 90       	pop	r0
     8ba:	cf 91       	pop	r28
     8bc:	df 91       	pop	r29
     8be:	08 95       	ret

000008c0 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     8c0:	df 93       	push	r29
     8c2:	cf 93       	push	r28
     8c4:	00 d0       	rcall	.+0      	; 0x8c6 <pvPortMalloc+0x6>
     8c6:	00 d0       	rcall	.+0      	; 0x8c8 <pvPortMalloc+0x8>
     8c8:	cd b7       	in	r28, 0x3d	; 61
     8ca:	de b7       	in	r29, 0x3e	; 62
     8cc:	9c 83       	std	Y+4, r25	; 0x04
     8ce:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     8d0:	1a 82       	std	Y+2, r1	; 0x02
     8d2:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     8d4:	0e 94 75 10 	call	0x20ea	; 0x20ea <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     8d8:	80 91 c2 00 	lds	r24, 0x00C2
     8dc:	90 91 c3 00 	lds	r25, 0x00C3
     8e0:	2b 81       	ldd	r18, Y+3	; 0x03
     8e2:	3c 81       	ldd	r19, Y+4	; 0x04
     8e4:	82 0f       	add	r24, r18
     8e6:	93 1f       	adc	r25, r19
     8e8:	22 e0       	ldi	r18, 0x02	; 2
     8ea:	88 35       	cpi	r24, 0x58	; 88
     8ec:	92 07       	cpc	r25, r18
     8ee:	18 f5       	brcc	.+70     	; 0x936 <pvPortMalloc+0x76>
     8f0:	20 91 c2 00 	lds	r18, 0x00C2
     8f4:	30 91 c3 00 	lds	r19, 0x00C3
     8f8:	8b 81       	ldd	r24, Y+3	; 0x03
     8fa:	9c 81       	ldd	r25, Y+4	; 0x04
     8fc:	28 0f       	add	r18, r24
     8fe:	39 1f       	adc	r19, r25
     900:	80 91 c2 00 	lds	r24, 0x00C2
     904:	90 91 c3 00 	lds	r25, 0x00C3
     908:	82 17       	cp	r24, r18
     90a:	93 07       	cpc	r25, r19
     90c:	a0 f4       	brcc	.+40     	; 0x936 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     90e:	80 91 c2 00 	lds	r24, 0x00C2
     912:	90 91 c3 00 	lds	r25, 0x00C3
     916:	8c 53       	subi	r24, 0x3C	; 60
     918:	9f 4f       	sbci	r25, 0xFF	; 255
     91a:	9a 83       	std	Y+2, r25	; 0x02
     91c:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     91e:	20 91 c2 00 	lds	r18, 0x00C2
     922:	30 91 c3 00 	lds	r19, 0x00C3
     926:	8b 81       	ldd	r24, Y+3	; 0x03
     928:	9c 81       	ldd	r25, Y+4	; 0x04
     92a:	82 0f       	add	r24, r18
     92c:	93 1f       	adc	r25, r19
     92e:	90 93 c3 00 	sts	0x00C3, r25
     932:	80 93 c2 00 	sts	0x00C2, r24
		}	
	}
	xTaskResumeAll();
     936:	0e 94 81 10 	call	0x2102	; 0x2102 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     93a:	89 81       	ldd	r24, Y+1	; 0x01
     93c:	9a 81       	ldd	r25, Y+2	; 0x02
}
     93e:	0f 90       	pop	r0
     940:	0f 90       	pop	r0
     942:	0f 90       	pop	r0
     944:	0f 90       	pop	r0
     946:	cf 91       	pop	r28
     948:	df 91       	pop	r29
     94a:	08 95       	ret

0000094c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     94c:	df 93       	push	r29
     94e:	cf 93       	push	r28
     950:	00 d0       	rcall	.+0      	; 0x952 <vPortFree+0x6>
     952:	cd b7       	in	r28, 0x3d	; 61
     954:	de b7       	in	r29, 0x3e	; 62
     956:	9a 83       	std	Y+2, r25	; 0x02
     958:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     95a:	0f 90       	pop	r0
     95c:	0f 90       	pop	r0
     95e:	cf 91       	pop	r28
     960:	df 91       	pop	r29
     962:	08 95       	ret

00000964 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     964:	df 93       	push	r29
     966:	cf 93       	push	r28
     968:	cd b7       	in	r28, 0x3d	; 61
     96a:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     96c:	10 92 c3 00 	sts	0x00C3, r1
     970:	10 92 c2 00 	sts	0x00C2, r1
}
     974:	cf 91       	pop	r28
     976:	df 91       	pop	r29
     978:	08 95       	ret

0000097a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     97a:	df 93       	push	r29
     97c:	cf 93       	push	r28
     97e:	cd b7       	in	r28, 0x3d	; 61
     980:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     982:	20 91 c2 00 	lds	r18, 0x00C2
     986:	30 91 c3 00 	lds	r19, 0x00C3
     98a:	88 e5       	ldi	r24, 0x58	; 88
     98c:	92 e0       	ldi	r25, 0x02	; 2
     98e:	82 1b       	sub	r24, r18
     990:	93 0b       	sbc	r25, r19
}
     992:	cf 91       	pop	r28
     994:	df 91       	pop	r29
     996:	08 95       	ret

00000998 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     998:	df 93       	push	r29
     99a:	cf 93       	push	r28
     99c:	00 d0       	rcall	.+0      	; 0x99e <vListInitialise+0x6>
     99e:	cd b7       	in	r28, 0x3d	; 61
     9a0:	de b7       	in	r29, 0x3e	; 62
     9a2:	9a 83       	std	Y+2, r25	; 0x02
     9a4:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     9a6:	89 81       	ldd	r24, Y+1	; 0x01
     9a8:	9a 81       	ldd	r25, Y+2	; 0x02
     9aa:	03 96       	adiw	r24, 0x03	; 3
     9ac:	e9 81       	ldd	r30, Y+1	; 0x01
     9ae:	fa 81       	ldd	r31, Y+2	; 0x02
     9b0:	92 83       	std	Z+2, r25	; 0x02
     9b2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     9b4:	e9 81       	ldd	r30, Y+1	; 0x01
     9b6:	fa 81       	ldd	r31, Y+2	; 0x02
     9b8:	8f ef       	ldi	r24, 0xFF	; 255
     9ba:	9f ef       	ldi	r25, 0xFF	; 255
     9bc:	94 83       	std	Z+4, r25	; 0x04
     9be:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     9c0:	89 81       	ldd	r24, Y+1	; 0x01
     9c2:	9a 81       	ldd	r25, Y+2	; 0x02
     9c4:	03 96       	adiw	r24, 0x03	; 3
     9c6:	e9 81       	ldd	r30, Y+1	; 0x01
     9c8:	fa 81       	ldd	r31, Y+2	; 0x02
     9ca:	96 83       	std	Z+6, r25	; 0x06
     9cc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     9ce:	89 81       	ldd	r24, Y+1	; 0x01
     9d0:	9a 81       	ldd	r25, Y+2	; 0x02
     9d2:	03 96       	adiw	r24, 0x03	; 3
     9d4:	e9 81       	ldd	r30, Y+1	; 0x01
     9d6:	fa 81       	ldd	r31, Y+2	; 0x02
     9d8:	90 87       	std	Z+8, r25	; 0x08
     9da:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     9dc:	e9 81       	ldd	r30, Y+1	; 0x01
     9de:	fa 81       	ldd	r31, Y+2	; 0x02
     9e0:	10 82       	st	Z, r1
}
     9e2:	0f 90       	pop	r0
     9e4:	0f 90       	pop	r0
     9e6:	cf 91       	pop	r28
     9e8:	df 91       	pop	r29
     9ea:	08 95       	ret

000009ec <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     9ec:	df 93       	push	r29
     9ee:	cf 93       	push	r28
     9f0:	00 d0       	rcall	.+0      	; 0x9f2 <vListInitialiseItem+0x6>
     9f2:	cd b7       	in	r28, 0x3d	; 61
     9f4:	de b7       	in	r29, 0x3e	; 62
     9f6:	9a 83       	std	Y+2, r25	; 0x02
     9f8:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     9fa:	e9 81       	ldd	r30, Y+1	; 0x01
     9fc:	fa 81       	ldd	r31, Y+2	; 0x02
     9fe:	11 86       	std	Z+9, r1	; 0x09
     a00:	10 86       	std	Z+8, r1	; 0x08
}
     a02:	0f 90       	pop	r0
     a04:	0f 90       	pop	r0
     a06:	cf 91       	pop	r28
     a08:	df 91       	pop	r29
     a0a:	08 95       	ret

00000a0c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     a0c:	df 93       	push	r29
     a0e:	cf 93       	push	r28
     a10:	00 d0       	rcall	.+0      	; 0xa12 <vListInsertEnd+0x6>
     a12:	00 d0       	rcall	.+0      	; 0xa14 <vListInsertEnd+0x8>
     a14:	00 d0       	rcall	.+0      	; 0xa16 <vListInsertEnd+0xa>
     a16:	cd b7       	in	r28, 0x3d	; 61
     a18:	de b7       	in	r29, 0x3e	; 62
     a1a:	9c 83       	std	Y+4, r25	; 0x04
     a1c:	8b 83       	std	Y+3, r24	; 0x03
     a1e:	7e 83       	std	Y+6, r23	; 0x06
     a20:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     a22:	eb 81       	ldd	r30, Y+3	; 0x03
     a24:	fc 81       	ldd	r31, Y+4	; 0x04
     a26:	81 81       	ldd	r24, Z+1	; 0x01
     a28:	92 81       	ldd	r25, Z+2	; 0x02
     a2a:	9a 83       	std	Y+2, r25	; 0x02
     a2c:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     a2e:	e9 81       	ldd	r30, Y+1	; 0x01
     a30:	fa 81       	ldd	r31, Y+2	; 0x02
     a32:	82 81       	ldd	r24, Z+2	; 0x02
     a34:	93 81       	ldd	r25, Z+3	; 0x03
     a36:	ed 81       	ldd	r30, Y+5	; 0x05
     a38:	fe 81       	ldd	r31, Y+6	; 0x06
     a3a:	93 83       	std	Z+3, r25	; 0x03
     a3c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     a3e:	eb 81       	ldd	r30, Y+3	; 0x03
     a40:	fc 81       	ldd	r31, Y+4	; 0x04
     a42:	81 81       	ldd	r24, Z+1	; 0x01
     a44:	92 81       	ldd	r25, Z+2	; 0x02
     a46:	ed 81       	ldd	r30, Y+5	; 0x05
     a48:	fe 81       	ldd	r31, Y+6	; 0x06
     a4a:	95 83       	std	Z+5, r25	; 0x05
     a4c:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     a4e:	e9 81       	ldd	r30, Y+1	; 0x01
     a50:	fa 81       	ldd	r31, Y+2	; 0x02
     a52:	02 80       	ldd	r0, Z+2	; 0x02
     a54:	f3 81       	ldd	r31, Z+3	; 0x03
     a56:	e0 2d       	mov	r30, r0
     a58:	8d 81       	ldd	r24, Y+5	; 0x05
     a5a:	9e 81       	ldd	r25, Y+6	; 0x06
     a5c:	95 83       	std	Z+5, r25	; 0x05
     a5e:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     a60:	8d 81       	ldd	r24, Y+5	; 0x05
     a62:	9e 81       	ldd	r25, Y+6	; 0x06
     a64:	e9 81       	ldd	r30, Y+1	; 0x01
     a66:	fa 81       	ldd	r31, Y+2	; 0x02
     a68:	93 83       	std	Z+3, r25	; 0x03
     a6a:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     a6c:	8d 81       	ldd	r24, Y+5	; 0x05
     a6e:	9e 81       	ldd	r25, Y+6	; 0x06
     a70:	eb 81       	ldd	r30, Y+3	; 0x03
     a72:	fc 81       	ldd	r31, Y+4	; 0x04
     a74:	92 83       	std	Z+2, r25	; 0x02
     a76:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a78:	ed 81       	ldd	r30, Y+5	; 0x05
     a7a:	fe 81       	ldd	r31, Y+6	; 0x06
     a7c:	8b 81       	ldd	r24, Y+3	; 0x03
     a7e:	9c 81       	ldd	r25, Y+4	; 0x04
     a80:	91 87       	std	Z+9, r25	; 0x09
     a82:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     a84:	eb 81       	ldd	r30, Y+3	; 0x03
     a86:	fc 81       	ldd	r31, Y+4	; 0x04
     a88:	80 81       	ld	r24, Z
     a8a:	8f 5f       	subi	r24, 0xFF	; 255
     a8c:	eb 81       	ldd	r30, Y+3	; 0x03
     a8e:	fc 81       	ldd	r31, Y+4	; 0x04
     a90:	80 83       	st	Z, r24
}
     a92:	26 96       	adiw	r28, 0x06	; 6
     a94:	0f b6       	in	r0, 0x3f	; 63
     a96:	f8 94       	cli
     a98:	de bf       	out	0x3e, r29	; 62
     a9a:	0f be       	out	0x3f, r0	; 63
     a9c:	cd bf       	out	0x3d, r28	; 61
     a9e:	cf 91       	pop	r28
     aa0:	df 91       	pop	r29
     aa2:	08 95       	ret

00000aa4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     aa4:	df 93       	push	r29
     aa6:	cf 93       	push	r28
     aa8:	cd b7       	in	r28, 0x3d	; 61
     aaa:	de b7       	in	r29, 0x3e	; 62
     aac:	28 97       	sbiw	r28, 0x08	; 8
     aae:	0f b6       	in	r0, 0x3f	; 63
     ab0:	f8 94       	cli
     ab2:	de bf       	out	0x3e, r29	; 62
     ab4:	0f be       	out	0x3f, r0	; 63
     ab6:	cd bf       	out	0x3d, r28	; 61
     ab8:	9e 83       	std	Y+6, r25	; 0x06
     aba:	8d 83       	std	Y+5, r24	; 0x05
     abc:	78 87       	std	Y+8, r23	; 0x08
     abe:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     ac0:	ef 81       	ldd	r30, Y+7	; 0x07
     ac2:	f8 85       	ldd	r31, Y+8	; 0x08
     ac4:	80 81       	ld	r24, Z
     ac6:	91 81       	ldd	r25, Z+1	; 0x01
     ac8:	9a 83       	std	Y+2, r25	; 0x02
     aca:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     acc:	89 81       	ldd	r24, Y+1	; 0x01
     ace:	9a 81       	ldd	r25, Y+2	; 0x02
     ad0:	2f ef       	ldi	r18, 0xFF	; 255
     ad2:	8f 3f       	cpi	r24, 0xFF	; 255
     ad4:	92 07       	cpc	r25, r18
     ad6:	39 f4       	brne	.+14     	; 0xae6 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     ad8:	ed 81       	ldd	r30, Y+5	; 0x05
     ada:	fe 81       	ldd	r31, Y+6	; 0x06
     adc:	87 81       	ldd	r24, Z+7	; 0x07
     ade:	90 85       	ldd	r25, Z+8	; 0x08
     ae0:	9c 83       	std	Y+4, r25	; 0x04
     ae2:	8b 83       	std	Y+3, r24	; 0x03
     ae4:	18 c0       	rjmp	.+48     	; 0xb16 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     ae6:	8d 81       	ldd	r24, Y+5	; 0x05
     ae8:	9e 81       	ldd	r25, Y+6	; 0x06
     aea:	03 96       	adiw	r24, 0x03	; 3
     aec:	9c 83       	std	Y+4, r25	; 0x04
     aee:	8b 83       	std	Y+3, r24	; 0x03
     af0:	06 c0       	rjmp	.+12     	; 0xafe <vListInsert+0x5a>
     af2:	eb 81       	ldd	r30, Y+3	; 0x03
     af4:	fc 81       	ldd	r31, Y+4	; 0x04
     af6:	82 81       	ldd	r24, Z+2	; 0x02
     af8:	93 81       	ldd	r25, Z+3	; 0x03
     afa:	9c 83       	std	Y+4, r25	; 0x04
     afc:	8b 83       	std	Y+3, r24	; 0x03
     afe:	eb 81       	ldd	r30, Y+3	; 0x03
     b00:	fc 81       	ldd	r31, Y+4	; 0x04
     b02:	02 80       	ldd	r0, Z+2	; 0x02
     b04:	f3 81       	ldd	r31, Z+3	; 0x03
     b06:	e0 2d       	mov	r30, r0
     b08:	20 81       	ld	r18, Z
     b0a:	31 81       	ldd	r19, Z+1	; 0x01
     b0c:	89 81       	ldd	r24, Y+1	; 0x01
     b0e:	9a 81       	ldd	r25, Y+2	; 0x02
     b10:	82 17       	cp	r24, r18
     b12:	93 07       	cpc	r25, r19
     b14:	70 f7       	brcc	.-36     	; 0xaf2 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     b16:	eb 81       	ldd	r30, Y+3	; 0x03
     b18:	fc 81       	ldd	r31, Y+4	; 0x04
     b1a:	82 81       	ldd	r24, Z+2	; 0x02
     b1c:	93 81       	ldd	r25, Z+3	; 0x03
     b1e:	ef 81       	ldd	r30, Y+7	; 0x07
     b20:	f8 85       	ldd	r31, Y+8	; 0x08
     b22:	93 83       	std	Z+3, r25	; 0x03
     b24:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     b26:	ef 81       	ldd	r30, Y+7	; 0x07
     b28:	f8 85       	ldd	r31, Y+8	; 0x08
     b2a:	02 80       	ldd	r0, Z+2	; 0x02
     b2c:	f3 81       	ldd	r31, Z+3	; 0x03
     b2e:	e0 2d       	mov	r30, r0
     b30:	8f 81       	ldd	r24, Y+7	; 0x07
     b32:	98 85       	ldd	r25, Y+8	; 0x08
     b34:	95 83       	std	Z+5, r25	; 0x05
     b36:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     b38:	ef 81       	ldd	r30, Y+7	; 0x07
     b3a:	f8 85       	ldd	r31, Y+8	; 0x08
     b3c:	8b 81       	ldd	r24, Y+3	; 0x03
     b3e:	9c 81       	ldd	r25, Y+4	; 0x04
     b40:	95 83       	std	Z+5, r25	; 0x05
     b42:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     b44:	8f 81       	ldd	r24, Y+7	; 0x07
     b46:	98 85       	ldd	r25, Y+8	; 0x08
     b48:	eb 81       	ldd	r30, Y+3	; 0x03
     b4a:	fc 81       	ldd	r31, Y+4	; 0x04
     b4c:	93 83       	std	Z+3, r25	; 0x03
     b4e:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     b50:	ef 81       	ldd	r30, Y+7	; 0x07
     b52:	f8 85       	ldd	r31, Y+8	; 0x08
     b54:	8d 81       	ldd	r24, Y+5	; 0x05
     b56:	9e 81       	ldd	r25, Y+6	; 0x06
     b58:	91 87       	std	Z+9, r25	; 0x09
     b5a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     b5c:	ed 81       	ldd	r30, Y+5	; 0x05
     b5e:	fe 81       	ldd	r31, Y+6	; 0x06
     b60:	80 81       	ld	r24, Z
     b62:	8f 5f       	subi	r24, 0xFF	; 255
     b64:	ed 81       	ldd	r30, Y+5	; 0x05
     b66:	fe 81       	ldd	r31, Y+6	; 0x06
     b68:	80 83       	st	Z, r24
}
     b6a:	28 96       	adiw	r28, 0x08	; 8
     b6c:	0f b6       	in	r0, 0x3f	; 63
     b6e:	f8 94       	cli
     b70:	de bf       	out	0x3e, r29	; 62
     b72:	0f be       	out	0x3f, r0	; 63
     b74:	cd bf       	out	0x3d, r28	; 61
     b76:	cf 91       	pop	r28
     b78:	df 91       	pop	r29
     b7a:	08 95       	ret

00000b7c <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     b7c:	df 93       	push	r29
     b7e:	cf 93       	push	r28
     b80:	00 d0       	rcall	.+0      	; 0xb82 <vListRemove+0x6>
     b82:	00 d0       	rcall	.+0      	; 0xb84 <vListRemove+0x8>
     b84:	cd b7       	in	r28, 0x3d	; 61
     b86:	de b7       	in	r29, 0x3e	; 62
     b88:	9c 83       	std	Y+4, r25	; 0x04
     b8a:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     b8c:	eb 81       	ldd	r30, Y+3	; 0x03
     b8e:	fc 81       	ldd	r31, Y+4	; 0x04
     b90:	a2 81       	ldd	r26, Z+2	; 0x02
     b92:	b3 81       	ldd	r27, Z+3	; 0x03
     b94:	eb 81       	ldd	r30, Y+3	; 0x03
     b96:	fc 81       	ldd	r31, Y+4	; 0x04
     b98:	84 81       	ldd	r24, Z+4	; 0x04
     b9a:	95 81       	ldd	r25, Z+5	; 0x05
     b9c:	15 96       	adiw	r26, 0x05	; 5
     b9e:	9c 93       	st	X, r25
     ba0:	8e 93       	st	-X, r24
     ba2:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     ba4:	eb 81       	ldd	r30, Y+3	; 0x03
     ba6:	fc 81       	ldd	r31, Y+4	; 0x04
     ba8:	a4 81       	ldd	r26, Z+4	; 0x04
     baa:	b5 81       	ldd	r27, Z+5	; 0x05
     bac:	eb 81       	ldd	r30, Y+3	; 0x03
     bae:	fc 81       	ldd	r31, Y+4	; 0x04
     bb0:	82 81       	ldd	r24, Z+2	; 0x02
     bb2:	93 81       	ldd	r25, Z+3	; 0x03
     bb4:	13 96       	adiw	r26, 0x03	; 3
     bb6:	9c 93       	st	X, r25
     bb8:	8e 93       	st	-X, r24
     bba:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     bbc:	eb 81       	ldd	r30, Y+3	; 0x03
     bbe:	fc 81       	ldd	r31, Y+4	; 0x04
     bc0:	80 85       	ldd	r24, Z+8	; 0x08
     bc2:	91 85       	ldd	r25, Z+9	; 0x09
     bc4:	9a 83       	std	Y+2, r25	; 0x02
     bc6:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     bc8:	e9 81       	ldd	r30, Y+1	; 0x01
     bca:	fa 81       	ldd	r31, Y+2	; 0x02
     bcc:	21 81       	ldd	r18, Z+1	; 0x01
     bce:	32 81       	ldd	r19, Z+2	; 0x02
     bd0:	8b 81       	ldd	r24, Y+3	; 0x03
     bd2:	9c 81       	ldd	r25, Y+4	; 0x04
     bd4:	28 17       	cp	r18, r24
     bd6:	39 07       	cpc	r19, r25
     bd8:	41 f4       	brne	.+16     	; 0xbea <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     bda:	eb 81       	ldd	r30, Y+3	; 0x03
     bdc:	fc 81       	ldd	r31, Y+4	; 0x04
     bde:	84 81       	ldd	r24, Z+4	; 0x04
     be0:	95 81       	ldd	r25, Z+5	; 0x05
     be2:	e9 81       	ldd	r30, Y+1	; 0x01
     be4:	fa 81       	ldd	r31, Y+2	; 0x02
     be6:	92 83       	std	Z+2, r25	; 0x02
     be8:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     bea:	eb 81       	ldd	r30, Y+3	; 0x03
     bec:	fc 81       	ldd	r31, Y+4	; 0x04
     bee:	11 86       	std	Z+9, r1	; 0x09
     bf0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     bf2:	e9 81       	ldd	r30, Y+1	; 0x01
     bf4:	fa 81       	ldd	r31, Y+2	; 0x02
     bf6:	80 81       	ld	r24, Z
     bf8:	81 50       	subi	r24, 0x01	; 1
     bfa:	e9 81       	ldd	r30, Y+1	; 0x01
     bfc:	fa 81       	ldd	r31, Y+2	; 0x02
     bfe:	80 83       	st	Z, r24
}
     c00:	0f 90       	pop	r0
     c02:	0f 90       	pop	r0
     c04:	0f 90       	pop	r0
     c06:	0f 90       	pop	r0
     c08:	cf 91       	pop	r28
     c0a:	df 91       	pop	r29
     c0c:	08 95       	ret

00000c0e <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
     c0e:	df 93       	push	r29
     c10:	cf 93       	push	r28
     c12:	cd b7       	in	r28, 0x3d	; 61
     c14:	de b7       	in	r29, 0x3e	; 62
     c16:	28 97       	sbiw	r28, 0x08	; 8
     c18:	0f b6       	in	r0, 0x3f	; 63
     c1a:	f8 94       	cli
     c1c:	de bf       	out	0x3e, r29	; 62
     c1e:	0f be       	out	0x3f, r0	; 63
     c20:	cd bf       	out	0x3d, r28	; 61
     c22:	9c 83       	std	Y+4, r25	; 0x04
     c24:	8b 83       	std	Y+3, r24	; 0x03
     c26:	7e 83       	std	Y+6, r23	; 0x06
     c28:	6d 83       	std	Y+5, r22	; 0x05
     c2a:	58 87       	std	Y+8, r21	; 0x08
     c2c:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     c2e:	eb 81       	ldd	r30, Y+3	; 0x03
     c30:	fc 81       	ldd	r31, Y+4	; 0x04
     c32:	81 e1       	ldi	r24, 0x11	; 17
     c34:	80 83       	st	Z, r24
	pxTopOfStack--;
     c36:	8b 81       	ldd	r24, Y+3	; 0x03
     c38:	9c 81       	ldd	r25, Y+4	; 0x04
     c3a:	01 97       	sbiw	r24, 0x01	; 1
     c3c:	9c 83       	std	Y+4, r25	; 0x04
     c3e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     c40:	eb 81       	ldd	r30, Y+3	; 0x03
     c42:	fc 81       	ldd	r31, Y+4	; 0x04
     c44:	82 e2       	ldi	r24, 0x22	; 34
     c46:	80 83       	st	Z, r24
	pxTopOfStack--;
     c48:	8b 81       	ldd	r24, Y+3	; 0x03
     c4a:	9c 81       	ldd	r25, Y+4	; 0x04
     c4c:	01 97       	sbiw	r24, 0x01	; 1
     c4e:	9c 83       	std	Y+4, r25	; 0x04
     c50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     c52:	eb 81       	ldd	r30, Y+3	; 0x03
     c54:	fc 81       	ldd	r31, Y+4	; 0x04
     c56:	83 e3       	ldi	r24, 0x33	; 51
     c58:	80 83       	st	Z, r24
	pxTopOfStack--;
     c5a:	8b 81       	ldd	r24, Y+3	; 0x03
     c5c:	9c 81       	ldd	r25, Y+4	; 0x04
     c5e:	01 97       	sbiw	r24, 0x01	; 1
     c60:	9c 83       	std	Y+4, r25	; 0x04
     c62:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
     c64:	8d 81       	ldd	r24, Y+5	; 0x05
     c66:	9e 81       	ldd	r25, Y+6	; 0x06
     c68:	9a 83       	std	Y+2, r25	; 0x02
     c6a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     c6c:	89 81       	ldd	r24, Y+1	; 0x01
     c6e:	eb 81       	ldd	r30, Y+3	; 0x03
     c70:	fc 81       	ldd	r31, Y+4	; 0x04
     c72:	80 83       	st	Z, r24
	pxTopOfStack--;
     c74:	8b 81       	ldd	r24, Y+3	; 0x03
     c76:	9c 81       	ldd	r25, Y+4	; 0x04
     c78:	01 97       	sbiw	r24, 0x01	; 1
     c7a:	9c 83       	std	Y+4, r25	; 0x04
     c7c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     c7e:	89 81       	ldd	r24, Y+1	; 0x01
     c80:	9a 81       	ldd	r25, Y+2	; 0x02
     c82:	89 2f       	mov	r24, r25
     c84:	99 27       	eor	r25, r25
     c86:	9a 83       	std	Y+2, r25	; 0x02
     c88:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     c8a:	89 81       	ldd	r24, Y+1	; 0x01
     c8c:	eb 81       	ldd	r30, Y+3	; 0x03
     c8e:	fc 81       	ldd	r31, Y+4	; 0x04
     c90:	80 83       	st	Z, r24
	pxTopOfStack--;
     c92:	8b 81       	ldd	r24, Y+3	; 0x03
     c94:	9c 81       	ldd	r25, Y+4	; 0x04
     c96:	01 97       	sbiw	r24, 0x01	; 1
     c98:	9c 83       	std	Y+4, r25	; 0x04
     c9a:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     c9c:	eb 81       	ldd	r30, Y+3	; 0x03
     c9e:	fc 81       	ldd	r31, Y+4	; 0x04
     ca0:	10 82       	st	Z, r1
	pxTopOfStack--;
     ca2:	8b 81       	ldd	r24, Y+3	; 0x03
     ca4:	9c 81       	ldd	r25, Y+4	; 0x04
     ca6:	01 97       	sbiw	r24, 0x01	; 1
     ca8:	9c 83       	std	Y+4, r25	; 0x04
     caa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     cac:	eb 81       	ldd	r30, Y+3	; 0x03
     cae:	fc 81       	ldd	r31, Y+4	; 0x04
     cb0:	80 e8       	ldi	r24, 0x80	; 128
     cb2:	80 83       	st	Z, r24
	pxTopOfStack--;
     cb4:	8b 81       	ldd	r24, Y+3	; 0x03
     cb6:	9c 81       	ldd	r25, Y+4	; 0x04
     cb8:	01 97       	sbiw	r24, 0x01	; 1
     cba:	9c 83       	std	Y+4, r25	; 0x04
     cbc:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     cbe:	eb 81       	ldd	r30, Y+3	; 0x03
     cc0:	fc 81       	ldd	r31, Y+4	; 0x04
     cc2:	10 82       	st	Z, r1
	pxTopOfStack--;
     cc4:	8b 81       	ldd	r24, Y+3	; 0x03
     cc6:	9c 81       	ldd	r25, Y+4	; 0x04
     cc8:	01 97       	sbiw	r24, 0x01	; 1
     cca:	9c 83       	std	Y+4, r25	; 0x04
     ccc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     cce:	eb 81       	ldd	r30, Y+3	; 0x03
     cd0:	fc 81       	ldd	r31, Y+4	; 0x04
     cd2:	82 e0       	ldi	r24, 0x02	; 2
     cd4:	80 83       	st	Z, r24
	pxTopOfStack--;
     cd6:	8b 81       	ldd	r24, Y+3	; 0x03
     cd8:	9c 81       	ldd	r25, Y+4	; 0x04
     cda:	01 97       	sbiw	r24, 0x01	; 1
     cdc:	9c 83       	std	Y+4, r25	; 0x04
     cde:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     ce0:	eb 81       	ldd	r30, Y+3	; 0x03
     ce2:	fc 81       	ldd	r31, Y+4	; 0x04
     ce4:	83 e0       	ldi	r24, 0x03	; 3
     ce6:	80 83       	st	Z, r24
	pxTopOfStack--;
     ce8:	8b 81       	ldd	r24, Y+3	; 0x03
     cea:	9c 81       	ldd	r25, Y+4	; 0x04
     cec:	01 97       	sbiw	r24, 0x01	; 1
     cee:	9c 83       	std	Y+4, r25	; 0x04
     cf0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     cf2:	eb 81       	ldd	r30, Y+3	; 0x03
     cf4:	fc 81       	ldd	r31, Y+4	; 0x04
     cf6:	84 e0       	ldi	r24, 0x04	; 4
     cf8:	80 83       	st	Z, r24
	pxTopOfStack--;
     cfa:	8b 81       	ldd	r24, Y+3	; 0x03
     cfc:	9c 81       	ldd	r25, Y+4	; 0x04
     cfe:	01 97       	sbiw	r24, 0x01	; 1
     d00:	9c 83       	std	Y+4, r25	; 0x04
     d02:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     d04:	eb 81       	ldd	r30, Y+3	; 0x03
     d06:	fc 81       	ldd	r31, Y+4	; 0x04
     d08:	85 e0       	ldi	r24, 0x05	; 5
     d0a:	80 83       	st	Z, r24
	pxTopOfStack--;
     d0c:	8b 81       	ldd	r24, Y+3	; 0x03
     d0e:	9c 81       	ldd	r25, Y+4	; 0x04
     d10:	01 97       	sbiw	r24, 0x01	; 1
     d12:	9c 83       	std	Y+4, r25	; 0x04
     d14:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     d16:	eb 81       	ldd	r30, Y+3	; 0x03
     d18:	fc 81       	ldd	r31, Y+4	; 0x04
     d1a:	86 e0       	ldi	r24, 0x06	; 6
     d1c:	80 83       	st	Z, r24
	pxTopOfStack--;
     d1e:	8b 81       	ldd	r24, Y+3	; 0x03
     d20:	9c 81       	ldd	r25, Y+4	; 0x04
     d22:	01 97       	sbiw	r24, 0x01	; 1
     d24:	9c 83       	std	Y+4, r25	; 0x04
     d26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     d28:	eb 81       	ldd	r30, Y+3	; 0x03
     d2a:	fc 81       	ldd	r31, Y+4	; 0x04
     d2c:	87 e0       	ldi	r24, 0x07	; 7
     d2e:	80 83       	st	Z, r24
	pxTopOfStack--;
     d30:	8b 81       	ldd	r24, Y+3	; 0x03
     d32:	9c 81       	ldd	r25, Y+4	; 0x04
     d34:	01 97       	sbiw	r24, 0x01	; 1
     d36:	9c 83       	std	Y+4, r25	; 0x04
     d38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     d3a:	eb 81       	ldd	r30, Y+3	; 0x03
     d3c:	fc 81       	ldd	r31, Y+4	; 0x04
     d3e:	88 e0       	ldi	r24, 0x08	; 8
     d40:	80 83       	st	Z, r24
	pxTopOfStack--;
     d42:	8b 81       	ldd	r24, Y+3	; 0x03
     d44:	9c 81       	ldd	r25, Y+4	; 0x04
     d46:	01 97       	sbiw	r24, 0x01	; 1
     d48:	9c 83       	std	Y+4, r25	; 0x04
     d4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     d4c:	eb 81       	ldd	r30, Y+3	; 0x03
     d4e:	fc 81       	ldd	r31, Y+4	; 0x04
     d50:	89 e0       	ldi	r24, 0x09	; 9
     d52:	80 83       	st	Z, r24
	pxTopOfStack--;
     d54:	8b 81       	ldd	r24, Y+3	; 0x03
     d56:	9c 81       	ldd	r25, Y+4	; 0x04
     d58:	01 97       	sbiw	r24, 0x01	; 1
     d5a:	9c 83       	std	Y+4, r25	; 0x04
     d5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     d5e:	eb 81       	ldd	r30, Y+3	; 0x03
     d60:	fc 81       	ldd	r31, Y+4	; 0x04
     d62:	80 e1       	ldi	r24, 0x10	; 16
     d64:	80 83       	st	Z, r24
	pxTopOfStack--;
     d66:	8b 81       	ldd	r24, Y+3	; 0x03
     d68:	9c 81       	ldd	r25, Y+4	; 0x04
     d6a:	01 97       	sbiw	r24, 0x01	; 1
     d6c:	9c 83       	std	Y+4, r25	; 0x04
     d6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     d70:	eb 81       	ldd	r30, Y+3	; 0x03
     d72:	fc 81       	ldd	r31, Y+4	; 0x04
     d74:	81 e1       	ldi	r24, 0x11	; 17
     d76:	80 83       	st	Z, r24
	pxTopOfStack--;
     d78:	8b 81       	ldd	r24, Y+3	; 0x03
     d7a:	9c 81       	ldd	r25, Y+4	; 0x04
     d7c:	01 97       	sbiw	r24, 0x01	; 1
     d7e:	9c 83       	std	Y+4, r25	; 0x04
     d80:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     d82:	eb 81       	ldd	r30, Y+3	; 0x03
     d84:	fc 81       	ldd	r31, Y+4	; 0x04
     d86:	82 e1       	ldi	r24, 0x12	; 18
     d88:	80 83       	st	Z, r24
	pxTopOfStack--;
     d8a:	8b 81       	ldd	r24, Y+3	; 0x03
     d8c:	9c 81       	ldd	r25, Y+4	; 0x04
     d8e:	01 97       	sbiw	r24, 0x01	; 1
     d90:	9c 83       	std	Y+4, r25	; 0x04
     d92:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     d94:	eb 81       	ldd	r30, Y+3	; 0x03
     d96:	fc 81       	ldd	r31, Y+4	; 0x04
     d98:	83 e1       	ldi	r24, 0x13	; 19
     d9a:	80 83       	st	Z, r24
	pxTopOfStack--;
     d9c:	8b 81       	ldd	r24, Y+3	; 0x03
     d9e:	9c 81       	ldd	r25, Y+4	; 0x04
     da0:	01 97       	sbiw	r24, 0x01	; 1
     da2:	9c 83       	std	Y+4, r25	; 0x04
     da4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     da6:	eb 81       	ldd	r30, Y+3	; 0x03
     da8:	fc 81       	ldd	r31, Y+4	; 0x04
     daa:	84 e1       	ldi	r24, 0x14	; 20
     dac:	80 83       	st	Z, r24
	pxTopOfStack--;
     dae:	8b 81       	ldd	r24, Y+3	; 0x03
     db0:	9c 81       	ldd	r25, Y+4	; 0x04
     db2:	01 97       	sbiw	r24, 0x01	; 1
     db4:	9c 83       	std	Y+4, r25	; 0x04
     db6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     db8:	eb 81       	ldd	r30, Y+3	; 0x03
     dba:	fc 81       	ldd	r31, Y+4	; 0x04
     dbc:	85 e1       	ldi	r24, 0x15	; 21
     dbe:	80 83       	st	Z, r24
	pxTopOfStack--;
     dc0:	8b 81       	ldd	r24, Y+3	; 0x03
     dc2:	9c 81       	ldd	r25, Y+4	; 0x04
     dc4:	01 97       	sbiw	r24, 0x01	; 1
     dc6:	9c 83       	std	Y+4, r25	; 0x04
     dc8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     dca:	eb 81       	ldd	r30, Y+3	; 0x03
     dcc:	fc 81       	ldd	r31, Y+4	; 0x04
     dce:	86 e1       	ldi	r24, 0x16	; 22
     dd0:	80 83       	st	Z, r24
	pxTopOfStack--;
     dd2:	8b 81       	ldd	r24, Y+3	; 0x03
     dd4:	9c 81       	ldd	r25, Y+4	; 0x04
     dd6:	01 97       	sbiw	r24, 0x01	; 1
     dd8:	9c 83       	std	Y+4, r25	; 0x04
     dda:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     ddc:	eb 81       	ldd	r30, Y+3	; 0x03
     dde:	fc 81       	ldd	r31, Y+4	; 0x04
     de0:	87 e1       	ldi	r24, 0x17	; 23
     de2:	80 83       	st	Z, r24
	pxTopOfStack--;
     de4:	8b 81       	ldd	r24, Y+3	; 0x03
     de6:	9c 81       	ldd	r25, Y+4	; 0x04
     de8:	01 97       	sbiw	r24, 0x01	; 1
     dea:	9c 83       	std	Y+4, r25	; 0x04
     dec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     dee:	eb 81       	ldd	r30, Y+3	; 0x03
     df0:	fc 81       	ldd	r31, Y+4	; 0x04
     df2:	88 e1       	ldi	r24, 0x18	; 24
     df4:	80 83       	st	Z, r24
	pxTopOfStack--;
     df6:	8b 81       	ldd	r24, Y+3	; 0x03
     df8:	9c 81       	ldd	r25, Y+4	; 0x04
     dfa:	01 97       	sbiw	r24, 0x01	; 1
     dfc:	9c 83       	std	Y+4, r25	; 0x04
     dfe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     e00:	eb 81       	ldd	r30, Y+3	; 0x03
     e02:	fc 81       	ldd	r31, Y+4	; 0x04
     e04:	89 e1       	ldi	r24, 0x19	; 25
     e06:	80 83       	st	Z, r24
	pxTopOfStack--;
     e08:	8b 81       	ldd	r24, Y+3	; 0x03
     e0a:	9c 81       	ldd	r25, Y+4	; 0x04
     e0c:	01 97       	sbiw	r24, 0x01	; 1
     e0e:	9c 83       	std	Y+4, r25	; 0x04
     e10:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     e12:	eb 81       	ldd	r30, Y+3	; 0x03
     e14:	fc 81       	ldd	r31, Y+4	; 0x04
     e16:	80 e2       	ldi	r24, 0x20	; 32
     e18:	80 83       	st	Z, r24
	pxTopOfStack--;
     e1a:	8b 81       	ldd	r24, Y+3	; 0x03
     e1c:	9c 81       	ldd	r25, Y+4	; 0x04
     e1e:	01 97       	sbiw	r24, 0x01	; 1
     e20:	9c 83       	std	Y+4, r25	; 0x04
     e22:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     e24:	eb 81       	ldd	r30, Y+3	; 0x03
     e26:	fc 81       	ldd	r31, Y+4	; 0x04
     e28:	81 e2       	ldi	r24, 0x21	; 33
     e2a:	80 83       	st	Z, r24
	pxTopOfStack--;
     e2c:	8b 81       	ldd	r24, Y+3	; 0x03
     e2e:	9c 81       	ldd	r25, Y+4	; 0x04
     e30:	01 97       	sbiw	r24, 0x01	; 1
     e32:	9c 83       	std	Y+4, r25	; 0x04
     e34:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     e36:	eb 81       	ldd	r30, Y+3	; 0x03
     e38:	fc 81       	ldd	r31, Y+4	; 0x04
     e3a:	82 e2       	ldi	r24, 0x22	; 34
     e3c:	80 83       	st	Z, r24
	pxTopOfStack--;
     e3e:	8b 81       	ldd	r24, Y+3	; 0x03
     e40:	9c 81       	ldd	r25, Y+4	; 0x04
     e42:	01 97       	sbiw	r24, 0x01	; 1
     e44:	9c 83       	std	Y+4, r25	; 0x04
     e46:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     e48:	eb 81       	ldd	r30, Y+3	; 0x03
     e4a:	fc 81       	ldd	r31, Y+4	; 0x04
     e4c:	83 e2       	ldi	r24, 0x23	; 35
     e4e:	80 83       	st	Z, r24
	pxTopOfStack--;
     e50:	8b 81       	ldd	r24, Y+3	; 0x03
     e52:	9c 81       	ldd	r25, Y+4	; 0x04
     e54:	01 97       	sbiw	r24, 0x01	; 1
     e56:	9c 83       	std	Y+4, r25	; 0x04
     e58:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
     e5a:	8f 81       	ldd	r24, Y+7	; 0x07
     e5c:	98 85       	ldd	r25, Y+8	; 0x08
     e5e:	9a 83       	std	Y+2, r25	; 0x02
     e60:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     e62:	89 81       	ldd	r24, Y+1	; 0x01
     e64:	eb 81       	ldd	r30, Y+3	; 0x03
     e66:	fc 81       	ldd	r31, Y+4	; 0x04
     e68:	80 83       	st	Z, r24
	pxTopOfStack--;
     e6a:	8b 81       	ldd	r24, Y+3	; 0x03
     e6c:	9c 81       	ldd	r25, Y+4	; 0x04
     e6e:	01 97       	sbiw	r24, 0x01	; 1
     e70:	9c 83       	std	Y+4, r25	; 0x04
     e72:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     e74:	89 81       	ldd	r24, Y+1	; 0x01
     e76:	9a 81       	ldd	r25, Y+2	; 0x02
     e78:	89 2f       	mov	r24, r25
     e7a:	99 27       	eor	r25, r25
     e7c:	9a 83       	std	Y+2, r25	; 0x02
     e7e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     e80:	89 81       	ldd	r24, Y+1	; 0x01
     e82:	eb 81       	ldd	r30, Y+3	; 0x03
     e84:	fc 81       	ldd	r31, Y+4	; 0x04
     e86:	80 83       	st	Z, r24
	pxTopOfStack--;
     e88:	8b 81       	ldd	r24, Y+3	; 0x03
     e8a:	9c 81       	ldd	r25, Y+4	; 0x04
     e8c:	01 97       	sbiw	r24, 0x01	; 1
     e8e:	9c 83       	std	Y+4, r25	; 0x04
     e90:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     e92:	eb 81       	ldd	r30, Y+3	; 0x03
     e94:	fc 81       	ldd	r31, Y+4	; 0x04
     e96:	86 e2       	ldi	r24, 0x26	; 38
     e98:	80 83       	st	Z, r24
	pxTopOfStack--;
     e9a:	8b 81       	ldd	r24, Y+3	; 0x03
     e9c:	9c 81       	ldd	r25, Y+4	; 0x04
     e9e:	01 97       	sbiw	r24, 0x01	; 1
     ea0:	9c 83       	std	Y+4, r25	; 0x04
     ea2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     ea4:	eb 81       	ldd	r30, Y+3	; 0x03
     ea6:	fc 81       	ldd	r31, Y+4	; 0x04
     ea8:	87 e2       	ldi	r24, 0x27	; 39
     eaa:	80 83       	st	Z, r24
	pxTopOfStack--;
     eac:	8b 81       	ldd	r24, Y+3	; 0x03
     eae:	9c 81       	ldd	r25, Y+4	; 0x04
     eb0:	01 97       	sbiw	r24, 0x01	; 1
     eb2:	9c 83       	std	Y+4, r25	; 0x04
     eb4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     eb6:	eb 81       	ldd	r30, Y+3	; 0x03
     eb8:	fc 81       	ldd	r31, Y+4	; 0x04
     eba:	88 e2       	ldi	r24, 0x28	; 40
     ebc:	80 83       	st	Z, r24
	pxTopOfStack--;
     ebe:	8b 81       	ldd	r24, Y+3	; 0x03
     ec0:	9c 81       	ldd	r25, Y+4	; 0x04
     ec2:	01 97       	sbiw	r24, 0x01	; 1
     ec4:	9c 83       	std	Y+4, r25	; 0x04
     ec6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     ec8:	eb 81       	ldd	r30, Y+3	; 0x03
     eca:	fc 81       	ldd	r31, Y+4	; 0x04
     ecc:	89 e2       	ldi	r24, 0x29	; 41
     ece:	80 83       	st	Z, r24
	pxTopOfStack--;
     ed0:	8b 81       	ldd	r24, Y+3	; 0x03
     ed2:	9c 81       	ldd	r25, Y+4	; 0x04
     ed4:	01 97       	sbiw	r24, 0x01	; 1
     ed6:	9c 83       	std	Y+4, r25	; 0x04
     ed8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     eda:	eb 81       	ldd	r30, Y+3	; 0x03
     edc:	fc 81       	ldd	r31, Y+4	; 0x04
     ede:	80 e3       	ldi	r24, 0x30	; 48
     ee0:	80 83       	st	Z, r24
	pxTopOfStack--;
     ee2:	8b 81       	ldd	r24, Y+3	; 0x03
     ee4:	9c 81       	ldd	r25, Y+4	; 0x04
     ee6:	01 97       	sbiw	r24, 0x01	; 1
     ee8:	9c 83       	std	Y+4, r25	; 0x04
     eea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     eec:	eb 81       	ldd	r30, Y+3	; 0x03
     eee:	fc 81       	ldd	r31, Y+4	; 0x04
     ef0:	81 e3       	ldi	r24, 0x31	; 49
     ef2:	80 83       	st	Z, r24
	pxTopOfStack--;
     ef4:	8b 81       	ldd	r24, Y+3	; 0x03
     ef6:	9c 81       	ldd	r25, Y+4	; 0x04
     ef8:	01 97       	sbiw	r24, 0x01	; 1
     efa:	9c 83       	std	Y+4, r25	; 0x04
     efc:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     efe:	8b 81       	ldd	r24, Y+3	; 0x03
     f00:	9c 81       	ldd	r25, Y+4	; 0x04
}
     f02:	28 96       	adiw	r28, 0x08	; 8
     f04:	0f b6       	in	r0, 0x3f	; 63
     f06:	f8 94       	cli
     f08:	de bf       	out	0x3e, r29	; 62
     f0a:	0f be       	out	0x3f, r0	; 63
     f0c:	cd bf       	out	0x3d, r28	; 61
     f0e:	cf 91       	pop	r28
     f10:	df 91       	pop	r29
     f12:	08 95       	ret

00000f14 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
     f14:	df 93       	push	r29
     f16:	cf 93       	push	r28
     f18:	cd b7       	in	r28, 0x3d	; 61
     f1a:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     f1c:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     f20:	a0 91 1c 03 	lds	r26, 0x031C
     f24:	b0 91 1d 03 	lds	r27, 0x031D
     f28:	cd 91       	ld	r28, X+
     f2a:	cd bf       	out	0x3d, r28	; 61
     f2c:	dd 91       	ld	r29, X+
     f2e:	de bf       	out	0x3e, r29	; 62
     f30:	ff 91       	pop	r31
     f32:	ef 91       	pop	r30
     f34:	df 91       	pop	r29
     f36:	cf 91       	pop	r28
     f38:	bf 91       	pop	r27
     f3a:	af 91       	pop	r26
     f3c:	9f 91       	pop	r25
     f3e:	8f 91       	pop	r24
     f40:	7f 91       	pop	r23
     f42:	6f 91       	pop	r22
     f44:	5f 91       	pop	r21
     f46:	4f 91       	pop	r20
     f48:	3f 91       	pop	r19
     f4a:	2f 91       	pop	r18
     f4c:	1f 91       	pop	r17
     f4e:	0f 91       	pop	r16
     f50:	ff 90       	pop	r15
     f52:	ef 90       	pop	r14
     f54:	df 90       	pop	r13
     f56:	cf 90       	pop	r12
     f58:	bf 90       	pop	r11
     f5a:	af 90       	pop	r10
     f5c:	9f 90       	pop	r9
     f5e:	8f 90       	pop	r8
     f60:	7f 90       	pop	r7
     f62:	6f 90       	pop	r6
     f64:	5f 90       	pop	r5
     f66:	4f 90       	pop	r4
     f68:	3f 90       	pop	r3
     f6a:	2f 90       	pop	r2
     f6c:	1f 90       	pop	r1
     f6e:	0f 90       	pop	r0
     f70:	0f be       	out	0x3f, r0	; 63
     f72:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     f74:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     f76:	81 e0       	ldi	r24, 0x01	; 1
}
     f78:	cf 91       	pop	r28
     f7a:	df 91       	pop	r29
     f7c:	08 95       	ret

00000f7e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     f7e:	df 93       	push	r29
     f80:	cf 93       	push	r28
     f82:	cd b7       	in	r28, 0x3d	; 61
     f84:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     f86:	cf 91       	pop	r28
     f88:	df 91       	pop	r29
     f8a:	08 95       	ret

00000f8c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     f8c:	0f 92       	push	r0
     f8e:	0f b6       	in	r0, 0x3f	; 63
     f90:	f8 94       	cli
     f92:	0f 92       	push	r0
     f94:	1f 92       	push	r1
     f96:	11 24       	eor	r1, r1
     f98:	2f 92       	push	r2
     f9a:	3f 92       	push	r3
     f9c:	4f 92       	push	r4
     f9e:	5f 92       	push	r5
     fa0:	6f 92       	push	r6
     fa2:	7f 92       	push	r7
     fa4:	8f 92       	push	r8
     fa6:	9f 92       	push	r9
     fa8:	af 92       	push	r10
     faa:	bf 92       	push	r11
     fac:	cf 92       	push	r12
     fae:	df 92       	push	r13
     fb0:	ef 92       	push	r14
     fb2:	ff 92       	push	r15
     fb4:	0f 93       	push	r16
     fb6:	1f 93       	push	r17
     fb8:	2f 93       	push	r18
     fba:	3f 93       	push	r19
     fbc:	4f 93       	push	r20
     fbe:	5f 93       	push	r21
     fc0:	6f 93       	push	r22
     fc2:	7f 93       	push	r23
     fc4:	8f 93       	push	r24
     fc6:	9f 93       	push	r25
     fc8:	af 93       	push	r26
     fca:	bf 93       	push	r27
     fcc:	cf 93       	push	r28
     fce:	df 93       	push	r29
     fd0:	ef 93       	push	r30
     fd2:	ff 93       	push	r31
     fd4:	a0 91 1c 03 	lds	r26, 0x031C
     fd8:	b0 91 1d 03 	lds	r27, 0x031D
     fdc:	0d b6       	in	r0, 0x3d	; 61
     fde:	0d 92       	st	X+, r0
     fe0:	0e b6       	in	r0, 0x3e	; 62
     fe2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     fe4:	0e 94 15 12 	call	0x242a	; 0x242a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     fe8:	a0 91 1c 03 	lds	r26, 0x031C
     fec:	b0 91 1d 03 	lds	r27, 0x031D
     ff0:	cd 91       	ld	r28, X+
     ff2:	cd bf       	out	0x3d, r28	; 61
     ff4:	dd 91       	ld	r29, X+
     ff6:	de bf       	out	0x3e, r29	; 62
     ff8:	ff 91       	pop	r31
     ffa:	ef 91       	pop	r30
     ffc:	df 91       	pop	r29
     ffe:	cf 91       	pop	r28
    1000:	bf 91       	pop	r27
    1002:	af 91       	pop	r26
    1004:	9f 91       	pop	r25
    1006:	8f 91       	pop	r24
    1008:	7f 91       	pop	r23
    100a:	6f 91       	pop	r22
    100c:	5f 91       	pop	r21
    100e:	4f 91       	pop	r20
    1010:	3f 91       	pop	r19
    1012:	2f 91       	pop	r18
    1014:	1f 91       	pop	r17
    1016:	0f 91       	pop	r16
    1018:	ff 90       	pop	r15
    101a:	ef 90       	pop	r14
    101c:	df 90       	pop	r13
    101e:	cf 90       	pop	r12
    1020:	bf 90       	pop	r11
    1022:	af 90       	pop	r10
    1024:	9f 90       	pop	r9
    1026:	8f 90       	pop	r8
    1028:	7f 90       	pop	r7
    102a:	6f 90       	pop	r6
    102c:	5f 90       	pop	r5
    102e:	4f 90       	pop	r4
    1030:	3f 90       	pop	r3
    1032:	2f 90       	pop	r2
    1034:	1f 90       	pop	r1
    1036:	0f 90       	pop	r0
    1038:	0f be       	out	0x3f, r0	; 63
    103a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    103c:	08 95       	ret

0000103e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    103e:	0f 92       	push	r0
    1040:	0f b6       	in	r0, 0x3f	; 63
    1042:	f8 94       	cli
    1044:	0f 92       	push	r0
    1046:	1f 92       	push	r1
    1048:	11 24       	eor	r1, r1
    104a:	2f 92       	push	r2
    104c:	3f 92       	push	r3
    104e:	4f 92       	push	r4
    1050:	5f 92       	push	r5
    1052:	6f 92       	push	r6
    1054:	7f 92       	push	r7
    1056:	8f 92       	push	r8
    1058:	9f 92       	push	r9
    105a:	af 92       	push	r10
    105c:	bf 92       	push	r11
    105e:	cf 92       	push	r12
    1060:	df 92       	push	r13
    1062:	ef 92       	push	r14
    1064:	ff 92       	push	r15
    1066:	0f 93       	push	r16
    1068:	1f 93       	push	r17
    106a:	2f 93       	push	r18
    106c:	3f 93       	push	r19
    106e:	4f 93       	push	r20
    1070:	5f 93       	push	r21
    1072:	6f 93       	push	r22
    1074:	7f 93       	push	r23
    1076:	8f 93       	push	r24
    1078:	9f 93       	push	r25
    107a:	af 93       	push	r26
    107c:	bf 93       	push	r27
    107e:	cf 93       	push	r28
    1080:	df 93       	push	r29
    1082:	ef 93       	push	r30
    1084:	ff 93       	push	r31
    1086:	a0 91 1c 03 	lds	r26, 0x031C
    108a:	b0 91 1d 03 	lds	r27, 0x031D
    108e:	0d b6       	in	r0, 0x3d	; 61
    1090:	0d 92       	st	X+, r0
    1092:	0e b6       	in	r0, 0x3e	; 62
    1094:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1096:	0e 94 40 11 	call	0x2280	; 0x2280 <vTaskIncrementTick>
	vTaskSwitchContext();
    109a:	0e 94 15 12 	call	0x242a	; 0x242a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    109e:	a0 91 1c 03 	lds	r26, 0x031C
    10a2:	b0 91 1d 03 	lds	r27, 0x031D
    10a6:	cd 91       	ld	r28, X+
    10a8:	cd bf       	out	0x3d, r28	; 61
    10aa:	dd 91       	ld	r29, X+
    10ac:	de bf       	out	0x3e, r29	; 62
    10ae:	ff 91       	pop	r31
    10b0:	ef 91       	pop	r30
    10b2:	df 91       	pop	r29
    10b4:	cf 91       	pop	r28
    10b6:	bf 91       	pop	r27
    10b8:	af 91       	pop	r26
    10ba:	9f 91       	pop	r25
    10bc:	8f 91       	pop	r24
    10be:	7f 91       	pop	r23
    10c0:	6f 91       	pop	r22
    10c2:	5f 91       	pop	r21
    10c4:	4f 91       	pop	r20
    10c6:	3f 91       	pop	r19
    10c8:	2f 91       	pop	r18
    10ca:	1f 91       	pop	r17
    10cc:	0f 91       	pop	r16
    10ce:	ff 90       	pop	r15
    10d0:	ef 90       	pop	r14
    10d2:	df 90       	pop	r13
    10d4:	cf 90       	pop	r12
    10d6:	bf 90       	pop	r11
    10d8:	af 90       	pop	r10
    10da:	9f 90       	pop	r9
    10dc:	8f 90       	pop	r8
    10de:	7f 90       	pop	r7
    10e0:	6f 90       	pop	r6
    10e2:	5f 90       	pop	r5
    10e4:	4f 90       	pop	r4
    10e6:	3f 90       	pop	r3
    10e8:	2f 90       	pop	r2
    10ea:	1f 90       	pop	r1
    10ec:	0f 90       	pop	r0
    10ee:	0f be       	out	0x3f, r0	; 63
    10f0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    10f2:	08 95       	ret

000010f4 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    10f4:	df 93       	push	r29
    10f6:	cf 93       	push	r28
    10f8:	00 d0       	rcall	.+0      	; 0x10fa <prvSetupTimerInterrupt+0x6>
    10fa:	00 d0       	rcall	.+0      	; 0x10fc <prvSetupTimerInterrupt+0x8>
    10fc:	00 d0       	rcall	.+0      	; 0x10fe <prvSetupTimerInterrupt+0xa>
    10fe:	cd b7       	in	r28, 0x3d	; 61
    1100:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1102:	80 e4       	ldi	r24, 0x40	; 64
    1104:	9f e1       	ldi	r25, 0x1F	; 31
    1106:	a0 e0       	ldi	r26, 0x00	; 0
    1108:	b0 e0       	ldi	r27, 0x00	; 0
    110a:	8b 83       	std	Y+3, r24	; 0x03
    110c:	9c 83       	std	Y+4, r25	; 0x04
    110e:	ad 83       	std	Y+5, r26	; 0x05
    1110:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1112:	8b 81       	ldd	r24, Y+3	; 0x03
    1114:	9c 81       	ldd	r25, Y+4	; 0x04
    1116:	ad 81       	ldd	r26, Y+5	; 0x05
    1118:	be 81       	ldd	r27, Y+6	; 0x06
    111a:	68 94       	set
    111c:	15 f8       	bld	r1, 5
    111e:	b6 95       	lsr	r27
    1120:	a7 95       	ror	r26
    1122:	97 95       	ror	r25
    1124:	87 95       	ror	r24
    1126:	16 94       	lsr	r1
    1128:	d1 f7       	brne	.-12     	; 0x111e <prvSetupTimerInterrupt+0x2a>
    112a:	8b 83       	std	Y+3, r24	; 0x03
    112c:	9c 83       	std	Y+4, r25	; 0x04
    112e:	ad 83       	std	Y+5, r26	; 0x05
    1130:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    1132:	8b 81       	ldd	r24, Y+3	; 0x03
    1134:	9c 81       	ldd	r25, Y+4	; 0x04
    1136:	ad 81       	ldd	r26, Y+5	; 0x05
    1138:	be 81       	ldd	r27, Y+6	; 0x06
    113a:	01 97       	sbiw	r24, 0x01	; 1
    113c:	a1 09       	sbc	r26, r1
    113e:	b1 09       	sbc	r27, r1
    1140:	8b 83       	std	Y+3, r24	; 0x03
    1142:	9c 83       	std	Y+4, r25	; 0x04
    1144:	ad 83       	std	Y+5, r26	; 0x05
    1146:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1148:	8b 81       	ldd	r24, Y+3	; 0x03
    114a:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    114c:	8b 81       	ldd	r24, Y+3	; 0x03
    114e:	9c 81       	ldd	r25, Y+4	; 0x04
    1150:	ad 81       	ldd	r26, Y+5	; 0x05
    1152:	be 81       	ldd	r27, Y+6	; 0x06
    1154:	89 2f       	mov	r24, r25
    1156:	9a 2f       	mov	r25, r26
    1158:	ab 2f       	mov	r26, r27
    115a:	bb 27       	eor	r27, r27
    115c:	8b 83       	std	Y+3, r24	; 0x03
    115e:	9c 83       	std	Y+4, r25	; 0x04
    1160:	ad 83       	std	Y+5, r26	; 0x05
    1162:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1164:	8b 81       	ldd	r24, Y+3	; 0x03
    1166:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1168:	eb e4       	ldi	r30, 0x4B	; 75
    116a:	f0 e0       	ldi	r31, 0x00	; 0
    116c:	8a 81       	ldd	r24, Y+2	; 0x02
    116e:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1170:	ea e4       	ldi	r30, 0x4A	; 74
    1172:	f0 e0       	ldi	r31, 0x00	; 0
    1174:	89 81       	ldd	r24, Y+1	; 0x01
    1176:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1178:	8b e0       	ldi	r24, 0x0B	; 11
    117a:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    117c:	ee e4       	ldi	r30, 0x4E	; 78
    117e:	f0 e0       	ldi	r31, 0x00	; 0
    1180:	89 81       	ldd	r24, Y+1	; 0x01
    1182:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1184:	e9 e5       	ldi	r30, 0x59	; 89
    1186:	f0 e0       	ldi	r31, 0x00	; 0
    1188:	80 81       	ld	r24, Z
    118a:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    118c:	89 81       	ldd	r24, Y+1	; 0x01
    118e:	80 61       	ori	r24, 0x10	; 16
    1190:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1192:	e9 e5       	ldi	r30, 0x59	; 89
    1194:	f0 e0       	ldi	r31, 0x00	; 0
    1196:	89 81       	ldd	r24, Y+1	; 0x01
    1198:	80 83       	st	Z, r24
}
    119a:	26 96       	adiw	r28, 0x06	; 6
    119c:	0f b6       	in	r0, 0x3f	; 63
    119e:	f8 94       	cli
    11a0:	de bf       	out	0x3e, r29	; 62
    11a2:	0f be       	out	0x3f, r0	; 63
    11a4:	cd bf       	out	0x3d, r28	; 61
    11a6:	cf 91       	pop	r28
    11a8:	df 91       	pop	r29
    11aa:	08 95       	ret

000011ac <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    11ac:	0e 94 1f 08 	call	0x103e	; 0x103e <vPortYieldFromTick>
		asm volatile ( "reti" );
    11b0:	18 95       	reti

000011b2 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    11b2:	df 93       	push	r29
    11b4:	cf 93       	push	r28
    11b6:	cd b7       	in	r28, 0x3d	; 61
    11b8:	de b7       	in	r29, 0x3e	; 62
    11ba:	28 97       	sbiw	r28, 0x08	; 8
    11bc:	0f b6       	in	r0, 0x3f	; 63
    11be:	f8 94       	cli
    11c0:	de bf       	out	0x3e, r29	; 62
    11c2:	0f be       	out	0x3f, r0	; 63
    11c4:	cd bf       	out	0x3d, r28	; 61
    11c6:	8f 83       	std	Y+7, r24	; 0x07
    11c8:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    11ca:	1a 82       	std	Y+2, r1	; 0x02
    11cc:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    11ce:	8f 81       	ldd	r24, Y+7	; 0x07
    11d0:	88 23       	and	r24, r24
    11d2:	09 f4       	brne	.+2      	; 0x11d6 <xQueueCreate+0x24>
    11d4:	8c c0       	rjmp	.+280    	; 0x12ee <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    11d6:	8f e1       	ldi	r24, 0x1F	; 31
    11d8:	90 e0       	ldi	r25, 0x00	; 0
    11da:	0e 94 60 04 	call	0x8c0	; 0x8c0 <pvPortMalloc>
    11de:	9e 83       	std	Y+6, r25	; 0x06
    11e0:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    11e2:	8d 81       	ldd	r24, Y+5	; 0x05
    11e4:	9e 81       	ldd	r25, Y+6	; 0x06
    11e6:	00 97       	sbiw	r24, 0x00	; 0
    11e8:	09 f4       	brne	.+2      	; 0x11ec <xQueueCreate+0x3a>
    11ea:	81 c0       	rjmp	.+258    	; 0x12ee <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    11ec:	8f 81       	ldd	r24, Y+7	; 0x07
    11ee:	28 2f       	mov	r18, r24
    11f0:	30 e0       	ldi	r19, 0x00	; 0
    11f2:	88 85       	ldd	r24, Y+8	; 0x08
    11f4:	88 2f       	mov	r24, r24
    11f6:	90 e0       	ldi	r25, 0x00	; 0
    11f8:	ac 01       	movw	r20, r24
    11fa:	24 9f       	mul	r18, r20
    11fc:	c0 01       	movw	r24, r0
    11fe:	25 9f       	mul	r18, r21
    1200:	90 0d       	add	r25, r0
    1202:	34 9f       	mul	r19, r20
    1204:	90 0d       	add	r25, r0
    1206:	11 24       	eor	r1, r1
    1208:	01 96       	adiw	r24, 0x01	; 1
    120a:	9c 83       	std	Y+4, r25	; 0x04
    120c:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    120e:	8b 81       	ldd	r24, Y+3	; 0x03
    1210:	9c 81       	ldd	r25, Y+4	; 0x04
    1212:	0e 94 60 04 	call	0x8c0	; 0x8c0 <pvPortMalloc>
    1216:	ed 81       	ldd	r30, Y+5	; 0x05
    1218:	fe 81       	ldd	r31, Y+6	; 0x06
    121a:	91 83       	std	Z+1, r25	; 0x01
    121c:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    121e:	ed 81       	ldd	r30, Y+5	; 0x05
    1220:	fe 81       	ldd	r31, Y+6	; 0x06
    1222:	80 81       	ld	r24, Z
    1224:	91 81       	ldd	r25, Z+1	; 0x01
    1226:	00 97       	sbiw	r24, 0x00	; 0
    1228:	09 f4       	brne	.+2      	; 0x122c <xQueueCreate+0x7a>
    122a:	5d c0       	rjmp	.+186    	; 0x12e6 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    122c:	ed 81       	ldd	r30, Y+5	; 0x05
    122e:	fe 81       	ldd	r31, Y+6	; 0x06
    1230:	40 81       	ld	r20, Z
    1232:	51 81       	ldd	r21, Z+1	; 0x01
    1234:	8f 81       	ldd	r24, Y+7	; 0x07
    1236:	28 2f       	mov	r18, r24
    1238:	30 e0       	ldi	r19, 0x00	; 0
    123a:	88 85       	ldd	r24, Y+8	; 0x08
    123c:	88 2f       	mov	r24, r24
    123e:	90 e0       	ldi	r25, 0x00	; 0
    1240:	bc 01       	movw	r22, r24
    1242:	26 9f       	mul	r18, r22
    1244:	c0 01       	movw	r24, r0
    1246:	27 9f       	mul	r18, r23
    1248:	90 0d       	add	r25, r0
    124a:	36 9f       	mul	r19, r22
    124c:	90 0d       	add	r25, r0
    124e:	11 24       	eor	r1, r1
    1250:	84 0f       	add	r24, r20
    1252:	95 1f       	adc	r25, r21
    1254:	ed 81       	ldd	r30, Y+5	; 0x05
    1256:	fe 81       	ldd	r31, Y+6	; 0x06
    1258:	93 83       	std	Z+3, r25	; 0x03
    125a:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    125c:	ed 81       	ldd	r30, Y+5	; 0x05
    125e:	fe 81       	ldd	r31, Y+6	; 0x06
    1260:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1262:	ed 81       	ldd	r30, Y+5	; 0x05
    1264:	fe 81       	ldd	r31, Y+6	; 0x06
    1266:	80 81       	ld	r24, Z
    1268:	91 81       	ldd	r25, Z+1	; 0x01
    126a:	ed 81       	ldd	r30, Y+5	; 0x05
    126c:	fe 81       	ldd	r31, Y+6	; 0x06
    126e:	95 83       	std	Z+5, r25	; 0x05
    1270:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    1272:	ed 81       	ldd	r30, Y+5	; 0x05
    1274:	fe 81       	ldd	r31, Y+6	; 0x06
    1276:	40 81       	ld	r20, Z
    1278:	51 81       	ldd	r21, Z+1	; 0x01
    127a:	8f 81       	ldd	r24, Y+7	; 0x07
    127c:	88 2f       	mov	r24, r24
    127e:	90 e0       	ldi	r25, 0x00	; 0
    1280:	9c 01       	movw	r18, r24
    1282:	21 50       	subi	r18, 0x01	; 1
    1284:	30 40       	sbci	r19, 0x00	; 0
    1286:	88 85       	ldd	r24, Y+8	; 0x08
    1288:	88 2f       	mov	r24, r24
    128a:	90 e0       	ldi	r25, 0x00	; 0
    128c:	bc 01       	movw	r22, r24
    128e:	26 9f       	mul	r18, r22
    1290:	c0 01       	movw	r24, r0
    1292:	27 9f       	mul	r18, r23
    1294:	90 0d       	add	r25, r0
    1296:	36 9f       	mul	r19, r22
    1298:	90 0d       	add	r25, r0
    129a:	11 24       	eor	r1, r1
    129c:	84 0f       	add	r24, r20
    129e:	95 1f       	adc	r25, r21
    12a0:	ed 81       	ldd	r30, Y+5	; 0x05
    12a2:	fe 81       	ldd	r31, Y+6	; 0x06
    12a4:	97 83       	std	Z+7, r25	; 0x07
    12a6:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    12a8:	ed 81       	ldd	r30, Y+5	; 0x05
    12aa:	fe 81       	ldd	r31, Y+6	; 0x06
    12ac:	8f 81       	ldd	r24, Y+7	; 0x07
    12ae:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    12b0:	ed 81       	ldd	r30, Y+5	; 0x05
    12b2:	fe 81       	ldd	r31, Y+6	; 0x06
    12b4:	88 85       	ldd	r24, Y+8	; 0x08
    12b6:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    12b8:	ed 81       	ldd	r30, Y+5	; 0x05
    12ba:	fe 81       	ldd	r31, Y+6	; 0x06
    12bc:	8f ef       	ldi	r24, 0xFF	; 255
    12be:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    12c0:	ed 81       	ldd	r30, Y+5	; 0x05
    12c2:	fe 81       	ldd	r31, Y+6	; 0x06
    12c4:	8f ef       	ldi	r24, 0xFF	; 255
    12c6:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    12c8:	8d 81       	ldd	r24, Y+5	; 0x05
    12ca:	9e 81       	ldd	r25, Y+6	; 0x06
    12cc:	08 96       	adiw	r24, 0x08	; 8
    12ce:	0e 94 cc 04 	call	0x998	; 0x998 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    12d2:	8d 81       	ldd	r24, Y+5	; 0x05
    12d4:	9e 81       	ldd	r25, Y+6	; 0x06
    12d6:	41 96       	adiw	r24, 0x11	; 17
    12d8:	0e 94 cc 04 	call	0x998	; 0x998 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    12dc:	8d 81       	ldd	r24, Y+5	; 0x05
    12de:	9e 81       	ldd	r25, Y+6	; 0x06
    12e0:	9a 83       	std	Y+2, r25	; 0x02
    12e2:	89 83       	std	Y+1, r24	; 0x01
    12e4:	04 c0       	rjmp	.+8      	; 0x12ee <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    12e6:	8d 81       	ldd	r24, Y+5	; 0x05
    12e8:	9e 81       	ldd	r25, Y+6	; 0x06
    12ea:	0e 94 a6 04 	call	0x94c	; 0x94c <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    12ee:	89 81       	ldd	r24, Y+1	; 0x01
    12f0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    12f2:	28 96       	adiw	r28, 0x08	; 8
    12f4:	0f b6       	in	r0, 0x3f	; 63
    12f6:	f8 94       	cli
    12f8:	de bf       	out	0x3e, r29	; 62
    12fa:	0f be       	out	0x3f, r0	; 63
    12fc:	cd bf       	out	0x3d, r28	; 61
    12fe:	cf 91       	pop	r28
    1300:	df 91       	pop	r29
    1302:	08 95       	ret

00001304 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1304:	df 93       	push	r29
    1306:	cf 93       	push	r28
    1308:	cd b7       	in	r28, 0x3d	; 61
    130a:	de b7       	in	r29, 0x3e	; 62
    130c:	2c 97       	sbiw	r28, 0x0c	; 12
    130e:	0f b6       	in	r0, 0x3f	; 63
    1310:	f8 94       	cli
    1312:	de bf       	out	0x3e, r29	; 62
    1314:	0f be       	out	0x3f, r0	; 63
    1316:	cd bf       	out	0x3d, r28	; 61
    1318:	9e 83       	std	Y+6, r25	; 0x06
    131a:	8d 83       	std	Y+5, r24	; 0x05
    131c:	78 87       	std	Y+8, r23	; 0x08
    131e:	6f 83       	std	Y+7, r22	; 0x07
    1320:	5a 87       	std	Y+10, r21	; 0x0a
    1322:	49 87       	std	Y+9, r20	; 0x09
    1324:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1326:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1328:	0f b6       	in	r0, 0x3f	; 63
    132a:	f8 94       	cli
    132c:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    132e:	ed 81       	ldd	r30, Y+5	; 0x05
    1330:	fe 81       	ldd	r31, Y+6	; 0x06
    1332:	92 8d       	ldd	r25, Z+26	; 0x1a
    1334:	ed 81       	ldd	r30, Y+5	; 0x05
    1336:	fe 81       	ldd	r31, Y+6	; 0x06
    1338:	83 8d       	ldd	r24, Z+27	; 0x1b
    133a:	98 17       	cp	r25, r24
    133c:	d8 f4       	brcc	.+54     	; 0x1374 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    133e:	8d 81       	ldd	r24, Y+5	; 0x05
    1340:	9e 81       	ldd	r25, Y+6	; 0x06
    1342:	2f 81       	ldd	r18, Y+7	; 0x07
    1344:	38 85       	ldd	r19, Y+8	; 0x08
    1346:	b9 01       	movw	r22, r18
    1348:	4b 85       	ldd	r20, Y+11	; 0x0b
    134a:	0e 94 bd 0b 	call	0x177a	; 0x177a <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    134e:	ed 81       	ldd	r30, Y+5	; 0x05
    1350:	fe 81       	ldd	r31, Y+6	; 0x06
    1352:	81 89       	ldd	r24, Z+17	; 0x11
    1354:	88 23       	and	r24, r24
    1356:	49 f0       	breq	.+18     	; 0x136a <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1358:	8d 81       	ldd	r24, Y+5	; 0x05
    135a:	9e 81       	ldd	r25, Y+6	; 0x06
    135c:	41 96       	adiw	r24, 0x11	; 17
    135e:	0e 94 b1 12 	call	0x2562	; 0x2562 <xTaskRemoveFromEventList>
    1362:	81 30       	cpi	r24, 0x01	; 1
    1364:	11 f4       	brne	.+4      	; 0x136a <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1366:	0e 94 c6 07 	call	0xf8c	; 0xf8c <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    136a:	0f 90       	pop	r0
    136c:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    136e:	81 e0       	ldi	r24, 0x01	; 1
    1370:	8c 87       	std	Y+12, r24	; 0x0c
    1372:	5c c0       	rjmp	.+184    	; 0x142c <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1374:	89 85       	ldd	r24, Y+9	; 0x09
    1376:	9a 85       	ldd	r25, Y+10	; 0x0a
    1378:	00 97       	sbiw	r24, 0x00	; 0
    137a:	21 f4       	brne	.+8      	; 0x1384 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    137c:	0f 90       	pop	r0
    137e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1380:	1c 86       	std	Y+12, r1	; 0x0c
    1382:	54 c0       	rjmp	.+168    	; 0x142c <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    1384:	89 81       	ldd	r24, Y+1	; 0x01
    1386:	88 23       	and	r24, r24
    1388:	31 f4       	brne	.+12     	; 0x1396 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    138a:	ce 01       	movw	r24, r28
    138c:	02 96       	adiw	r24, 0x02	; 2
    138e:	0e 94 19 13 	call	0x2632	; 0x2632 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1392:	81 e0       	ldi	r24, 0x01	; 1
    1394:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1396:	0f 90       	pop	r0
    1398:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    139a:	0e 94 75 10 	call	0x20ea	; 0x20ea <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    139e:	0f b6       	in	r0, 0x3f	; 63
    13a0:	f8 94       	cli
    13a2:	0f 92       	push	r0
    13a4:	ed 81       	ldd	r30, Y+5	; 0x05
    13a6:	fe 81       	ldd	r31, Y+6	; 0x06
    13a8:	85 8d       	ldd	r24, Z+29	; 0x1d
    13aa:	8f 3f       	cpi	r24, 0xFF	; 255
    13ac:	19 f4       	brne	.+6      	; 0x13b4 <xQueueGenericSend+0xb0>
    13ae:	ed 81       	ldd	r30, Y+5	; 0x05
    13b0:	fe 81       	ldd	r31, Y+6	; 0x06
    13b2:	15 8e       	std	Z+29, r1	; 0x1d
    13b4:	ed 81       	ldd	r30, Y+5	; 0x05
    13b6:	fe 81       	ldd	r31, Y+6	; 0x06
    13b8:	86 8d       	ldd	r24, Z+30	; 0x1e
    13ba:	8f 3f       	cpi	r24, 0xFF	; 255
    13bc:	19 f4       	brne	.+6      	; 0x13c4 <xQueueGenericSend+0xc0>
    13be:	ed 81       	ldd	r30, Y+5	; 0x05
    13c0:	fe 81       	ldd	r31, Y+6	; 0x06
    13c2:	16 8e       	std	Z+30, r1	; 0x1e
    13c4:	0f 90       	pop	r0
    13c6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    13c8:	ce 01       	movw	r24, r28
    13ca:	02 96       	adiw	r24, 0x02	; 2
    13cc:	9e 01       	movw	r18, r28
    13ce:	27 5f       	subi	r18, 0xF7	; 247
    13d0:	3f 4f       	sbci	r19, 0xFF	; 255
    13d2:	b9 01       	movw	r22, r18
    13d4:	0e 94 32 13 	call	0x2664	; 0x2664 <xTaskCheckForTimeOut>
    13d8:	88 23       	and	r24, r24
    13da:	09 f5       	brne	.+66     	; 0x141e <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    13dc:	8d 81       	ldd	r24, Y+5	; 0x05
    13de:	9e 81       	ldd	r25, Y+6	; 0x06
    13e0:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <prvIsQueueFull>
    13e4:	88 23       	and	r24, r24
    13e6:	a1 f0       	breq	.+40     	; 0x1410 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    13e8:	8d 81       	ldd	r24, Y+5	; 0x05
    13ea:	9e 81       	ldd	r25, Y+6	; 0x06
    13ec:	08 96       	adiw	r24, 0x08	; 8
    13ee:	29 85       	ldd	r18, Y+9	; 0x09
    13f0:	3a 85       	ldd	r19, Y+10	; 0x0a
    13f2:	b9 01       	movw	r22, r18
    13f4:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    13f8:	8d 81       	ldd	r24, Y+5	; 0x05
    13fa:	9e 81       	ldd	r25, Y+6	; 0x06
    13fc:	0e 94 9a 0c 	call	0x1934	; 0x1934 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1400:	0e 94 81 10 	call	0x2102	; 0x2102 <xTaskResumeAll>
    1404:	88 23       	and	r24, r24
    1406:	09 f0       	breq	.+2      	; 0x140a <xQueueGenericSend+0x106>
    1408:	8f cf       	rjmp	.-226    	; 0x1328 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    140a:	0e 94 c6 07 	call	0xf8c	; 0xf8c <vPortYield>
    140e:	8c cf       	rjmp	.-232    	; 0x1328 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1410:	8d 81       	ldd	r24, Y+5	; 0x05
    1412:	9e 81       	ldd	r25, Y+6	; 0x06
    1414:	0e 94 9a 0c 	call	0x1934	; 0x1934 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1418:	0e 94 81 10 	call	0x2102	; 0x2102 <xTaskResumeAll>
    141c:	85 cf       	rjmp	.-246    	; 0x1328 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    141e:	8d 81       	ldd	r24, Y+5	; 0x05
    1420:	9e 81       	ldd	r25, Y+6	; 0x06
    1422:	0e 94 9a 0c 	call	0x1934	; 0x1934 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1426:	0e 94 81 10 	call	0x2102	; 0x2102 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    142a:	1c 86       	std	Y+12, r1	; 0x0c
    142c:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    142e:	2c 96       	adiw	r28, 0x0c	; 12
    1430:	0f b6       	in	r0, 0x3f	; 63
    1432:	f8 94       	cli
    1434:	de bf       	out	0x3e, r29	; 62
    1436:	0f be       	out	0x3f, r0	; 63
    1438:	cd bf       	out	0x3d, r28	; 61
    143a:	cf 91       	pop	r28
    143c:	df 91       	pop	r29
    143e:	08 95       	ret

00001440 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1440:	df 93       	push	r29
    1442:	cf 93       	push	r28
    1444:	cd b7       	in	r28, 0x3d	; 61
    1446:	de b7       	in	r29, 0x3e	; 62
    1448:	29 97       	sbiw	r28, 0x09	; 9
    144a:	0f b6       	in	r0, 0x3f	; 63
    144c:	f8 94       	cli
    144e:	de bf       	out	0x3e, r29	; 62
    1450:	0f be       	out	0x3f, r0	; 63
    1452:	cd bf       	out	0x3d, r28	; 61
    1454:	9c 83       	std	Y+4, r25	; 0x04
    1456:	8b 83       	std	Y+3, r24	; 0x03
    1458:	7e 83       	std	Y+6, r23	; 0x06
    145a:	6d 83       	std	Y+5, r22	; 0x05
    145c:	58 87       	std	Y+8, r21	; 0x08
    145e:	4f 83       	std	Y+7, r20	; 0x07
    1460:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1462:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1464:	eb 81       	ldd	r30, Y+3	; 0x03
    1466:	fc 81       	ldd	r31, Y+4	; 0x04
    1468:	92 8d       	ldd	r25, Z+26	; 0x1a
    146a:	eb 81       	ldd	r30, Y+3	; 0x03
    146c:	fc 81       	ldd	r31, Y+4	; 0x04
    146e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1470:	98 17       	cp	r25, r24
    1472:	40 f5       	brcc	.+80     	; 0x14c4 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1474:	8b 81       	ldd	r24, Y+3	; 0x03
    1476:	9c 81       	ldd	r25, Y+4	; 0x04
    1478:	2d 81       	ldd	r18, Y+5	; 0x05
    147a:	3e 81       	ldd	r19, Y+6	; 0x06
    147c:	b9 01       	movw	r22, r18
    147e:	49 85       	ldd	r20, Y+9	; 0x09
    1480:	0e 94 bd 0b 	call	0x177a	; 0x177a <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1484:	eb 81       	ldd	r30, Y+3	; 0x03
    1486:	fc 81       	ldd	r31, Y+4	; 0x04
    1488:	86 8d       	ldd	r24, Z+30	; 0x1e
    148a:	8f 3f       	cpi	r24, 0xFF	; 255
    148c:	89 f4       	brne	.+34     	; 0x14b0 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    148e:	eb 81       	ldd	r30, Y+3	; 0x03
    1490:	fc 81       	ldd	r31, Y+4	; 0x04
    1492:	81 89       	ldd	r24, Z+17	; 0x11
    1494:	88 23       	and	r24, r24
    1496:	99 f0       	breq	.+38     	; 0x14be <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1498:	8b 81       	ldd	r24, Y+3	; 0x03
    149a:	9c 81       	ldd	r25, Y+4	; 0x04
    149c:	41 96       	adiw	r24, 0x11	; 17
    149e:	0e 94 b1 12 	call	0x2562	; 0x2562 <xTaskRemoveFromEventList>
    14a2:	88 23       	and	r24, r24
    14a4:	61 f0       	breq	.+24     	; 0x14be <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    14a6:	ef 81       	ldd	r30, Y+7	; 0x07
    14a8:	f8 85       	ldd	r31, Y+8	; 0x08
    14aa:	81 e0       	ldi	r24, 0x01	; 1
    14ac:	80 83       	st	Z, r24
    14ae:	07 c0       	rjmp	.+14     	; 0x14be <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    14b0:	eb 81       	ldd	r30, Y+3	; 0x03
    14b2:	fc 81       	ldd	r31, Y+4	; 0x04
    14b4:	86 8d       	ldd	r24, Z+30	; 0x1e
    14b6:	8f 5f       	subi	r24, 0xFF	; 255
    14b8:	eb 81       	ldd	r30, Y+3	; 0x03
    14ba:	fc 81       	ldd	r31, Y+4	; 0x04
    14bc:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    14be:	81 e0       	ldi	r24, 0x01	; 1
    14c0:	8a 83       	std	Y+2, r24	; 0x02
    14c2:	01 c0       	rjmp	.+2      	; 0x14c6 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    14c4:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    14c6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    14c8:	29 96       	adiw	r28, 0x09	; 9
    14ca:	0f b6       	in	r0, 0x3f	; 63
    14cc:	f8 94       	cli
    14ce:	de bf       	out	0x3e, r29	; 62
    14d0:	0f be       	out	0x3f, r0	; 63
    14d2:	cd bf       	out	0x3d, r28	; 61
    14d4:	cf 91       	pop	r28
    14d6:	df 91       	pop	r29
    14d8:	08 95       	ret

000014da <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    14da:	df 93       	push	r29
    14dc:	cf 93       	push	r28
    14de:	cd b7       	in	r28, 0x3d	; 61
    14e0:	de b7       	in	r29, 0x3e	; 62
    14e2:	2e 97       	sbiw	r28, 0x0e	; 14
    14e4:	0f b6       	in	r0, 0x3f	; 63
    14e6:	f8 94       	cli
    14e8:	de bf       	out	0x3e, r29	; 62
    14ea:	0f be       	out	0x3f, r0	; 63
    14ec:	cd bf       	out	0x3d, r28	; 61
    14ee:	98 87       	std	Y+8, r25	; 0x08
    14f0:	8f 83       	std	Y+7, r24	; 0x07
    14f2:	7a 87       	std	Y+10, r23	; 0x0a
    14f4:	69 87       	std	Y+9, r22	; 0x09
    14f6:	5c 87       	std	Y+12, r21	; 0x0c
    14f8:	4b 87       	std	Y+11, r20	; 0x0b
    14fa:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    14fc:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    14fe:	0f b6       	in	r0, 0x3f	; 63
    1500:	f8 94       	cli
    1502:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1504:	ef 81       	ldd	r30, Y+7	; 0x07
    1506:	f8 85       	ldd	r31, Y+8	; 0x08
    1508:	82 8d       	ldd	r24, Z+26	; 0x1a
    150a:	88 23       	and	r24, r24
    150c:	09 f4       	brne	.+2      	; 0x1510 <xQueueGenericReceive+0x36>
    150e:	3f c0       	rjmp	.+126    	; 0x158e <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1510:	ef 81       	ldd	r30, Y+7	; 0x07
    1512:	f8 85       	ldd	r31, Y+8	; 0x08
    1514:	86 81       	ldd	r24, Z+6	; 0x06
    1516:	97 81       	ldd	r25, Z+7	; 0x07
    1518:	9a 83       	std	Y+2, r25	; 0x02
    151a:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    151c:	8f 81       	ldd	r24, Y+7	; 0x07
    151e:	98 85       	ldd	r25, Y+8	; 0x08
    1520:	29 85       	ldd	r18, Y+9	; 0x09
    1522:	3a 85       	ldd	r19, Y+10	; 0x0a
    1524:	b9 01       	movw	r22, r18
    1526:	0e 94 52 0c 	call	0x18a4	; 0x18a4 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    152a:	8d 85       	ldd	r24, Y+13	; 0x0d
    152c:	88 23       	and	r24, r24
    152e:	b1 f4       	brne	.+44     	; 0x155c <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1530:	ef 81       	ldd	r30, Y+7	; 0x07
    1532:	f8 85       	ldd	r31, Y+8	; 0x08
    1534:	82 8d       	ldd	r24, Z+26	; 0x1a
    1536:	81 50       	subi	r24, 0x01	; 1
    1538:	ef 81       	ldd	r30, Y+7	; 0x07
    153a:	f8 85       	ldd	r31, Y+8	; 0x08
    153c:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    153e:	ef 81       	ldd	r30, Y+7	; 0x07
    1540:	f8 85       	ldd	r31, Y+8	; 0x08
    1542:	80 85       	ldd	r24, Z+8	; 0x08
    1544:	88 23       	and	r24, r24
    1546:	f1 f0       	breq	.+60     	; 0x1584 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1548:	8f 81       	ldd	r24, Y+7	; 0x07
    154a:	98 85       	ldd	r25, Y+8	; 0x08
    154c:	08 96       	adiw	r24, 0x08	; 8
    154e:	0e 94 b1 12 	call	0x2562	; 0x2562 <xTaskRemoveFromEventList>
    1552:	81 30       	cpi	r24, 0x01	; 1
    1554:	b9 f4       	brne	.+46     	; 0x1584 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    1556:	0e 94 c6 07 	call	0xf8c	; 0xf8c <vPortYield>
    155a:	14 c0       	rjmp	.+40     	; 0x1584 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    155c:	ef 81       	ldd	r30, Y+7	; 0x07
    155e:	f8 85       	ldd	r31, Y+8	; 0x08
    1560:	89 81       	ldd	r24, Y+1	; 0x01
    1562:	9a 81       	ldd	r25, Y+2	; 0x02
    1564:	97 83       	std	Z+7, r25	; 0x07
    1566:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1568:	ef 81       	ldd	r30, Y+7	; 0x07
    156a:	f8 85       	ldd	r31, Y+8	; 0x08
    156c:	81 89       	ldd	r24, Z+17	; 0x11
    156e:	88 23       	and	r24, r24
    1570:	49 f0       	breq	.+18     	; 0x1584 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1572:	8f 81       	ldd	r24, Y+7	; 0x07
    1574:	98 85       	ldd	r25, Y+8	; 0x08
    1576:	41 96       	adiw	r24, 0x11	; 17
    1578:	0e 94 b1 12 	call	0x2562	; 0x2562 <xTaskRemoveFromEventList>
    157c:	88 23       	and	r24, r24
    157e:	11 f0       	breq	.+4      	; 0x1584 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1580:	0e 94 c6 07 	call	0xf8c	; 0xf8c <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1584:	0f 90       	pop	r0
    1586:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1588:	81 e0       	ldi	r24, 0x01	; 1
    158a:	8e 87       	std	Y+14, r24	; 0x0e
    158c:	5c c0       	rjmp	.+184    	; 0x1646 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    158e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1590:	9c 85       	ldd	r25, Y+12	; 0x0c
    1592:	00 97       	sbiw	r24, 0x00	; 0
    1594:	21 f4       	brne	.+8      	; 0x159e <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1596:	0f 90       	pop	r0
    1598:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    159a:	1e 86       	std	Y+14, r1	; 0x0e
    159c:	54 c0       	rjmp	.+168    	; 0x1646 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    159e:	8b 81       	ldd	r24, Y+3	; 0x03
    15a0:	88 23       	and	r24, r24
    15a2:	31 f4       	brne	.+12     	; 0x15b0 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    15a4:	ce 01       	movw	r24, r28
    15a6:	04 96       	adiw	r24, 0x04	; 4
    15a8:	0e 94 19 13 	call	0x2632	; 0x2632 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    15ac:	81 e0       	ldi	r24, 0x01	; 1
    15ae:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    15b0:	0f 90       	pop	r0
    15b2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    15b4:	0e 94 75 10 	call	0x20ea	; 0x20ea <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    15b8:	0f b6       	in	r0, 0x3f	; 63
    15ba:	f8 94       	cli
    15bc:	0f 92       	push	r0
    15be:	ef 81       	ldd	r30, Y+7	; 0x07
    15c0:	f8 85       	ldd	r31, Y+8	; 0x08
    15c2:	85 8d       	ldd	r24, Z+29	; 0x1d
    15c4:	8f 3f       	cpi	r24, 0xFF	; 255
    15c6:	19 f4       	brne	.+6      	; 0x15ce <xQueueGenericReceive+0xf4>
    15c8:	ef 81       	ldd	r30, Y+7	; 0x07
    15ca:	f8 85       	ldd	r31, Y+8	; 0x08
    15cc:	15 8e       	std	Z+29, r1	; 0x1d
    15ce:	ef 81       	ldd	r30, Y+7	; 0x07
    15d0:	f8 85       	ldd	r31, Y+8	; 0x08
    15d2:	86 8d       	ldd	r24, Z+30	; 0x1e
    15d4:	8f 3f       	cpi	r24, 0xFF	; 255
    15d6:	19 f4       	brne	.+6      	; 0x15de <xQueueGenericReceive+0x104>
    15d8:	ef 81       	ldd	r30, Y+7	; 0x07
    15da:	f8 85       	ldd	r31, Y+8	; 0x08
    15dc:	16 8e       	std	Z+30, r1	; 0x1e
    15de:	0f 90       	pop	r0
    15e0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    15e2:	ce 01       	movw	r24, r28
    15e4:	04 96       	adiw	r24, 0x04	; 4
    15e6:	9e 01       	movw	r18, r28
    15e8:	25 5f       	subi	r18, 0xF5	; 245
    15ea:	3f 4f       	sbci	r19, 0xFF	; 255
    15ec:	b9 01       	movw	r22, r18
    15ee:	0e 94 32 13 	call	0x2664	; 0x2664 <xTaskCheckForTimeOut>
    15f2:	88 23       	and	r24, r24
    15f4:	09 f5       	brne	.+66     	; 0x1638 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    15f6:	8f 81       	ldd	r24, Y+7	; 0x07
    15f8:	98 85       	ldd	r25, Y+8	; 0x08
    15fa:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <prvIsQueueEmpty>
    15fe:	88 23       	and	r24, r24
    1600:	a1 f0       	breq	.+40     	; 0x162a <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1602:	8f 81       	ldd	r24, Y+7	; 0x07
    1604:	98 85       	ldd	r25, Y+8	; 0x08
    1606:	41 96       	adiw	r24, 0x11	; 17
    1608:	2b 85       	ldd	r18, Y+11	; 0x0b
    160a:	3c 85       	ldd	r19, Y+12	; 0x0c
    160c:	b9 01       	movw	r22, r18
    160e:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1612:	8f 81       	ldd	r24, Y+7	; 0x07
    1614:	98 85       	ldd	r25, Y+8	; 0x08
    1616:	0e 94 9a 0c 	call	0x1934	; 0x1934 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    161a:	0e 94 81 10 	call	0x2102	; 0x2102 <xTaskResumeAll>
    161e:	88 23       	and	r24, r24
    1620:	09 f0       	breq	.+2      	; 0x1624 <xQueueGenericReceive+0x14a>
    1622:	6d cf       	rjmp	.-294    	; 0x14fe <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1624:	0e 94 c6 07 	call	0xf8c	; 0xf8c <vPortYield>
    1628:	6a cf       	rjmp	.-300    	; 0x14fe <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    162a:	8f 81       	ldd	r24, Y+7	; 0x07
    162c:	98 85       	ldd	r25, Y+8	; 0x08
    162e:	0e 94 9a 0c 	call	0x1934	; 0x1934 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1632:	0e 94 81 10 	call	0x2102	; 0x2102 <xTaskResumeAll>
    1636:	63 cf       	rjmp	.-314    	; 0x14fe <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1638:	8f 81       	ldd	r24, Y+7	; 0x07
    163a:	98 85       	ldd	r25, Y+8	; 0x08
    163c:	0e 94 9a 0c 	call	0x1934	; 0x1934 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1640:	0e 94 81 10 	call	0x2102	; 0x2102 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1644:	1e 86       	std	Y+14, r1	; 0x0e
    1646:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    1648:	2e 96       	adiw	r28, 0x0e	; 14
    164a:	0f b6       	in	r0, 0x3f	; 63
    164c:	f8 94       	cli
    164e:	de bf       	out	0x3e, r29	; 62
    1650:	0f be       	out	0x3f, r0	; 63
    1652:	cd bf       	out	0x3d, r28	; 61
    1654:	cf 91       	pop	r28
    1656:	df 91       	pop	r29
    1658:	08 95       	ret

0000165a <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    165a:	df 93       	push	r29
    165c:	cf 93       	push	r28
    165e:	cd b7       	in	r28, 0x3d	; 61
    1660:	de b7       	in	r29, 0x3e	; 62
    1662:	28 97       	sbiw	r28, 0x08	; 8
    1664:	0f b6       	in	r0, 0x3f	; 63
    1666:	f8 94       	cli
    1668:	de bf       	out	0x3e, r29	; 62
    166a:	0f be       	out	0x3f, r0	; 63
    166c:	cd bf       	out	0x3d, r28	; 61
    166e:	9c 83       	std	Y+4, r25	; 0x04
    1670:	8b 83       	std	Y+3, r24	; 0x03
    1672:	7e 83       	std	Y+6, r23	; 0x06
    1674:	6d 83       	std	Y+5, r22	; 0x05
    1676:	58 87       	std	Y+8, r21	; 0x08
    1678:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    167a:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    167c:	eb 81       	ldd	r30, Y+3	; 0x03
    167e:	fc 81       	ldd	r31, Y+4	; 0x04
    1680:	82 8d       	ldd	r24, Z+26	; 0x1a
    1682:	88 23       	and	r24, r24
    1684:	71 f1       	breq	.+92     	; 0x16e2 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1686:	8b 81       	ldd	r24, Y+3	; 0x03
    1688:	9c 81       	ldd	r25, Y+4	; 0x04
    168a:	2d 81       	ldd	r18, Y+5	; 0x05
    168c:	3e 81       	ldd	r19, Y+6	; 0x06
    168e:	b9 01       	movw	r22, r18
    1690:	0e 94 52 0c 	call	0x18a4	; 0x18a4 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1694:	eb 81       	ldd	r30, Y+3	; 0x03
    1696:	fc 81       	ldd	r31, Y+4	; 0x04
    1698:	82 8d       	ldd	r24, Z+26	; 0x1a
    169a:	81 50       	subi	r24, 0x01	; 1
    169c:	eb 81       	ldd	r30, Y+3	; 0x03
    169e:	fc 81       	ldd	r31, Y+4	; 0x04
    16a0:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    16a2:	eb 81       	ldd	r30, Y+3	; 0x03
    16a4:	fc 81       	ldd	r31, Y+4	; 0x04
    16a6:	85 8d       	ldd	r24, Z+29	; 0x1d
    16a8:	8f 3f       	cpi	r24, 0xFF	; 255
    16aa:	89 f4       	brne	.+34     	; 0x16ce <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16ac:	eb 81       	ldd	r30, Y+3	; 0x03
    16ae:	fc 81       	ldd	r31, Y+4	; 0x04
    16b0:	80 85       	ldd	r24, Z+8	; 0x08
    16b2:	88 23       	and	r24, r24
    16b4:	99 f0       	breq	.+38     	; 0x16dc <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16b6:	8b 81       	ldd	r24, Y+3	; 0x03
    16b8:	9c 81       	ldd	r25, Y+4	; 0x04
    16ba:	08 96       	adiw	r24, 0x08	; 8
    16bc:	0e 94 b1 12 	call	0x2562	; 0x2562 <xTaskRemoveFromEventList>
    16c0:	88 23       	and	r24, r24
    16c2:	61 f0       	breq	.+24     	; 0x16dc <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    16c4:	ef 81       	ldd	r30, Y+7	; 0x07
    16c6:	f8 85       	ldd	r31, Y+8	; 0x08
    16c8:	81 e0       	ldi	r24, 0x01	; 1
    16ca:	80 83       	st	Z, r24
    16cc:	07 c0       	rjmp	.+14     	; 0x16dc <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    16ce:	eb 81       	ldd	r30, Y+3	; 0x03
    16d0:	fc 81       	ldd	r31, Y+4	; 0x04
    16d2:	85 8d       	ldd	r24, Z+29	; 0x1d
    16d4:	8f 5f       	subi	r24, 0xFF	; 255
    16d6:	eb 81       	ldd	r30, Y+3	; 0x03
    16d8:	fc 81       	ldd	r31, Y+4	; 0x04
    16da:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    16dc:	81 e0       	ldi	r24, 0x01	; 1
    16de:	8a 83       	std	Y+2, r24	; 0x02
    16e0:	01 c0       	rjmp	.+2      	; 0x16e4 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    16e2:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    16e4:	8a 81       	ldd	r24, Y+2	; 0x02
}
    16e6:	28 96       	adiw	r28, 0x08	; 8
    16e8:	0f b6       	in	r0, 0x3f	; 63
    16ea:	f8 94       	cli
    16ec:	de bf       	out	0x3e, r29	; 62
    16ee:	0f be       	out	0x3f, r0	; 63
    16f0:	cd bf       	out	0x3d, r28	; 61
    16f2:	cf 91       	pop	r28
    16f4:	df 91       	pop	r29
    16f6:	08 95       	ret

000016f8 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    16f8:	df 93       	push	r29
    16fa:	cf 93       	push	r28
    16fc:	00 d0       	rcall	.+0      	; 0x16fe <uxQueueMessagesWaiting+0x6>
    16fe:	0f 92       	push	r0
    1700:	cd b7       	in	r28, 0x3d	; 61
    1702:	de b7       	in	r29, 0x3e	; 62
    1704:	9b 83       	std	Y+3, r25	; 0x03
    1706:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1708:	0f b6       	in	r0, 0x3f	; 63
    170a:	f8 94       	cli
    170c:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    170e:	ea 81       	ldd	r30, Y+2	; 0x02
    1710:	fb 81       	ldd	r31, Y+3	; 0x03
    1712:	82 8d       	ldd	r24, Z+26	; 0x1a
    1714:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1716:	0f 90       	pop	r0
    1718:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    171a:	89 81       	ldd	r24, Y+1	; 0x01
}
    171c:	0f 90       	pop	r0
    171e:	0f 90       	pop	r0
    1720:	0f 90       	pop	r0
    1722:	cf 91       	pop	r28
    1724:	df 91       	pop	r29
    1726:	08 95       	ret

00001728 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1728:	df 93       	push	r29
    172a:	cf 93       	push	r28
    172c:	00 d0       	rcall	.+0      	; 0x172e <uxQueueMessagesWaitingFromISR+0x6>
    172e:	0f 92       	push	r0
    1730:	cd b7       	in	r28, 0x3d	; 61
    1732:	de b7       	in	r29, 0x3e	; 62
    1734:	9b 83       	std	Y+3, r25	; 0x03
    1736:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1738:	ea 81       	ldd	r30, Y+2	; 0x02
    173a:	fb 81       	ldd	r31, Y+3	; 0x03
    173c:	82 8d       	ldd	r24, Z+26	; 0x1a
    173e:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1740:	89 81       	ldd	r24, Y+1	; 0x01
}
    1742:	0f 90       	pop	r0
    1744:	0f 90       	pop	r0
    1746:	0f 90       	pop	r0
    1748:	cf 91       	pop	r28
    174a:	df 91       	pop	r29
    174c:	08 95       	ret

0000174e <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    174e:	df 93       	push	r29
    1750:	cf 93       	push	r28
    1752:	00 d0       	rcall	.+0      	; 0x1754 <vQueueDelete+0x6>
    1754:	cd b7       	in	r28, 0x3d	; 61
    1756:	de b7       	in	r29, 0x3e	; 62
    1758:	9a 83       	std	Y+2, r25	; 0x02
    175a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    175c:	e9 81       	ldd	r30, Y+1	; 0x01
    175e:	fa 81       	ldd	r31, Y+2	; 0x02
    1760:	80 81       	ld	r24, Z
    1762:	91 81       	ldd	r25, Z+1	; 0x01
    1764:	0e 94 a6 04 	call	0x94c	; 0x94c <vPortFree>
	vPortFree( pxQueue );
    1768:	89 81       	ldd	r24, Y+1	; 0x01
    176a:	9a 81       	ldd	r25, Y+2	; 0x02
    176c:	0e 94 a6 04 	call	0x94c	; 0x94c <vPortFree>
}
    1770:	0f 90       	pop	r0
    1772:	0f 90       	pop	r0
    1774:	cf 91       	pop	r28
    1776:	df 91       	pop	r29
    1778:	08 95       	ret

0000177a <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    177a:	df 93       	push	r29
    177c:	cf 93       	push	r28
    177e:	00 d0       	rcall	.+0      	; 0x1780 <prvCopyDataToQueue+0x6>
    1780:	00 d0       	rcall	.+0      	; 0x1782 <prvCopyDataToQueue+0x8>
    1782:	0f 92       	push	r0
    1784:	cd b7       	in	r28, 0x3d	; 61
    1786:	de b7       	in	r29, 0x3e	; 62
    1788:	9a 83       	std	Y+2, r25	; 0x02
    178a:	89 83       	std	Y+1, r24	; 0x01
    178c:	7c 83       	std	Y+4, r23	; 0x04
    178e:	6b 83       	std	Y+3, r22	; 0x03
    1790:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1792:	e9 81       	ldd	r30, Y+1	; 0x01
    1794:	fa 81       	ldd	r31, Y+2	; 0x02
    1796:	84 8d       	ldd	r24, Z+28	; 0x1c
    1798:	88 23       	and	r24, r24
    179a:	09 f4       	brne	.+2      	; 0x179e <prvCopyDataToQueue+0x24>
    179c:	74 c0       	rjmp	.+232    	; 0x1886 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    179e:	8d 81       	ldd	r24, Y+5	; 0x05
    17a0:	88 23       	and	r24, r24
    17a2:	99 f5       	brne	.+102    	; 0x180a <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    17a4:	e9 81       	ldd	r30, Y+1	; 0x01
    17a6:	fa 81       	ldd	r31, Y+2	; 0x02
    17a8:	64 81       	ldd	r22, Z+4	; 0x04
    17aa:	75 81       	ldd	r23, Z+5	; 0x05
    17ac:	e9 81       	ldd	r30, Y+1	; 0x01
    17ae:	fa 81       	ldd	r31, Y+2	; 0x02
    17b0:	84 8d       	ldd	r24, Z+28	; 0x1c
    17b2:	48 2f       	mov	r20, r24
    17b4:	50 e0       	ldi	r21, 0x00	; 0
    17b6:	2b 81       	ldd	r18, Y+3	; 0x03
    17b8:	3c 81       	ldd	r19, Y+4	; 0x04
    17ba:	cb 01       	movw	r24, r22
    17bc:	b9 01       	movw	r22, r18
    17be:	0e 94 24 15 	call	0x2a48	; 0x2a48 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    17c2:	e9 81       	ldd	r30, Y+1	; 0x01
    17c4:	fa 81       	ldd	r31, Y+2	; 0x02
    17c6:	24 81       	ldd	r18, Z+4	; 0x04
    17c8:	35 81       	ldd	r19, Z+5	; 0x05
    17ca:	e9 81       	ldd	r30, Y+1	; 0x01
    17cc:	fa 81       	ldd	r31, Y+2	; 0x02
    17ce:	84 8d       	ldd	r24, Z+28	; 0x1c
    17d0:	88 2f       	mov	r24, r24
    17d2:	90 e0       	ldi	r25, 0x00	; 0
    17d4:	82 0f       	add	r24, r18
    17d6:	93 1f       	adc	r25, r19
    17d8:	e9 81       	ldd	r30, Y+1	; 0x01
    17da:	fa 81       	ldd	r31, Y+2	; 0x02
    17dc:	95 83       	std	Z+5, r25	; 0x05
    17de:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    17e0:	e9 81       	ldd	r30, Y+1	; 0x01
    17e2:	fa 81       	ldd	r31, Y+2	; 0x02
    17e4:	24 81       	ldd	r18, Z+4	; 0x04
    17e6:	35 81       	ldd	r19, Z+5	; 0x05
    17e8:	e9 81       	ldd	r30, Y+1	; 0x01
    17ea:	fa 81       	ldd	r31, Y+2	; 0x02
    17ec:	82 81       	ldd	r24, Z+2	; 0x02
    17ee:	93 81       	ldd	r25, Z+3	; 0x03
    17f0:	28 17       	cp	r18, r24
    17f2:	39 07       	cpc	r19, r25
    17f4:	08 f4       	brcc	.+2      	; 0x17f8 <prvCopyDataToQueue+0x7e>
    17f6:	47 c0       	rjmp	.+142    	; 0x1886 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    17f8:	e9 81       	ldd	r30, Y+1	; 0x01
    17fa:	fa 81       	ldd	r31, Y+2	; 0x02
    17fc:	80 81       	ld	r24, Z
    17fe:	91 81       	ldd	r25, Z+1	; 0x01
    1800:	e9 81       	ldd	r30, Y+1	; 0x01
    1802:	fa 81       	ldd	r31, Y+2	; 0x02
    1804:	95 83       	std	Z+5, r25	; 0x05
    1806:	84 83       	std	Z+4, r24	; 0x04
    1808:	3e c0       	rjmp	.+124    	; 0x1886 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    180a:	e9 81       	ldd	r30, Y+1	; 0x01
    180c:	fa 81       	ldd	r31, Y+2	; 0x02
    180e:	66 81       	ldd	r22, Z+6	; 0x06
    1810:	77 81       	ldd	r23, Z+7	; 0x07
    1812:	e9 81       	ldd	r30, Y+1	; 0x01
    1814:	fa 81       	ldd	r31, Y+2	; 0x02
    1816:	84 8d       	ldd	r24, Z+28	; 0x1c
    1818:	48 2f       	mov	r20, r24
    181a:	50 e0       	ldi	r21, 0x00	; 0
    181c:	2b 81       	ldd	r18, Y+3	; 0x03
    181e:	3c 81       	ldd	r19, Y+4	; 0x04
    1820:	cb 01       	movw	r24, r22
    1822:	b9 01       	movw	r22, r18
    1824:	0e 94 24 15 	call	0x2a48	; 0x2a48 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1828:	e9 81       	ldd	r30, Y+1	; 0x01
    182a:	fa 81       	ldd	r31, Y+2	; 0x02
    182c:	26 81       	ldd	r18, Z+6	; 0x06
    182e:	37 81       	ldd	r19, Z+7	; 0x07
    1830:	e9 81       	ldd	r30, Y+1	; 0x01
    1832:	fa 81       	ldd	r31, Y+2	; 0x02
    1834:	84 8d       	ldd	r24, Z+28	; 0x1c
    1836:	88 2f       	mov	r24, r24
    1838:	90 e0       	ldi	r25, 0x00	; 0
    183a:	90 95       	com	r25
    183c:	81 95       	neg	r24
    183e:	9f 4f       	sbci	r25, 0xFF	; 255
    1840:	82 0f       	add	r24, r18
    1842:	93 1f       	adc	r25, r19
    1844:	e9 81       	ldd	r30, Y+1	; 0x01
    1846:	fa 81       	ldd	r31, Y+2	; 0x02
    1848:	97 83       	std	Z+7, r25	; 0x07
    184a:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    184c:	e9 81       	ldd	r30, Y+1	; 0x01
    184e:	fa 81       	ldd	r31, Y+2	; 0x02
    1850:	26 81       	ldd	r18, Z+6	; 0x06
    1852:	37 81       	ldd	r19, Z+7	; 0x07
    1854:	e9 81       	ldd	r30, Y+1	; 0x01
    1856:	fa 81       	ldd	r31, Y+2	; 0x02
    1858:	80 81       	ld	r24, Z
    185a:	91 81       	ldd	r25, Z+1	; 0x01
    185c:	28 17       	cp	r18, r24
    185e:	39 07       	cpc	r19, r25
    1860:	90 f4       	brcc	.+36     	; 0x1886 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1862:	e9 81       	ldd	r30, Y+1	; 0x01
    1864:	fa 81       	ldd	r31, Y+2	; 0x02
    1866:	22 81       	ldd	r18, Z+2	; 0x02
    1868:	33 81       	ldd	r19, Z+3	; 0x03
    186a:	e9 81       	ldd	r30, Y+1	; 0x01
    186c:	fa 81       	ldd	r31, Y+2	; 0x02
    186e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1870:	88 2f       	mov	r24, r24
    1872:	90 e0       	ldi	r25, 0x00	; 0
    1874:	90 95       	com	r25
    1876:	81 95       	neg	r24
    1878:	9f 4f       	sbci	r25, 0xFF	; 255
    187a:	82 0f       	add	r24, r18
    187c:	93 1f       	adc	r25, r19
    187e:	e9 81       	ldd	r30, Y+1	; 0x01
    1880:	fa 81       	ldd	r31, Y+2	; 0x02
    1882:	97 83       	std	Z+7, r25	; 0x07
    1884:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1886:	e9 81       	ldd	r30, Y+1	; 0x01
    1888:	fa 81       	ldd	r31, Y+2	; 0x02
    188a:	82 8d       	ldd	r24, Z+26	; 0x1a
    188c:	8f 5f       	subi	r24, 0xFF	; 255
    188e:	e9 81       	ldd	r30, Y+1	; 0x01
    1890:	fa 81       	ldd	r31, Y+2	; 0x02
    1892:	82 8f       	std	Z+26, r24	; 0x1a
}
    1894:	0f 90       	pop	r0
    1896:	0f 90       	pop	r0
    1898:	0f 90       	pop	r0
    189a:	0f 90       	pop	r0
    189c:	0f 90       	pop	r0
    189e:	cf 91       	pop	r28
    18a0:	df 91       	pop	r29
    18a2:	08 95       	ret

000018a4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    18a4:	df 93       	push	r29
    18a6:	cf 93       	push	r28
    18a8:	00 d0       	rcall	.+0      	; 0x18aa <prvCopyDataFromQueue+0x6>
    18aa:	00 d0       	rcall	.+0      	; 0x18ac <prvCopyDataFromQueue+0x8>
    18ac:	cd b7       	in	r28, 0x3d	; 61
    18ae:	de b7       	in	r29, 0x3e	; 62
    18b0:	9a 83       	std	Y+2, r25	; 0x02
    18b2:	89 83       	std	Y+1, r24	; 0x01
    18b4:	7c 83       	std	Y+4, r23	; 0x04
    18b6:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    18b8:	e9 81       	ldd	r30, Y+1	; 0x01
    18ba:	fa 81       	ldd	r31, Y+2	; 0x02
    18bc:	80 81       	ld	r24, Z
    18be:	91 81       	ldd	r25, Z+1	; 0x01
    18c0:	00 97       	sbiw	r24, 0x00	; 0
    18c2:	89 f1       	breq	.+98     	; 0x1926 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    18c4:	e9 81       	ldd	r30, Y+1	; 0x01
    18c6:	fa 81       	ldd	r31, Y+2	; 0x02
    18c8:	26 81       	ldd	r18, Z+6	; 0x06
    18ca:	37 81       	ldd	r19, Z+7	; 0x07
    18cc:	e9 81       	ldd	r30, Y+1	; 0x01
    18ce:	fa 81       	ldd	r31, Y+2	; 0x02
    18d0:	84 8d       	ldd	r24, Z+28	; 0x1c
    18d2:	88 2f       	mov	r24, r24
    18d4:	90 e0       	ldi	r25, 0x00	; 0
    18d6:	82 0f       	add	r24, r18
    18d8:	93 1f       	adc	r25, r19
    18da:	e9 81       	ldd	r30, Y+1	; 0x01
    18dc:	fa 81       	ldd	r31, Y+2	; 0x02
    18de:	97 83       	std	Z+7, r25	; 0x07
    18e0:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    18e2:	e9 81       	ldd	r30, Y+1	; 0x01
    18e4:	fa 81       	ldd	r31, Y+2	; 0x02
    18e6:	26 81       	ldd	r18, Z+6	; 0x06
    18e8:	37 81       	ldd	r19, Z+7	; 0x07
    18ea:	e9 81       	ldd	r30, Y+1	; 0x01
    18ec:	fa 81       	ldd	r31, Y+2	; 0x02
    18ee:	82 81       	ldd	r24, Z+2	; 0x02
    18f0:	93 81       	ldd	r25, Z+3	; 0x03
    18f2:	28 17       	cp	r18, r24
    18f4:	39 07       	cpc	r19, r25
    18f6:	40 f0       	brcs	.+16     	; 0x1908 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    18f8:	e9 81       	ldd	r30, Y+1	; 0x01
    18fa:	fa 81       	ldd	r31, Y+2	; 0x02
    18fc:	80 81       	ld	r24, Z
    18fe:	91 81       	ldd	r25, Z+1	; 0x01
    1900:	e9 81       	ldd	r30, Y+1	; 0x01
    1902:	fa 81       	ldd	r31, Y+2	; 0x02
    1904:	97 83       	std	Z+7, r25	; 0x07
    1906:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1908:	e9 81       	ldd	r30, Y+1	; 0x01
    190a:	fa 81       	ldd	r31, Y+2	; 0x02
    190c:	46 81       	ldd	r20, Z+6	; 0x06
    190e:	57 81       	ldd	r21, Z+7	; 0x07
    1910:	e9 81       	ldd	r30, Y+1	; 0x01
    1912:	fa 81       	ldd	r31, Y+2	; 0x02
    1914:	84 8d       	ldd	r24, Z+28	; 0x1c
    1916:	28 2f       	mov	r18, r24
    1918:	30 e0       	ldi	r19, 0x00	; 0
    191a:	8b 81       	ldd	r24, Y+3	; 0x03
    191c:	9c 81       	ldd	r25, Y+4	; 0x04
    191e:	ba 01       	movw	r22, r20
    1920:	a9 01       	movw	r20, r18
    1922:	0e 94 24 15 	call	0x2a48	; 0x2a48 <memcpy>
	}
}
    1926:	0f 90       	pop	r0
    1928:	0f 90       	pop	r0
    192a:	0f 90       	pop	r0
    192c:	0f 90       	pop	r0
    192e:	cf 91       	pop	r28
    1930:	df 91       	pop	r29
    1932:	08 95       	ret

00001934 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1934:	df 93       	push	r29
    1936:	cf 93       	push	r28
    1938:	00 d0       	rcall	.+0      	; 0x193a <prvUnlockQueue+0x6>
    193a:	cd b7       	in	r28, 0x3d	; 61
    193c:	de b7       	in	r29, 0x3e	; 62
    193e:	9a 83       	std	Y+2, r25	; 0x02
    1940:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1942:	0f b6       	in	r0, 0x3f	; 63
    1944:	f8 94       	cli
    1946:	0f 92       	push	r0
    1948:	15 c0       	rjmp	.+42     	; 0x1974 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    194a:	e9 81       	ldd	r30, Y+1	; 0x01
    194c:	fa 81       	ldd	r31, Y+2	; 0x02
    194e:	81 89       	ldd	r24, Z+17	; 0x11
    1950:	88 23       	and	r24, r24
    1952:	a9 f0       	breq	.+42     	; 0x197e <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1954:	89 81       	ldd	r24, Y+1	; 0x01
    1956:	9a 81       	ldd	r25, Y+2	; 0x02
    1958:	41 96       	adiw	r24, 0x11	; 17
    195a:	0e 94 b1 12 	call	0x2562	; 0x2562 <xTaskRemoveFromEventList>
    195e:	88 23       	and	r24, r24
    1960:	11 f0       	breq	.+4      	; 0x1966 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1962:	0e 94 8f 13 	call	0x271e	; 0x271e <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1966:	e9 81       	ldd	r30, Y+1	; 0x01
    1968:	fa 81       	ldd	r31, Y+2	; 0x02
    196a:	86 8d       	ldd	r24, Z+30	; 0x1e
    196c:	81 50       	subi	r24, 0x01	; 1
    196e:	e9 81       	ldd	r30, Y+1	; 0x01
    1970:	fa 81       	ldd	r31, Y+2	; 0x02
    1972:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1974:	e9 81       	ldd	r30, Y+1	; 0x01
    1976:	fa 81       	ldd	r31, Y+2	; 0x02
    1978:	86 8d       	ldd	r24, Z+30	; 0x1e
    197a:	18 16       	cp	r1, r24
    197c:	34 f3       	brlt	.-52     	; 0x194a <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    197e:	e9 81       	ldd	r30, Y+1	; 0x01
    1980:	fa 81       	ldd	r31, Y+2	; 0x02
    1982:	8f ef       	ldi	r24, 0xFF	; 255
    1984:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1986:	0f 90       	pop	r0
    1988:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    198a:	0f b6       	in	r0, 0x3f	; 63
    198c:	f8 94       	cli
    198e:	0f 92       	push	r0
    1990:	15 c0       	rjmp	.+42     	; 0x19bc <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1992:	e9 81       	ldd	r30, Y+1	; 0x01
    1994:	fa 81       	ldd	r31, Y+2	; 0x02
    1996:	80 85       	ldd	r24, Z+8	; 0x08
    1998:	88 23       	and	r24, r24
    199a:	a9 f0       	breq	.+42     	; 0x19c6 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    199c:	89 81       	ldd	r24, Y+1	; 0x01
    199e:	9a 81       	ldd	r25, Y+2	; 0x02
    19a0:	08 96       	adiw	r24, 0x08	; 8
    19a2:	0e 94 b1 12 	call	0x2562	; 0x2562 <xTaskRemoveFromEventList>
    19a6:	88 23       	and	r24, r24
    19a8:	11 f0       	breq	.+4      	; 0x19ae <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    19aa:	0e 94 8f 13 	call	0x271e	; 0x271e <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    19ae:	e9 81       	ldd	r30, Y+1	; 0x01
    19b0:	fa 81       	ldd	r31, Y+2	; 0x02
    19b2:	85 8d       	ldd	r24, Z+29	; 0x1d
    19b4:	81 50       	subi	r24, 0x01	; 1
    19b6:	e9 81       	ldd	r30, Y+1	; 0x01
    19b8:	fa 81       	ldd	r31, Y+2	; 0x02
    19ba:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    19bc:	e9 81       	ldd	r30, Y+1	; 0x01
    19be:	fa 81       	ldd	r31, Y+2	; 0x02
    19c0:	85 8d       	ldd	r24, Z+29	; 0x1d
    19c2:	18 16       	cp	r1, r24
    19c4:	34 f3       	brlt	.-52     	; 0x1992 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    19c6:	e9 81       	ldd	r30, Y+1	; 0x01
    19c8:	fa 81       	ldd	r31, Y+2	; 0x02
    19ca:	8f ef       	ldi	r24, 0xFF	; 255
    19cc:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    19ce:	0f 90       	pop	r0
    19d0:	0f be       	out	0x3f, r0	; 63
}
    19d2:	0f 90       	pop	r0
    19d4:	0f 90       	pop	r0
    19d6:	cf 91       	pop	r28
    19d8:	df 91       	pop	r29
    19da:	08 95       	ret

000019dc <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    19dc:	df 93       	push	r29
    19de:	cf 93       	push	r28
    19e0:	00 d0       	rcall	.+0      	; 0x19e2 <prvIsQueueEmpty+0x6>
    19e2:	0f 92       	push	r0
    19e4:	cd b7       	in	r28, 0x3d	; 61
    19e6:	de b7       	in	r29, 0x3e	; 62
    19e8:	9b 83       	std	Y+3, r25	; 0x03
    19ea:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    19ec:	0f b6       	in	r0, 0x3f	; 63
    19ee:	f8 94       	cli
    19f0:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    19f2:	ea 81       	ldd	r30, Y+2	; 0x02
    19f4:	fb 81       	ldd	r31, Y+3	; 0x03
    19f6:	82 8d       	ldd	r24, Z+26	; 0x1a
    19f8:	19 82       	std	Y+1, r1	; 0x01
    19fa:	88 23       	and	r24, r24
    19fc:	11 f4       	brne	.+4      	; 0x1a02 <prvIsQueueEmpty+0x26>
    19fe:	81 e0       	ldi	r24, 0x01	; 1
    1a00:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1a02:	0f 90       	pop	r0
    1a04:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1a06:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a08:	0f 90       	pop	r0
    1a0a:	0f 90       	pop	r0
    1a0c:	0f 90       	pop	r0
    1a0e:	cf 91       	pop	r28
    1a10:	df 91       	pop	r29
    1a12:	08 95       	ret

00001a14 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1a14:	df 93       	push	r29
    1a16:	cf 93       	push	r28
    1a18:	00 d0       	rcall	.+0      	; 0x1a1a <xQueueIsQueueEmptyFromISR+0x6>
    1a1a:	0f 92       	push	r0
    1a1c:	cd b7       	in	r28, 0x3d	; 61
    1a1e:	de b7       	in	r29, 0x3e	; 62
    1a20:	9b 83       	std	Y+3, r25	; 0x03
    1a22:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1a24:	ea 81       	ldd	r30, Y+2	; 0x02
    1a26:	fb 81       	ldd	r31, Y+3	; 0x03
    1a28:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a2a:	19 82       	std	Y+1, r1	; 0x01
    1a2c:	88 23       	and	r24, r24
    1a2e:	11 f4       	brne	.+4      	; 0x1a34 <xQueueIsQueueEmptyFromISR+0x20>
    1a30:	81 e0       	ldi	r24, 0x01	; 1
    1a32:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1a34:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a36:	0f 90       	pop	r0
    1a38:	0f 90       	pop	r0
    1a3a:	0f 90       	pop	r0
    1a3c:	cf 91       	pop	r28
    1a3e:	df 91       	pop	r29
    1a40:	08 95       	ret

00001a42 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    1a42:	df 93       	push	r29
    1a44:	cf 93       	push	r28
    1a46:	00 d0       	rcall	.+0      	; 0x1a48 <prvIsQueueFull+0x6>
    1a48:	0f 92       	push	r0
    1a4a:	cd b7       	in	r28, 0x3d	; 61
    1a4c:	de b7       	in	r29, 0x3e	; 62
    1a4e:	9b 83       	std	Y+3, r25	; 0x03
    1a50:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1a52:	0f b6       	in	r0, 0x3f	; 63
    1a54:	f8 94       	cli
    1a56:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1a58:	ea 81       	ldd	r30, Y+2	; 0x02
    1a5a:	fb 81       	ldd	r31, Y+3	; 0x03
    1a5c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a5e:	ea 81       	ldd	r30, Y+2	; 0x02
    1a60:	fb 81       	ldd	r31, Y+3	; 0x03
    1a62:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a64:	19 82       	std	Y+1, r1	; 0x01
    1a66:	98 17       	cp	r25, r24
    1a68:	11 f4       	brne	.+4      	; 0x1a6e <prvIsQueueFull+0x2c>
    1a6a:	81 e0       	ldi	r24, 0x01	; 1
    1a6c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1a6e:	0f 90       	pop	r0
    1a70:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1a72:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a74:	0f 90       	pop	r0
    1a76:	0f 90       	pop	r0
    1a78:	0f 90       	pop	r0
    1a7a:	cf 91       	pop	r28
    1a7c:	df 91       	pop	r29
    1a7e:	08 95       	ret

00001a80 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1a80:	df 93       	push	r29
    1a82:	cf 93       	push	r28
    1a84:	00 d0       	rcall	.+0      	; 0x1a86 <xQueueIsQueueFullFromISR+0x6>
    1a86:	0f 92       	push	r0
    1a88:	cd b7       	in	r28, 0x3d	; 61
    1a8a:	de b7       	in	r29, 0x3e	; 62
    1a8c:	9b 83       	std	Y+3, r25	; 0x03
    1a8e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1a90:	ea 81       	ldd	r30, Y+2	; 0x02
    1a92:	fb 81       	ldd	r31, Y+3	; 0x03
    1a94:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a96:	ea 81       	ldd	r30, Y+2	; 0x02
    1a98:	fb 81       	ldd	r31, Y+3	; 0x03
    1a9a:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a9c:	19 82       	std	Y+1, r1	; 0x01
    1a9e:	98 17       	cp	r25, r24
    1aa0:	11 f4       	brne	.+4      	; 0x1aa6 <xQueueIsQueueFullFromISR+0x26>
    1aa2:	81 e0       	ldi	r24, 0x01	; 1
    1aa4:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1aa6:	89 81       	ldd	r24, Y+1	; 0x01
}
    1aa8:	0f 90       	pop	r0
    1aaa:	0f 90       	pop	r0
    1aac:	0f 90       	pop	r0
    1aae:	cf 91       	pop	r28
    1ab0:	df 91       	pop	r29
    1ab2:	08 95       	ret

00001ab4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1ab4:	af 92       	push	r10
    1ab6:	bf 92       	push	r11
    1ab8:	cf 92       	push	r12
    1aba:	df 92       	push	r13
    1abc:	ef 92       	push	r14
    1abe:	ff 92       	push	r15
    1ac0:	0f 93       	push	r16
    1ac2:	1f 93       	push	r17
    1ac4:	df 93       	push	r29
    1ac6:	cf 93       	push	r28
    1ac8:	cd b7       	in	r28, 0x3d	; 61
    1aca:	de b7       	in	r29, 0x3e	; 62
    1acc:	64 97       	sbiw	r28, 0x14	; 20
    1ace:	0f b6       	in	r0, 0x3f	; 63
    1ad0:	f8 94       	cli
    1ad2:	de bf       	out	0x3e, r29	; 62
    1ad4:	0f be       	out	0x3f, r0	; 63
    1ad6:	cd bf       	out	0x3d, r28	; 61
    1ad8:	9f 83       	std	Y+7, r25	; 0x07
    1ada:	8e 83       	std	Y+6, r24	; 0x06
    1adc:	79 87       	std	Y+9, r23	; 0x09
    1ade:	68 87       	std	Y+8, r22	; 0x08
    1ae0:	5b 87       	std	Y+11, r21	; 0x0b
    1ae2:	4a 87       	std	Y+10, r20	; 0x0a
    1ae4:	3d 87       	std	Y+13, r19	; 0x0d
    1ae6:	2c 87       	std	Y+12, r18	; 0x0c
    1ae8:	0e 87       	std	Y+14, r16	; 0x0e
    1aea:	f8 8a       	std	Y+16, r15	; 0x10
    1aec:	ef 86       	std	Y+15, r14	; 0x0f
    1aee:	da 8a       	std	Y+18, r13	; 0x12
    1af0:	c9 8a       	std	Y+17, r12	; 0x11
    1af2:	bc 8a       	std	Y+20, r11	; 0x14
    1af4:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    1af6:	8a 85       	ldd	r24, Y+10	; 0x0a
    1af8:	9b 85       	ldd	r25, Y+11	; 0x0b
    1afa:	29 89       	ldd	r18, Y+17	; 0x11
    1afc:	3a 89       	ldd	r19, Y+18	; 0x12
    1afe:	b9 01       	movw	r22, r18
    1b00:	0e 94 be 14 	call	0x297c	; 0x297c <prvAllocateTCBAndStack>
    1b04:	9c 83       	std	Y+4, r25	; 0x04
    1b06:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    1b08:	8b 81       	ldd	r24, Y+3	; 0x03
    1b0a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b0c:	00 97       	sbiw	r24, 0x00	; 0
    1b0e:	09 f4       	brne	.+2      	; 0x1b12 <xTaskGenericCreate+0x5e>
    1b10:	99 c0       	rjmp	.+306    	; 0x1c44 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1b12:	eb 81       	ldd	r30, Y+3	; 0x03
    1b14:	fc 81       	ldd	r31, Y+4	; 0x04
    1b16:	27 89       	ldd	r18, Z+23	; 0x17
    1b18:	30 8d       	ldd	r19, Z+24	; 0x18
    1b1a:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b1c:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b1e:	01 97       	sbiw	r24, 0x01	; 1
    1b20:	82 0f       	add	r24, r18
    1b22:	93 1f       	adc	r25, r19
    1b24:	9a 83       	std	Y+2, r25	; 0x02
    1b26:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    1b28:	8b 81       	ldd	r24, Y+3	; 0x03
    1b2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b2c:	28 85       	ldd	r18, Y+8	; 0x08
    1b2e:	39 85       	ldd	r19, Y+9	; 0x09
    1b30:	eb 89       	ldd	r30, Y+19	; 0x13
    1b32:	fc 89       	ldd	r31, Y+20	; 0x14
    1b34:	aa 85       	ldd	r26, Y+10	; 0x0a
    1b36:	bb 85       	ldd	r27, Y+11	; 0x0b
    1b38:	b9 01       	movw	r22, r18
    1b3a:	4e 85       	ldd	r20, Y+14	; 0x0e
    1b3c:	9f 01       	movw	r18, r30
    1b3e:	8d 01       	movw	r16, r26
    1b40:	0e 94 a3 13 	call	0x2746	; 0x2746 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1b44:	89 81       	ldd	r24, Y+1	; 0x01
    1b46:	9a 81       	ldd	r25, Y+2	; 0x02
    1b48:	2e 81       	ldd	r18, Y+6	; 0x06
    1b4a:	3f 81       	ldd	r19, Y+7	; 0x07
    1b4c:	4c 85       	ldd	r20, Y+12	; 0x0c
    1b4e:	5d 85       	ldd	r21, Y+13	; 0x0d
    1b50:	b9 01       	movw	r22, r18
    1b52:	0e 94 07 06 	call	0xc0e	; 0xc0e <pxPortInitialiseStack>
    1b56:	eb 81       	ldd	r30, Y+3	; 0x03
    1b58:	fc 81       	ldd	r31, Y+4	; 0x04
    1b5a:	91 83       	std	Z+1, r25	; 0x01
    1b5c:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    1b5e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1b60:	98 89       	ldd	r25, Y+16	; 0x10
    1b62:	00 97       	sbiw	r24, 0x00	; 0
    1b64:	31 f0       	breq	.+12     	; 0x1b72 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1b66:	ef 85       	ldd	r30, Y+15	; 0x0f
    1b68:	f8 89       	ldd	r31, Y+16	; 0x10
    1b6a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b6c:	9c 81       	ldd	r25, Y+4	; 0x04
    1b6e:	91 83       	std	Z+1, r25	; 0x01
    1b70:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1b72:	0f b6       	in	r0, 0x3f	; 63
    1b74:	f8 94       	cli
    1b76:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1b78:	80 91 1f 03 	lds	r24, 0x031F
    1b7c:	8f 5f       	subi	r24, 0xFF	; 255
    1b7e:	80 93 1f 03 	sts	0x031F, r24
			if( pxCurrentTCB == NULL )
    1b82:	80 91 1c 03 	lds	r24, 0x031C
    1b86:	90 91 1d 03 	lds	r25, 0x031D
    1b8a:	00 97       	sbiw	r24, 0x00	; 0
    1b8c:	69 f4       	brne	.+26     	; 0x1ba8 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1b8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b90:	9c 81       	ldd	r25, Y+4	; 0x04
    1b92:	90 93 1d 03 	sts	0x031D, r25
    1b96:	80 93 1c 03 	sts	0x031C, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1b9a:	80 91 1f 03 	lds	r24, 0x031F
    1b9e:	81 30       	cpi	r24, 0x01	; 1
    1ba0:	a9 f4       	brne	.+42     	; 0x1bcc <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    1ba2:	0e 94 fa 13 	call	0x27f4	; 0x27f4 <prvInitialiseTaskLists>
    1ba6:	12 c0       	rjmp	.+36     	; 0x1bcc <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1ba8:	80 91 24 03 	lds	r24, 0x0324
    1bac:	88 23       	and	r24, r24
    1bae:	71 f4       	brne	.+28     	; 0x1bcc <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1bb0:	e0 91 1c 03 	lds	r30, 0x031C
    1bb4:	f0 91 1d 03 	lds	r31, 0x031D
    1bb8:	96 89       	ldd	r25, Z+22	; 0x16
    1bba:	8e 85       	ldd	r24, Y+14	; 0x0e
    1bbc:	89 17       	cp	r24, r25
    1bbe:	30 f0       	brcs	.+12     	; 0x1bcc <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    1bc0:	8b 81       	ldd	r24, Y+3	; 0x03
    1bc2:	9c 81       	ldd	r25, Y+4	; 0x04
    1bc4:	90 93 1d 03 	sts	0x031D, r25
    1bc8:	80 93 1c 03 	sts	0x031C, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1bcc:	eb 81       	ldd	r30, Y+3	; 0x03
    1bce:	fc 81       	ldd	r31, Y+4	; 0x04
    1bd0:	96 89       	ldd	r25, Z+22	; 0x16
    1bd2:	80 91 22 03 	lds	r24, 0x0322
    1bd6:	89 17       	cp	r24, r25
    1bd8:	28 f4       	brcc	.+10     	; 0x1be4 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1bda:	eb 81       	ldd	r30, Y+3	; 0x03
    1bdc:	fc 81       	ldd	r31, Y+4	; 0x04
    1bde:	86 89       	ldd	r24, Z+22	; 0x16
    1be0:	80 93 22 03 	sts	0x0322, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1be4:	80 91 29 03 	lds	r24, 0x0329
    1be8:	8f 5f       	subi	r24, 0xFF	; 255
    1bea:	80 93 29 03 	sts	0x0329, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1bee:	eb 81       	ldd	r30, Y+3	; 0x03
    1bf0:	fc 81       	ldd	r31, Y+4	; 0x04
    1bf2:	96 89       	ldd	r25, Z+22	; 0x16
    1bf4:	80 91 23 03 	lds	r24, 0x0323
    1bf8:	89 17       	cp	r24, r25
    1bfa:	28 f4       	brcc	.+10     	; 0x1c06 <xTaskGenericCreate+0x152>
    1bfc:	eb 81       	ldd	r30, Y+3	; 0x03
    1bfe:	fc 81       	ldd	r31, Y+4	; 0x04
    1c00:	86 89       	ldd	r24, Z+22	; 0x16
    1c02:	80 93 23 03 	sts	0x0323, r24
    1c06:	eb 81       	ldd	r30, Y+3	; 0x03
    1c08:	fc 81       	ldd	r31, Y+4	; 0x04
    1c0a:	86 89       	ldd	r24, Z+22	; 0x16
    1c0c:	28 2f       	mov	r18, r24
    1c0e:	30 e0       	ldi	r19, 0x00	; 0
    1c10:	c9 01       	movw	r24, r18
    1c12:	88 0f       	add	r24, r24
    1c14:	99 1f       	adc	r25, r25
    1c16:	88 0f       	add	r24, r24
    1c18:	99 1f       	adc	r25, r25
    1c1a:	88 0f       	add	r24, r24
    1c1c:	99 1f       	adc	r25, r25
    1c1e:	82 0f       	add	r24, r18
    1c20:	93 1f       	adc	r25, r19
    1c22:	ac 01       	movw	r20, r24
    1c24:	46 5d       	subi	r20, 0xD6	; 214
    1c26:	5c 4f       	sbci	r21, 0xFC	; 252
    1c28:	8b 81       	ldd	r24, Y+3	; 0x03
    1c2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c2c:	9c 01       	movw	r18, r24
    1c2e:	2e 5f       	subi	r18, 0xFE	; 254
    1c30:	3f 4f       	sbci	r19, 0xFF	; 255
    1c32:	ca 01       	movw	r24, r20
    1c34:	b9 01       	movw	r22, r18
    1c36:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListInsertEnd>

			xReturn = pdPASS;
    1c3a:	81 e0       	ldi	r24, 0x01	; 1
    1c3c:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1c3e:	0f 90       	pop	r0
    1c40:	0f be       	out	0x3f, r0	; 63
    1c42:	02 c0       	rjmp	.+4      	; 0x1c48 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1c44:	8f ef       	ldi	r24, 0xFF	; 255
    1c46:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    1c48:	8d 81       	ldd	r24, Y+5	; 0x05
    1c4a:	81 30       	cpi	r24, 0x01	; 1
    1c4c:	71 f4       	brne	.+28     	; 0x1c6a <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    1c4e:	80 91 24 03 	lds	r24, 0x0324
    1c52:	88 23       	and	r24, r24
    1c54:	51 f0       	breq	.+20     	; 0x1c6a <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1c56:	e0 91 1c 03 	lds	r30, 0x031C
    1c5a:	f0 91 1d 03 	lds	r31, 0x031D
    1c5e:	96 89       	ldd	r25, Z+22	; 0x16
    1c60:	8e 85       	ldd	r24, Y+14	; 0x0e
    1c62:	98 17       	cp	r25, r24
    1c64:	10 f4       	brcc	.+4      	; 0x1c6a <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    1c66:	0e 94 c6 07 	call	0xf8c	; 0xf8c <vPortYield>
			}
		}
	}

	return xReturn;
    1c6a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1c6c:	64 96       	adiw	r28, 0x14	; 20
    1c6e:	0f b6       	in	r0, 0x3f	; 63
    1c70:	f8 94       	cli
    1c72:	de bf       	out	0x3e, r29	; 62
    1c74:	0f be       	out	0x3f, r0	; 63
    1c76:	cd bf       	out	0x3d, r28	; 61
    1c78:	cf 91       	pop	r28
    1c7a:	df 91       	pop	r29
    1c7c:	1f 91       	pop	r17
    1c7e:	0f 91       	pop	r16
    1c80:	ff 90       	pop	r15
    1c82:	ef 90       	pop	r14
    1c84:	df 90       	pop	r13
    1c86:	cf 90       	pop	r12
    1c88:	bf 90       	pop	r11
    1c8a:	af 90       	pop	r10
    1c8c:	08 95       	ret

00001c8e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1c8e:	df 93       	push	r29
    1c90:	cf 93       	push	r28
    1c92:	00 d0       	rcall	.+0      	; 0x1c94 <vTaskDelete+0x6>
    1c94:	00 d0       	rcall	.+0      	; 0x1c96 <vTaskDelete+0x8>
    1c96:	00 d0       	rcall	.+0      	; 0x1c98 <vTaskDelete+0xa>
    1c98:	cd b7       	in	r28, 0x3d	; 61
    1c9a:	de b7       	in	r29, 0x3e	; 62
    1c9c:	9c 83       	std	Y+4, r25	; 0x04
    1c9e:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1ca0:	0f b6       	in	r0, 0x3f	; 63
    1ca2:	f8 94       	cli
    1ca4:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1ca6:	20 91 1c 03 	lds	r18, 0x031C
    1caa:	30 91 1d 03 	lds	r19, 0x031D
    1cae:	8b 81       	ldd	r24, Y+3	; 0x03
    1cb0:	9c 81       	ldd	r25, Y+4	; 0x04
    1cb2:	82 17       	cp	r24, r18
    1cb4:	93 07       	cpc	r25, r19
    1cb6:	11 f4       	brne	.+4      	; 0x1cbc <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    1cb8:	1c 82       	std	Y+4, r1	; 0x04
    1cba:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1cbc:	8b 81       	ldd	r24, Y+3	; 0x03
    1cbe:	9c 81       	ldd	r25, Y+4	; 0x04
    1cc0:	00 97       	sbiw	r24, 0x00	; 0
    1cc2:	39 f4       	brne	.+14     	; 0x1cd2 <vTaskDelete+0x44>
    1cc4:	80 91 1c 03 	lds	r24, 0x031C
    1cc8:	90 91 1d 03 	lds	r25, 0x031D
    1ccc:	9e 83       	std	Y+6, r25	; 0x06
    1cce:	8d 83       	std	Y+5, r24	; 0x05
    1cd0:	04 c0       	rjmp	.+8      	; 0x1cda <vTaskDelete+0x4c>
    1cd2:	8b 81       	ldd	r24, Y+3	; 0x03
    1cd4:	9c 81       	ldd	r25, Y+4	; 0x04
    1cd6:	9e 83       	std	Y+6, r25	; 0x06
    1cd8:	8d 83       	std	Y+5, r24	; 0x05
    1cda:	8d 81       	ldd	r24, Y+5	; 0x05
    1cdc:	9e 81       	ldd	r25, Y+6	; 0x06
    1cde:	9a 83       	std	Y+2, r25	; 0x02
    1ce0:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1ce2:	89 81       	ldd	r24, Y+1	; 0x01
    1ce4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ce6:	02 96       	adiw	r24, 0x02	; 2
    1ce8:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1cec:	e9 81       	ldd	r30, Y+1	; 0x01
    1cee:	fa 81       	ldd	r31, Y+2	; 0x02
    1cf0:	84 89       	ldd	r24, Z+20	; 0x14
    1cf2:	95 89       	ldd	r25, Z+21	; 0x15
    1cf4:	00 97       	sbiw	r24, 0x00	; 0
    1cf6:	29 f0       	breq	.+10     	; 0x1d02 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1cf8:	89 81       	ldd	r24, Y+1	; 0x01
    1cfa:	9a 81       	ldd	r25, Y+2	; 0x02
    1cfc:	0c 96       	adiw	r24, 0x0c	; 12
    1cfe:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1d02:	89 81       	ldd	r24, Y+1	; 0x01
    1d04:	9a 81       	ldd	r25, Y+2	; 0x02
    1d06:	9c 01       	movw	r18, r24
    1d08:	2e 5f       	subi	r18, 0xFE	; 254
    1d0a:	3f 4f       	sbci	r19, 0xFF	; 255
    1d0c:	86 e7       	ldi	r24, 0x76	; 118
    1d0e:	93 e0       	ldi	r25, 0x03	; 3
    1d10:	b9 01       	movw	r22, r18
    1d12:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1d16:	80 91 1e 03 	lds	r24, 0x031E
    1d1a:	8f 5f       	subi	r24, 0xFF	; 255
    1d1c:	80 93 1e 03 	sts	0x031E, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1d20:	80 91 29 03 	lds	r24, 0x0329
    1d24:	8f 5f       	subi	r24, 0xFF	; 255
    1d26:	80 93 29 03 	sts	0x0329, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1d2a:	0f 90       	pop	r0
    1d2c:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1d2e:	80 91 24 03 	lds	r24, 0x0324
    1d32:	88 23       	and	r24, r24
    1d34:	31 f0       	breq	.+12     	; 0x1d42 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1d36:	8b 81       	ldd	r24, Y+3	; 0x03
    1d38:	9c 81       	ldd	r25, Y+4	; 0x04
    1d3a:	00 97       	sbiw	r24, 0x00	; 0
    1d3c:	11 f4       	brne	.+4      	; 0x1d42 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    1d3e:	0e 94 c6 07 	call	0xf8c	; 0xf8c <vPortYield>
			}
		}
	}
    1d42:	26 96       	adiw	r28, 0x06	; 6
    1d44:	0f b6       	in	r0, 0x3f	; 63
    1d46:	f8 94       	cli
    1d48:	de bf       	out	0x3e, r29	; 62
    1d4a:	0f be       	out	0x3f, r0	; 63
    1d4c:	cd bf       	out	0x3d, r28	; 61
    1d4e:	cf 91       	pop	r28
    1d50:	df 91       	pop	r29
    1d52:	08 95       	ret

00001d54 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1d54:	df 93       	push	r29
    1d56:	cf 93       	push	r28
    1d58:	cd b7       	in	r28, 0x3d	; 61
    1d5a:	de b7       	in	r29, 0x3e	; 62
    1d5c:	28 97       	sbiw	r28, 0x08	; 8
    1d5e:	0f b6       	in	r0, 0x3f	; 63
    1d60:	f8 94       	cli
    1d62:	de bf       	out	0x3e, r29	; 62
    1d64:	0f be       	out	0x3f, r0	; 63
    1d66:	cd bf       	out	0x3d, r28	; 61
    1d68:	9e 83       	std	Y+6, r25	; 0x06
    1d6a:	8d 83       	std	Y+5, r24	; 0x05
    1d6c:	78 87       	std	Y+8, r23	; 0x08
    1d6e:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    1d70:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1d72:	0e 94 75 10 	call	0x20ea	; 0x20ea <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1d76:	ed 81       	ldd	r30, Y+5	; 0x05
    1d78:	fe 81       	ldd	r31, Y+6	; 0x06
    1d7a:	20 81       	ld	r18, Z
    1d7c:	31 81       	ldd	r19, Z+1	; 0x01
    1d7e:	8f 81       	ldd	r24, Y+7	; 0x07
    1d80:	98 85       	ldd	r25, Y+8	; 0x08
    1d82:	82 0f       	add	r24, r18
    1d84:	93 1f       	adc	r25, r19
    1d86:	9c 83       	std	Y+4, r25	; 0x04
    1d88:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    1d8a:	ed 81       	ldd	r30, Y+5	; 0x05
    1d8c:	fe 81       	ldd	r31, Y+6	; 0x06
    1d8e:	20 81       	ld	r18, Z
    1d90:	31 81       	ldd	r19, Z+1	; 0x01
    1d92:	80 91 20 03 	lds	r24, 0x0320
    1d96:	90 91 21 03 	lds	r25, 0x0321
    1d9a:	82 17       	cp	r24, r18
    1d9c:	93 07       	cpc	r25, r19
    1d9e:	a8 f4       	brcc	.+42     	; 0x1dca <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1da0:	ed 81       	ldd	r30, Y+5	; 0x05
    1da2:	fe 81       	ldd	r31, Y+6	; 0x06
    1da4:	20 81       	ld	r18, Z
    1da6:	31 81       	ldd	r19, Z+1	; 0x01
    1da8:	8b 81       	ldd	r24, Y+3	; 0x03
    1daa:	9c 81       	ldd	r25, Y+4	; 0x04
    1dac:	82 17       	cp	r24, r18
    1dae:	93 07       	cpc	r25, r19
    1db0:	00 f5       	brcc	.+64     	; 0x1df2 <vTaskDelayUntil+0x9e>
    1db2:	20 91 20 03 	lds	r18, 0x0320
    1db6:	30 91 21 03 	lds	r19, 0x0321
    1dba:	8b 81       	ldd	r24, Y+3	; 0x03
    1dbc:	9c 81       	ldd	r25, Y+4	; 0x04
    1dbe:	28 17       	cp	r18, r24
    1dc0:	39 07       	cpc	r19, r25
    1dc2:	b8 f4       	brcc	.+46     	; 0x1df2 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1dc4:	81 e0       	ldi	r24, 0x01	; 1
    1dc6:	89 83       	std	Y+1, r24	; 0x01
    1dc8:	14 c0       	rjmp	.+40     	; 0x1df2 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1dca:	ed 81       	ldd	r30, Y+5	; 0x05
    1dcc:	fe 81       	ldd	r31, Y+6	; 0x06
    1dce:	20 81       	ld	r18, Z
    1dd0:	31 81       	ldd	r19, Z+1	; 0x01
    1dd2:	8b 81       	ldd	r24, Y+3	; 0x03
    1dd4:	9c 81       	ldd	r25, Y+4	; 0x04
    1dd6:	82 17       	cp	r24, r18
    1dd8:	93 07       	cpc	r25, r19
    1dda:	48 f0       	brcs	.+18     	; 0x1dee <vTaskDelayUntil+0x9a>
    1ddc:	20 91 20 03 	lds	r18, 0x0320
    1de0:	30 91 21 03 	lds	r19, 0x0321
    1de4:	8b 81       	ldd	r24, Y+3	; 0x03
    1de6:	9c 81       	ldd	r25, Y+4	; 0x04
    1de8:	28 17       	cp	r18, r24
    1dea:	39 07       	cpc	r19, r25
    1dec:	10 f4       	brcc	.+4      	; 0x1df2 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1dee:	81 e0       	ldi	r24, 0x01	; 1
    1df0:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1df2:	ed 81       	ldd	r30, Y+5	; 0x05
    1df4:	fe 81       	ldd	r31, Y+6	; 0x06
    1df6:	8b 81       	ldd	r24, Y+3	; 0x03
    1df8:	9c 81       	ldd	r25, Y+4	; 0x04
    1dfa:	91 83       	std	Z+1, r25	; 0x01
    1dfc:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1dfe:	89 81       	ldd	r24, Y+1	; 0x01
    1e00:	88 23       	and	r24, r24
    1e02:	59 f0       	breq	.+22     	; 0x1e1a <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1e04:	80 91 1c 03 	lds	r24, 0x031C
    1e08:	90 91 1d 03 	lds	r25, 0x031D
    1e0c:	02 96       	adiw	r24, 0x02	; 2
    1e0e:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1e12:	8b 81       	ldd	r24, Y+3	; 0x03
    1e14:	9c 81       	ldd	r25, Y+4	; 0x04
    1e16:	0e 94 75 14 	call	0x28ea	; 0x28ea <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1e1a:	0e 94 81 10 	call	0x2102	; 0x2102 <xTaskResumeAll>
    1e1e:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1e20:	8a 81       	ldd	r24, Y+2	; 0x02
    1e22:	88 23       	and	r24, r24
    1e24:	11 f4       	brne	.+4      	; 0x1e2a <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    1e26:	0e 94 c6 07 	call	0xf8c	; 0xf8c <vPortYield>
		}
	}
    1e2a:	28 96       	adiw	r28, 0x08	; 8
    1e2c:	0f b6       	in	r0, 0x3f	; 63
    1e2e:	f8 94       	cli
    1e30:	de bf       	out	0x3e, r29	; 62
    1e32:	0f be       	out	0x3f, r0	; 63
    1e34:	cd bf       	out	0x3d, r28	; 61
    1e36:	cf 91       	pop	r28
    1e38:	df 91       	pop	r29
    1e3a:	08 95       	ret

00001e3c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1e3c:	df 93       	push	r29
    1e3e:	cf 93       	push	r28
    1e40:	00 d0       	rcall	.+0      	; 0x1e42 <vTaskDelay+0x6>
    1e42:	00 d0       	rcall	.+0      	; 0x1e44 <vTaskDelay+0x8>
    1e44:	0f 92       	push	r0
    1e46:	cd b7       	in	r28, 0x3d	; 61
    1e48:	de b7       	in	r29, 0x3e	; 62
    1e4a:	9d 83       	std	Y+5, r25	; 0x05
    1e4c:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1e4e:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1e50:	8c 81       	ldd	r24, Y+4	; 0x04
    1e52:	9d 81       	ldd	r25, Y+5	; 0x05
    1e54:	00 97       	sbiw	r24, 0x00	; 0
    1e56:	d1 f0       	breq	.+52     	; 0x1e8c <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    1e58:	0e 94 75 10 	call	0x20ea	; 0x20ea <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1e5c:	20 91 20 03 	lds	r18, 0x0320
    1e60:	30 91 21 03 	lds	r19, 0x0321
    1e64:	8c 81       	ldd	r24, Y+4	; 0x04
    1e66:	9d 81       	ldd	r25, Y+5	; 0x05
    1e68:	82 0f       	add	r24, r18
    1e6a:	93 1f       	adc	r25, r19
    1e6c:	9b 83       	std	Y+3, r25	; 0x03
    1e6e:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1e70:	80 91 1c 03 	lds	r24, 0x031C
    1e74:	90 91 1d 03 	lds	r25, 0x031D
    1e78:	02 96       	adiw	r24, 0x02	; 2
    1e7a:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1e7e:	8a 81       	ldd	r24, Y+2	; 0x02
    1e80:	9b 81       	ldd	r25, Y+3	; 0x03
    1e82:	0e 94 75 14 	call	0x28ea	; 0x28ea <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1e86:	0e 94 81 10 	call	0x2102	; 0x2102 <xTaskResumeAll>
    1e8a:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1e8c:	89 81       	ldd	r24, Y+1	; 0x01
    1e8e:	88 23       	and	r24, r24
    1e90:	11 f4       	brne	.+4      	; 0x1e96 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    1e92:	0e 94 c6 07 	call	0xf8c	; 0xf8c <vPortYield>
		}
	}
    1e96:	0f 90       	pop	r0
    1e98:	0f 90       	pop	r0
    1e9a:	0f 90       	pop	r0
    1e9c:	0f 90       	pop	r0
    1e9e:	0f 90       	pop	r0
    1ea0:	cf 91       	pop	r28
    1ea2:	df 91       	pop	r29
    1ea4:	08 95       	ret

00001ea6 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
    1ea6:	df 93       	push	r29
    1ea8:	cf 93       	push	r28
    1eaa:	cd b7       	in	r28, 0x3d	; 61
    1eac:	de b7       	in	r29, 0x3e	; 62
    1eae:	27 97       	sbiw	r28, 0x07	; 7
    1eb0:	0f b6       	in	r0, 0x3f	; 63
    1eb2:	f8 94       	cli
    1eb4:	de bf       	out	0x3e, r29	; 62
    1eb6:	0f be       	out	0x3f, r0	; 63
    1eb8:	cd bf       	out	0x3d, r28	; 61
    1eba:	9d 83       	std	Y+5, r25	; 0x05
    1ebc:	8c 83       	std	Y+4, r24	; 0x04
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
    1ebe:	0f b6       	in	r0, 0x3f	; 63
    1ec0:	f8 94       	cli
    1ec2:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1ec4:	8c 81       	ldd	r24, Y+4	; 0x04
    1ec6:	9d 81       	ldd	r25, Y+5	; 0x05
    1ec8:	00 97       	sbiw	r24, 0x00	; 0
    1eca:	39 f4       	brne	.+14     	; 0x1eda <uxTaskPriorityGet+0x34>
    1ecc:	80 91 1c 03 	lds	r24, 0x031C
    1ed0:	90 91 1d 03 	lds	r25, 0x031D
    1ed4:	9f 83       	std	Y+7, r25	; 0x07
    1ed6:	8e 83       	std	Y+6, r24	; 0x06
    1ed8:	04 c0       	rjmp	.+8      	; 0x1ee2 <uxTaskPriorityGet+0x3c>
    1eda:	8c 81       	ldd	r24, Y+4	; 0x04
    1edc:	9d 81       	ldd	r25, Y+5	; 0x05
    1ede:	9f 83       	std	Y+7, r25	; 0x07
    1ee0:	8e 83       	std	Y+6, r24	; 0x06
    1ee2:	8e 81       	ldd	r24, Y+6	; 0x06
    1ee4:	9f 81       	ldd	r25, Y+7	; 0x07
    1ee6:	9b 83       	std	Y+3, r25	; 0x03
    1ee8:	8a 83       	std	Y+2, r24	; 0x02
			uxReturn = pxTCB->uxPriority;
    1eea:	ea 81       	ldd	r30, Y+2	; 0x02
    1eec:	fb 81       	ldd	r31, Y+3	; 0x03
    1eee:	86 89       	ldd	r24, Z+22	; 0x16
    1ef0:	89 83       	std	Y+1, r24	; 0x01
		}
		taskEXIT_CRITICAL();
    1ef2:	0f 90       	pop	r0
    1ef4:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
    1ef6:	89 81       	ldd	r24, Y+1	; 0x01
	}
    1ef8:	27 96       	adiw	r28, 0x07	; 7
    1efa:	0f b6       	in	r0, 0x3f	; 63
    1efc:	f8 94       	cli
    1efe:	de bf       	out	0x3e, r29	; 62
    1f00:	0f be       	out	0x3f, r0	; 63
    1f02:	cd bf       	out	0x3d, r28	; 61
    1f04:	cf 91       	pop	r28
    1f06:	df 91       	pop	r29
    1f08:	08 95       	ret

00001f0a <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    1f0a:	df 93       	push	r29
    1f0c:	cf 93       	push	r28
    1f0e:	cd b7       	in	r28, 0x3d	; 61
    1f10:	de b7       	in	r29, 0x3e	; 62
    1f12:	29 97       	sbiw	r28, 0x09	; 9
    1f14:	0f b6       	in	r0, 0x3f	; 63
    1f16:	f8 94       	cli
    1f18:	de bf       	out	0x3e, r29	; 62
    1f1a:	0f be       	out	0x3f, r0	; 63
    1f1c:	cd bf       	out	0x3d, r28	; 61
    1f1e:	9e 83       	std	Y+6, r25	; 0x06
    1f20:	8d 83       	std	Y+5, r24	; 0x05
    1f22:	6f 83       	std	Y+7, r22	; 0x07
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentPriority;
	portBASE_TYPE xYieldRequired = pdFALSE;
    1f24:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= configMAX_PRIORITIES )
    1f26:	8f 81       	ldd	r24, Y+7	; 0x07
    1f28:	85 30       	cpi	r24, 0x05	; 5
    1f2a:	10 f0       	brcs	.+4      	; 0x1f30 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    1f2c:	84 e0       	ldi	r24, 0x04	; 4
    1f2e:	8f 83       	std	Y+7, r24	; 0x07
		}

		taskENTER_CRITICAL();
    1f30:	0f b6       	in	r0, 0x3f	; 63
    1f32:	f8 94       	cli
    1f34:	0f 92       	push	r0
		{
			if( pxTask == pxCurrentTCB )
    1f36:	20 91 1c 03 	lds	r18, 0x031C
    1f3a:	30 91 1d 03 	lds	r19, 0x031D
    1f3e:	8d 81       	ldd	r24, Y+5	; 0x05
    1f40:	9e 81       	ldd	r25, Y+6	; 0x06
    1f42:	82 17       	cp	r24, r18
    1f44:	93 07       	cpc	r25, r19
    1f46:	11 f4       	brne	.+4      	; 0x1f4c <vTaskPrioritySet+0x42>
			{
				pxTask = NULL;
    1f48:	1e 82       	std	Y+6, r1	; 0x06
    1f4a:	1d 82       	std	Y+5, r1	; 0x05
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1f4c:	8d 81       	ldd	r24, Y+5	; 0x05
    1f4e:	9e 81       	ldd	r25, Y+6	; 0x06
    1f50:	00 97       	sbiw	r24, 0x00	; 0
    1f52:	39 f4       	brne	.+14     	; 0x1f62 <vTaskPrioritySet+0x58>
    1f54:	80 91 1c 03 	lds	r24, 0x031C
    1f58:	90 91 1d 03 	lds	r25, 0x031D
    1f5c:	99 87       	std	Y+9, r25	; 0x09
    1f5e:	88 87       	std	Y+8, r24	; 0x08
    1f60:	04 c0       	rjmp	.+8      	; 0x1f6a <vTaskPrioritySet+0x60>
    1f62:	8d 81       	ldd	r24, Y+5	; 0x05
    1f64:	9e 81       	ldd	r25, Y+6	; 0x06
    1f66:	99 87       	std	Y+9, r25	; 0x09
    1f68:	88 87       	std	Y+8, r24	; 0x08
    1f6a:	88 85       	ldd	r24, Y+8	; 0x08
    1f6c:	99 85       	ldd	r25, Y+9	; 0x09
    1f6e:	9c 83       	std	Y+4, r25	; 0x04
    1f70:	8b 83       	std	Y+3, r24	; 0x03
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentPriority = pxTCB->uxPriority;
    1f72:	eb 81       	ldd	r30, Y+3	; 0x03
    1f74:	fc 81       	ldd	r31, Y+4	; 0x04
    1f76:	86 89       	ldd	r24, Z+22	; 0x16
    1f78:	8a 83       	std	Y+2, r24	; 0x02
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    1f7a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f7c:	8f 81       	ldd	r24, Y+7	; 0x07
    1f7e:	98 17       	cp	r25, r24
    1f80:	09 f4       	brne	.+2      	; 0x1f84 <vTaskPrioritySet+0x7a>
    1f82:	65 c0       	rjmp	.+202    	; 0x204e <vTaskPrioritySet+0x144>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    1f84:	9f 81       	ldd	r25, Y+7	; 0x07
    1f86:	8a 81       	ldd	r24, Y+2	; 0x02
    1f88:	89 17       	cp	r24, r25
    1f8a:	38 f4       	brcc	.+14     	; 0x1f9a <vTaskPrioritySet+0x90>
				{
					if( pxTask != NULL )
    1f8c:	8d 81       	ldd	r24, Y+5	; 0x05
    1f8e:	9e 81       	ldd	r25, Y+6	; 0x06
    1f90:	00 97       	sbiw	r24, 0x00	; 0
    1f92:	49 f0       	breq	.+18     	; 0x1fa6 <vTaskPrioritySet+0x9c>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    1f94:	81 e0       	ldi	r24, 0x01	; 1
    1f96:	89 83       	std	Y+1, r24	; 0x01
    1f98:	06 c0       	rjmp	.+12     	; 0x1fa6 <vTaskPrioritySet+0x9c>
					}
				}
				else if( pxTask == NULL )
    1f9a:	8d 81       	ldd	r24, Y+5	; 0x05
    1f9c:	9e 81       	ldd	r25, Y+6	; 0x06
    1f9e:	00 97       	sbiw	r24, 0x00	; 0
    1fa0:	11 f4       	brne	.+4      	; 0x1fa6 <vTaskPrioritySet+0x9c>
				{
					/* Setting our own priority down means there may now be another
					task of higher priority that is ready to execute. */
					xYieldRequired = pdTRUE;
    1fa2:	81 e0       	ldi	r24, 0x01	; 1
    1fa4:	89 83       	std	Y+1, r24	; 0x01
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    1fa6:	eb 81       	ldd	r30, Y+3	; 0x03
    1fa8:	fc 81       	ldd	r31, Y+4	; 0x04
    1faa:	8f 81       	ldd	r24, Y+7	; 0x07
    1fac:	86 8b       	std	Z+22, r24	; 0x16
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    1fae:	8f 81       	ldd	r24, Y+7	; 0x07
    1fb0:	28 2f       	mov	r18, r24
    1fb2:	30 e0       	ldi	r19, 0x00	; 0
    1fb4:	85 e0       	ldi	r24, 0x05	; 5
    1fb6:	90 e0       	ldi	r25, 0x00	; 0
    1fb8:	82 1b       	sub	r24, r18
    1fba:	93 0b       	sbc	r25, r19
    1fbc:	eb 81       	ldd	r30, Y+3	; 0x03
    1fbe:	fc 81       	ldd	r31, Y+4	; 0x04
    1fc0:	95 87       	std	Z+13, r25	; 0x0d
    1fc2:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    1fc4:	eb 81       	ldd	r30, Y+3	; 0x03
    1fc6:	fc 81       	ldd	r31, Y+4	; 0x04
    1fc8:	42 85       	ldd	r20, Z+10	; 0x0a
    1fca:	53 85       	ldd	r21, Z+11	; 0x0b
    1fcc:	8a 81       	ldd	r24, Y+2	; 0x02
    1fce:	28 2f       	mov	r18, r24
    1fd0:	30 e0       	ldi	r19, 0x00	; 0
    1fd2:	c9 01       	movw	r24, r18
    1fd4:	88 0f       	add	r24, r24
    1fd6:	99 1f       	adc	r25, r25
    1fd8:	88 0f       	add	r24, r24
    1fda:	99 1f       	adc	r25, r25
    1fdc:	88 0f       	add	r24, r24
    1fde:	99 1f       	adc	r25, r25
    1fe0:	82 0f       	add	r24, r18
    1fe2:	93 1f       	adc	r25, r19
    1fe4:	86 5d       	subi	r24, 0xD6	; 214
    1fe6:	9c 4f       	sbci	r25, 0xFC	; 252
    1fe8:	48 17       	cp	r20, r24
    1fea:	59 07       	cpc	r21, r25
    1fec:	59 f5       	brne	.+86     	; 0x2044 <vTaskPrioritySet+0x13a>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    1fee:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ff2:	02 96       	adiw	r24, 0x02	; 2
    1ff4:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1ff8:	eb 81       	ldd	r30, Y+3	; 0x03
    1ffa:	fc 81       	ldd	r31, Y+4	; 0x04
    1ffc:	96 89       	ldd	r25, Z+22	; 0x16
    1ffe:	80 91 23 03 	lds	r24, 0x0323
    2002:	89 17       	cp	r24, r25
    2004:	28 f4       	brcc	.+10     	; 0x2010 <vTaskPrioritySet+0x106>
    2006:	eb 81       	ldd	r30, Y+3	; 0x03
    2008:	fc 81       	ldd	r31, Y+4	; 0x04
    200a:	86 89       	ldd	r24, Z+22	; 0x16
    200c:	80 93 23 03 	sts	0x0323, r24
    2010:	eb 81       	ldd	r30, Y+3	; 0x03
    2012:	fc 81       	ldd	r31, Y+4	; 0x04
    2014:	86 89       	ldd	r24, Z+22	; 0x16
    2016:	28 2f       	mov	r18, r24
    2018:	30 e0       	ldi	r19, 0x00	; 0
    201a:	c9 01       	movw	r24, r18
    201c:	88 0f       	add	r24, r24
    201e:	99 1f       	adc	r25, r25
    2020:	88 0f       	add	r24, r24
    2022:	99 1f       	adc	r25, r25
    2024:	88 0f       	add	r24, r24
    2026:	99 1f       	adc	r25, r25
    2028:	82 0f       	add	r24, r18
    202a:	93 1f       	adc	r25, r19
    202c:	ac 01       	movw	r20, r24
    202e:	46 5d       	subi	r20, 0xD6	; 214
    2030:	5c 4f       	sbci	r21, 0xFC	; 252
    2032:	8b 81       	ldd	r24, Y+3	; 0x03
    2034:	9c 81       	ldd	r25, Y+4	; 0x04
    2036:	9c 01       	movw	r18, r24
    2038:	2e 5f       	subi	r18, 0xFE	; 254
    203a:	3f 4f       	sbci	r19, 0xFF	; 255
    203c:	ca 01       	movw	r24, r20
    203e:	b9 01       	movw	r22, r18
    2040:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListInsertEnd>
				}

				if( xYieldRequired == pdTRUE )
    2044:	89 81       	ldd	r24, Y+1	; 0x01
    2046:	81 30       	cpi	r24, 0x01	; 1
    2048:	11 f4       	brne	.+4      	; 0x204e <vTaskPrioritySet+0x144>
				{
					portYIELD_WITHIN_API();
    204a:	0e 94 c6 07 	call	0xf8c	; 0xf8c <vPortYield>
				}
			}
		}
		taskEXIT_CRITICAL();
    204e:	0f 90       	pop	r0
    2050:	0f be       	out	0x3f, r0	; 63
	}
    2052:	29 96       	adiw	r28, 0x09	; 9
    2054:	0f b6       	in	r0, 0x3f	; 63
    2056:	f8 94       	cli
    2058:	de bf       	out	0x3e, r29	; 62
    205a:	0f be       	out	0x3f, r0	; 63
    205c:	cd bf       	out	0x3d, r28	; 61
    205e:	cf 91       	pop	r28
    2060:	df 91       	pop	r29
    2062:	08 95       	ret

00002064 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2064:	af 92       	push	r10
    2066:	bf 92       	push	r11
    2068:	cf 92       	push	r12
    206a:	df 92       	push	r13
    206c:	ef 92       	push	r14
    206e:	ff 92       	push	r15
    2070:	0f 93       	push	r16
    2072:	df 93       	push	r29
    2074:	cf 93       	push	r28
    2076:	0f 92       	push	r0
    2078:	cd b7       	in	r28, 0x3d	; 61
    207a:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    207c:	29 e7       	ldi	r18, 0x79	; 121
    207e:	30 e0       	ldi	r19, 0x00	; 0
    2080:	89 e9       	ldi	r24, 0x99	; 153
    2082:	93 e1       	ldi	r25, 0x13	; 19
    2084:	b9 01       	movw	r22, r18
    2086:	45 e5       	ldi	r20, 0x55	; 85
    2088:	50 e0       	ldi	r21, 0x00	; 0
    208a:	20 e0       	ldi	r18, 0x00	; 0
    208c:	30 e0       	ldi	r19, 0x00	; 0
    208e:	00 e0       	ldi	r16, 0x00	; 0
    2090:	ee 24       	eor	r14, r14
    2092:	ff 24       	eor	r15, r15
    2094:	cc 24       	eor	r12, r12
    2096:	dd 24       	eor	r13, r13
    2098:	aa 24       	eor	r10, r10
    209a:	bb 24       	eor	r11, r11
    209c:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <xTaskGenericCreate>
    20a0:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    20a2:	89 81       	ldd	r24, Y+1	; 0x01
    20a4:	81 30       	cpi	r24, 0x01	; 1
    20a6:	51 f4       	brne	.+20     	; 0x20bc <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    20a8:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    20aa:	81 e0       	ldi	r24, 0x01	; 1
    20ac:	80 93 24 03 	sts	0x0324, r24
		xTickCount = ( portTickType ) 0U;
    20b0:	10 92 21 03 	sts	0x0321, r1
    20b4:	10 92 20 03 	sts	0x0320, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    20b8:	0e 94 8a 07 	call	0xf14	; 0xf14 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    20bc:	0f 90       	pop	r0
    20be:	cf 91       	pop	r28
    20c0:	df 91       	pop	r29
    20c2:	0f 91       	pop	r16
    20c4:	ff 90       	pop	r15
    20c6:	ef 90       	pop	r14
    20c8:	df 90       	pop	r13
    20ca:	cf 90       	pop	r12
    20cc:	bf 90       	pop	r11
    20ce:	af 90       	pop	r10
    20d0:	08 95       	ret

000020d2 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    20d2:	df 93       	push	r29
    20d4:	cf 93       	push	r28
    20d6:	cd b7       	in	r28, 0x3d	; 61
    20d8:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    20da:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    20dc:	10 92 24 03 	sts	0x0324, r1
	vPortEndScheduler();
    20e0:	0e 94 bf 07 	call	0xf7e	; 0xf7e <vPortEndScheduler>
}
    20e4:	cf 91       	pop	r28
    20e6:	df 91       	pop	r29
    20e8:	08 95       	ret

000020ea <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    20ea:	df 93       	push	r29
    20ec:	cf 93       	push	r28
    20ee:	cd b7       	in	r28, 0x3d	; 61
    20f0:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    20f2:	80 91 25 03 	lds	r24, 0x0325
    20f6:	8f 5f       	subi	r24, 0xFF	; 255
    20f8:	80 93 25 03 	sts	0x0325, r24
}
    20fc:	cf 91       	pop	r28
    20fe:	df 91       	pop	r29
    2100:	08 95       	ret

00002102 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2102:	df 93       	push	r29
    2104:	cf 93       	push	r28
    2106:	00 d0       	rcall	.+0      	; 0x2108 <xTaskResumeAll+0x6>
    2108:	00 d0       	rcall	.+0      	; 0x210a <xTaskResumeAll+0x8>
    210a:	cd b7       	in	r28, 0x3d	; 61
    210c:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    210e:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2110:	0f b6       	in	r0, 0x3f	; 63
    2112:	f8 94       	cli
    2114:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2116:	80 91 25 03 	lds	r24, 0x0325
    211a:	81 50       	subi	r24, 0x01	; 1
    211c:	80 93 25 03 	sts	0x0325, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2120:	80 91 25 03 	lds	r24, 0x0325
    2124:	88 23       	and	r24, r24
    2126:	09 f0       	breq	.+2      	; 0x212a <xTaskResumeAll+0x28>
    2128:	6c c0       	rjmp	.+216    	; 0x2202 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    212a:	80 91 1f 03 	lds	r24, 0x031F
    212e:	88 23       	and	r24, r24
    2130:	09 f4       	brne	.+2      	; 0x2134 <xTaskResumeAll+0x32>
    2132:	67 c0       	rjmp	.+206    	; 0x2202 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    2134:	19 82       	std	Y+1, r1	; 0x01
    2136:	41 c0       	rjmp	.+130    	; 0x21ba <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2138:	e0 91 72 03 	lds	r30, 0x0372
    213c:	f0 91 73 03 	lds	r31, 0x0373
    2140:	86 81       	ldd	r24, Z+6	; 0x06
    2142:	97 81       	ldd	r25, Z+7	; 0x07
    2144:	9c 83       	std	Y+4, r25	; 0x04
    2146:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    2148:	8b 81       	ldd	r24, Y+3	; 0x03
    214a:	9c 81       	ldd	r25, Y+4	; 0x04
    214c:	0c 96       	adiw	r24, 0x0c	; 12
    214e:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2152:	8b 81       	ldd	r24, Y+3	; 0x03
    2154:	9c 81       	ldd	r25, Y+4	; 0x04
    2156:	02 96       	adiw	r24, 0x02	; 2
    2158:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    215c:	eb 81       	ldd	r30, Y+3	; 0x03
    215e:	fc 81       	ldd	r31, Y+4	; 0x04
    2160:	96 89       	ldd	r25, Z+22	; 0x16
    2162:	80 91 23 03 	lds	r24, 0x0323
    2166:	89 17       	cp	r24, r25
    2168:	28 f4       	brcc	.+10     	; 0x2174 <xTaskResumeAll+0x72>
    216a:	eb 81       	ldd	r30, Y+3	; 0x03
    216c:	fc 81       	ldd	r31, Y+4	; 0x04
    216e:	86 89       	ldd	r24, Z+22	; 0x16
    2170:	80 93 23 03 	sts	0x0323, r24
    2174:	eb 81       	ldd	r30, Y+3	; 0x03
    2176:	fc 81       	ldd	r31, Y+4	; 0x04
    2178:	86 89       	ldd	r24, Z+22	; 0x16
    217a:	28 2f       	mov	r18, r24
    217c:	30 e0       	ldi	r19, 0x00	; 0
    217e:	c9 01       	movw	r24, r18
    2180:	88 0f       	add	r24, r24
    2182:	99 1f       	adc	r25, r25
    2184:	88 0f       	add	r24, r24
    2186:	99 1f       	adc	r25, r25
    2188:	88 0f       	add	r24, r24
    218a:	99 1f       	adc	r25, r25
    218c:	82 0f       	add	r24, r18
    218e:	93 1f       	adc	r25, r19
    2190:	86 5d       	subi	r24, 0xD6	; 214
    2192:	9c 4f       	sbci	r25, 0xFC	; 252
    2194:	2b 81       	ldd	r18, Y+3	; 0x03
    2196:	3c 81       	ldd	r19, Y+4	; 0x04
    2198:	2e 5f       	subi	r18, 0xFE	; 254
    219a:	3f 4f       	sbci	r19, 0xFF	; 255
    219c:	b9 01       	movw	r22, r18
    219e:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    21a2:	eb 81       	ldd	r30, Y+3	; 0x03
    21a4:	fc 81       	ldd	r31, Y+4	; 0x04
    21a6:	96 89       	ldd	r25, Z+22	; 0x16
    21a8:	e0 91 1c 03 	lds	r30, 0x031C
    21ac:	f0 91 1d 03 	lds	r31, 0x031D
    21b0:	86 89       	ldd	r24, Z+22	; 0x16
    21b2:	98 17       	cp	r25, r24
    21b4:	10 f0       	brcs	.+4      	; 0x21ba <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    21b6:	81 e0       	ldi	r24, 0x01	; 1
    21b8:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    21ba:	80 91 6d 03 	lds	r24, 0x036D
    21be:	88 23       	and	r24, r24
    21c0:	09 f0       	breq	.+2      	; 0x21c4 <xTaskResumeAll+0xc2>
    21c2:	ba cf       	rjmp	.-140    	; 0x2138 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    21c4:	80 91 26 03 	lds	r24, 0x0326
    21c8:	88 23       	and	r24, r24
    21ca:	71 f0       	breq	.+28     	; 0x21e8 <xTaskResumeAll+0xe6>
    21cc:	07 c0       	rjmp	.+14     	; 0x21dc <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    21ce:	0e 94 40 11 	call	0x2280	; 0x2280 <vTaskIncrementTick>
						--uxMissedTicks;
    21d2:	80 91 26 03 	lds	r24, 0x0326
    21d6:	81 50       	subi	r24, 0x01	; 1
    21d8:	80 93 26 03 	sts	0x0326, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    21dc:	80 91 26 03 	lds	r24, 0x0326
    21e0:	88 23       	and	r24, r24
    21e2:	a9 f7       	brne	.-22     	; 0x21ce <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    21e4:	81 e0       	ldi	r24, 0x01	; 1
    21e6:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    21e8:	89 81       	ldd	r24, Y+1	; 0x01
    21ea:	81 30       	cpi	r24, 0x01	; 1
    21ec:	21 f0       	breq	.+8      	; 0x21f6 <xTaskResumeAll+0xf4>
    21ee:	80 91 27 03 	lds	r24, 0x0327
    21f2:	81 30       	cpi	r24, 0x01	; 1
    21f4:	31 f4       	brne	.+12     	; 0x2202 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    21f6:	81 e0       	ldi	r24, 0x01	; 1
    21f8:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    21fa:	10 92 27 03 	sts	0x0327, r1
					portYIELD_WITHIN_API();
    21fe:	0e 94 c6 07 	call	0xf8c	; 0xf8c <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2202:	0f 90       	pop	r0
    2204:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2206:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2208:	0f 90       	pop	r0
    220a:	0f 90       	pop	r0
    220c:	0f 90       	pop	r0
    220e:	0f 90       	pop	r0
    2210:	cf 91       	pop	r28
    2212:	df 91       	pop	r29
    2214:	08 95       	ret

00002216 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    2216:	df 93       	push	r29
    2218:	cf 93       	push	r28
    221a:	00 d0       	rcall	.+0      	; 0x221c <xTaskGetTickCount+0x6>
    221c:	cd b7       	in	r28, 0x3d	; 61
    221e:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2220:	0f b6       	in	r0, 0x3f	; 63
    2222:	f8 94       	cli
    2224:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2226:	80 91 20 03 	lds	r24, 0x0320
    222a:	90 91 21 03 	lds	r25, 0x0321
    222e:	9a 83       	std	Y+2, r25	; 0x02
    2230:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2232:	0f 90       	pop	r0
    2234:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2236:	89 81       	ldd	r24, Y+1	; 0x01
    2238:	9a 81       	ldd	r25, Y+2	; 0x02
}
    223a:	0f 90       	pop	r0
    223c:	0f 90       	pop	r0
    223e:	cf 91       	pop	r28
    2240:	df 91       	pop	r29
    2242:	08 95       	ret

00002244 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    2244:	df 93       	push	r29
    2246:	cf 93       	push	r28
    2248:	00 d0       	rcall	.+0      	; 0x224a <xTaskGetTickCountFromISR+0x6>
    224a:	0f 92       	push	r0
    224c:	cd b7       	in	r28, 0x3d	; 61
    224e:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2250:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    2252:	80 91 20 03 	lds	r24, 0x0320
    2256:	90 91 21 03 	lds	r25, 0x0321
    225a:	9b 83       	std	Y+3, r25	; 0x03
    225c:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    225e:	8a 81       	ldd	r24, Y+2	; 0x02
    2260:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2262:	0f 90       	pop	r0
    2264:	0f 90       	pop	r0
    2266:	0f 90       	pop	r0
    2268:	cf 91       	pop	r28
    226a:	df 91       	pop	r29
    226c:	08 95       	ret

0000226e <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    226e:	df 93       	push	r29
    2270:	cf 93       	push	r28
    2272:	cd b7       	in	r28, 0x3d	; 61
    2274:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2276:	80 91 1f 03 	lds	r24, 0x031F
}
    227a:	cf 91       	pop	r28
    227c:	df 91       	pop	r29
    227e:	08 95       	ret

00002280 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2280:	df 93       	push	r29
    2282:	cf 93       	push	r28
    2284:	00 d0       	rcall	.+0      	; 0x2286 <vTaskIncrementTick+0x6>
    2286:	00 d0       	rcall	.+0      	; 0x2288 <vTaskIncrementTick+0x8>
    2288:	00 d0       	rcall	.+0      	; 0x228a <vTaskIncrementTick+0xa>
    228a:	cd b7       	in	r28, 0x3d	; 61
    228c:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    228e:	80 91 25 03 	lds	r24, 0x0325
    2292:	88 23       	and	r24, r24
    2294:	09 f0       	breq	.+2      	; 0x2298 <vTaskIncrementTick+0x18>
    2296:	bb c0       	rjmp	.+374    	; 0x240e <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    2298:	80 91 20 03 	lds	r24, 0x0320
    229c:	90 91 21 03 	lds	r25, 0x0321
    22a0:	01 96       	adiw	r24, 0x01	; 1
    22a2:	90 93 21 03 	sts	0x0321, r25
    22a6:	80 93 20 03 	sts	0x0320, r24
		if( xTickCount == ( portTickType ) 0U )
    22aa:	80 91 20 03 	lds	r24, 0x0320
    22ae:	90 91 21 03 	lds	r25, 0x0321
    22b2:	00 97       	sbiw	r24, 0x00	; 0
    22b4:	d1 f5       	brne	.+116    	; 0x232a <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    22b6:	80 91 69 03 	lds	r24, 0x0369
    22ba:	90 91 6a 03 	lds	r25, 0x036A
    22be:	9c 83       	std	Y+4, r25	; 0x04
    22c0:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    22c2:	80 91 6b 03 	lds	r24, 0x036B
    22c6:	90 91 6c 03 	lds	r25, 0x036C
    22ca:	90 93 6a 03 	sts	0x036A, r25
    22ce:	80 93 69 03 	sts	0x0369, r24
			pxOverflowDelayedTaskList = pxTemp;
    22d2:	8b 81       	ldd	r24, Y+3	; 0x03
    22d4:	9c 81       	ldd	r25, Y+4	; 0x04
    22d6:	90 93 6c 03 	sts	0x036C, r25
    22da:	80 93 6b 03 	sts	0x036B, r24
			xNumOfOverflows++;
    22de:	80 91 28 03 	lds	r24, 0x0328
    22e2:	8f 5f       	subi	r24, 0xFF	; 255
    22e4:	80 93 28 03 	sts	0x0328, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    22e8:	e0 91 69 03 	lds	r30, 0x0369
    22ec:	f0 91 6a 03 	lds	r31, 0x036A
    22f0:	80 81       	ld	r24, Z
    22f2:	88 23       	and	r24, r24
    22f4:	39 f4       	brne	.+14     	; 0x2304 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    22f6:	8f ef       	ldi	r24, 0xFF	; 255
    22f8:	9f ef       	ldi	r25, 0xFF	; 255
    22fa:	90 93 7f 00 	sts	0x007F, r25
    22fe:	80 93 7e 00 	sts	0x007E, r24
    2302:	13 c0       	rjmp	.+38     	; 0x232a <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2304:	e0 91 69 03 	lds	r30, 0x0369
    2308:	f0 91 6a 03 	lds	r31, 0x036A
    230c:	05 80       	ldd	r0, Z+5	; 0x05
    230e:	f6 81       	ldd	r31, Z+6	; 0x06
    2310:	e0 2d       	mov	r30, r0
    2312:	86 81       	ldd	r24, Z+6	; 0x06
    2314:	97 81       	ldd	r25, Z+7	; 0x07
    2316:	9e 83       	std	Y+6, r25	; 0x06
    2318:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    231a:	ed 81       	ldd	r30, Y+5	; 0x05
    231c:	fe 81       	ldd	r31, Y+6	; 0x06
    231e:	82 81       	ldd	r24, Z+2	; 0x02
    2320:	93 81       	ldd	r25, Z+3	; 0x03
    2322:	90 93 7f 00 	sts	0x007F, r25
    2326:	80 93 7e 00 	sts	0x007E, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    232a:	20 91 20 03 	lds	r18, 0x0320
    232e:	30 91 21 03 	lds	r19, 0x0321
    2332:	80 91 7e 00 	lds	r24, 0x007E
    2336:	90 91 7f 00 	lds	r25, 0x007F
    233a:	28 17       	cp	r18, r24
    233c:	39 07       	cpc	r19, r25
    233e:	08 f4       	brcc	.+2      	; 0x2342 <vTaskIncrementTick+0xc2>
    2340:	6b c0       	rjmp	.+214    	; 0x2418 <vTaskIncrementTick+0x198>
    2342:	e0 91 69 03 	lds	r30, 0x0369
    2346:	f0 91 6a 03 	lds	r31, 0x036A
    234a:	80 81       	ld	r24, Z
    234c:	88 23       	and	r24, r24
    234e:	39 f4       	brne	.+14     	; 0x235e <vTaskIncrementTick+0xde>
    2350:	8f ef       	ldi	r24, 0xFF	; 255
    2352:	9f ef       	ldi	r25, 0xFF	; 255
    2354:	90 93 7f 00 	sts	0x007F, r25
    2358:	80 93 7e 00 	sts	0x007E, r24
    235c:	5d c0       	rjmp	.+186    	; 0x2418 <vTaskIncrementTick+0x198>
    235e:	e0 91 69 03 	lds	r30, 0x0369
    2362:	f0 91 6a 03 	lds	r31, 0x036A
    2366:	05 80       	ldd	r0, Z+5	; 0x05
    2368:	f6 81       	ldd	r31, Z+6	; 0x06
    236a:	e0 2d       	mov	r30, r0
    236c:	86 81       	ldd	r24, Z+6	; 0x06
    236e:	97 81       	ldd	r25, Z+7	; 0x07
    2370:	9e 83       	std	Y+6, r25	; 0x06
    2372:	8d 83       	std	Y+5, r24	; 0x05
    2374:	ed 81       	ldd	r30, Y+5	; 0x05
    2376:	fe 81       	ldd	r31, Y+6	; 0x06
    2378:	82 81       	ldd	r24, Z+2	; 0x02
    237a:	93 81       	ldd	r25, Z+3	; 0x03
    237c:	9a 83       	std	Y+2, r25	; 0x02
    237e:	89 83       	std	Y+1, r24	; 0x01
    2380:	20 91 20 03 	lds	r18, 0x0320
    2384:	30 91 21 03 	lds	r19, 0x0321
    2388:	89 81       	ldd	r24, Y+1	; 0x01
    238a:	9a 81       	ldd	r25, Y+2	; 0x02
    238c:	28 17       	cp	r18, r24
    238e:	39 07       	cpc	r19, r25
    2390:	38 f4       	brcc	.+14     	; 0x23a0 <vTaskIncrementTick+0x120>
    2392:	89 81       	ldd	r24, Y+1	; 0x01
    2394:	9a 81       	ldd	r25, Y+2	; 0x02
    2396:	90 93 7f 00 	sts	0x007F, r25
    239a:	80 93 7e 00 	sts	0x007E, r24
    239e:	3c c0       	rjmp	.+120    	; 0x2418 <vTaskIncrementTick+0x198>
    23a0:	8d 81       	ldd	r24, Y+5	; 0x05
    23a2:	9e 81       	ldd	r25, Y+6	; 0x06
    23a4:	02 96       	adiw	r24, 0x02	; 2
    23a6:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>
    23aa:	ed 81       	ldd	r30, Y+5	; 0x05
    23ac:	fe 81       	ldd	r31, Y+6	; 0x06
    23ae:	84 89       	ldd	r24, Z+20	; 0x14
    23b0:	95 89       	ldd	r25, Z+21	; 0x15
    23b2:	00 97       	sbiw	r24, 0x00	; 0
    23b4:	29 f0       	breq	.+10     	; 0x23c0 <vTaskIncrementTick+0x140>
    23b6:	8d 81       	ldd	r24, Y+5	; 0x05
    23b8:	9e 81       	ldd	r25, Y+6	; 0x06
    23ba:	0c 96       	adiw	r24, 0x0c	; 12
    23bc:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>
    23c0:	ed 81       	ldd	r30, Y+5	; 0x05
    23c2:	fe 81       	ldd	r31, Y+6	; 0x06
    23c4:	96 89       	ldd	r25, Z+22	; 0x16
    23c6:	80 91 23 03 	lds	r24, 0x0323
    23ca:	89 17       	cp	r24, r25
    23cc:	28 f4       	brcc	.+10     	; 0x23d8 <vTaskIncrementTick+0x158>
    23ce:	ed 81       	ldd	r30, Y+5	; 0x05
    23d0:	fe 81       	ldd	r31, Y+6	; 0x06
    23d2:	86 89       	ldd	r24, Z+22	; 0x16
    23d4:	80 93 23 03 	sts	0x0323, r24
    23d8:	ed 81       	ldd	r30, Y+5	; 0x05
    23da:	fe 81       	ldd	r31, Y+6	; 0x06
    23dc:	86 89       	ldd	r24, Z+22	; 0x16
    23de:	28 2f       	mov	r18, r24
    23e0:	30 e0       	ldi	r19, 0x00	; 0
    23e2:	c9 01       	movw	r24, r18
    23e4:	88 0f       	add	r24, r24
    23e6:	99 1f       	adc	r25, r25
    23e8:	88 0f       	add	r24, r24
    23ea:	99 1f       	adc	r25, r25
    23ec:	88 0f       	add	r24, r24
    23ee:	99 1f       	adc	r25, r25
    23f0:	82 0f       	add	r24, r18
    23f2:	93 1f       	adc	r25, r19
    23f4:	ac 01       	movw	r20, r24
    23f6:	46 5d       	subi	r20, 0xD6	; 214
    23f8:	5c 4f       	sbci	r21, 0xFC	; 252
    23fa:	8d 81       	ldd	r24, Y+5	; 0x05
    23fc:	9e 81       	ldd	r25, Y+6	; 0x06
    23fe:	9c 01       	movw	r18, r24
    2400:	2e 5f       	subi	r18, 0xFE	; 254
    2402:	3f 4f       	sbci	r19, 0xFF	; 255
    2404:	ca 01       	movw	r24, r20
    2406:	b9 01       	movw	r22, r18
    2408:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListInsertEnd>
    240c:	9a cf       	rjmp	.-204    	; 0x2342 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    240e:	80 91 26 03 	lds	r24, 0x0326
    2412:	8f 5f       	subi	r24, 0xFF	; 255
    2414:	80 93 26 03 	sts	0x0326, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2418:	26 96       	adiw	r28, 0x06	; 6
    241a:	0f b6       	in	r0, 0x3f	; 63
    241c:	f8 94       	cli
    241e:	de bf       	out	0x3e, r29	; 62
    2420:	0f be       	out	0x3f, r0	; 63
    2422:	cd bf       	out	0x3d, r28	; 61
    2424:	cf 91       	pop	r28
    2426:	df 91       	pop	r29
    2428:	08 95       	ret

0000242a <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    242a:	df 93       	push	r29
    242c:	cf 93       	push	r28
    242e:	00 d0       	rcall	.+0      	; 0x2430 <vTaskSwitchContext+0x6>
    2430:	cd b7       	in	r28, 0x3d	; 61
    2432:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2434:	80 91 25 03 	lds	r24, 0x0325
    2438:	88 23       	and	r24, r24
    243a:	49 f0       	breq	.+18     	; 0x244e <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    243c:	81 e0       	ldi	r24, 0x01	; 1
    243e:	80 93 27 03 	sts	0x0327, r24
    2442:	54 c0       	rjmp	.+168    	; 0x24ec <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2444:	80 91 23 03 	lds	r24, 0x0323
    2448:	81 50       	subi	r24, 0x01	; 1
    244a:	80 93 23 03 	sts	0x0323, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    244e:	80 91 23 03 	lds	r24, 0x0323
    2452:	28 2f       	mov	r18, r24
    2454:	30 e0       	ldi	r19, 0x00	; 0
    2456:	c9 01       	movw	r24, r18
    2458:	88 0f       	add	r24, r24
    245a:	99 1f       	adc	r25, r25
    245c:	88 0f       	add	r24, r24
    245e:	99 1f       	adc	r25, r25
    2460:	88 0f       	add	r24, r24
    2462:	99 1f       	adc	r25, r25
    2464:	82 0f       	add	r24, r18
    2466:	93 1f       	adc	r25, r19
    2468:	fc 01       	movw	r30, r24
    246a:	e6 5d       	subi	r30, 0xD6	; 214
    246c:	fc 4f       	sbci	r31, 0xFC	; 252
    246e:	80 81       	ld	r24, Z
    2470:	88 23       	and	r24, r24
    2472:	41 f3       	breq	.-48     	; 0x2444 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2474:	80 91 23 03 	lds	r24, 0x0323
    2478:	28 2f       	mov	r18, r24
    247a:	30 e0       	ldi	r19, 0x00	; 0
    247c:	c9 01       	movw	r24, r18
    247e:	88 0f       	add	r24, r24
    2480:	99 1f       	adc	r25, r25
    2482:	88 0f       	add	r24, r24
    2484:	99 1f       	adc	r25, r25
    2486:	88 0f       	add	r24, r24
    2488:	99 1f       	adc	r25, r25
    248a:	82 0f       	add	r24, r18
    248c:	93 1f       	adc	r25, r19
    248e:	86 5d       	subi	r24, 0xD6	; 214
    2490:	9c 4f       	sbci	r25, 0xFC	; 252
    2492:	9a 83       	std	Y+2, r25	; 0x02
    2494:	89 83       	std	Y+1, r24	; 0x01
    2496:	e9 81       	ldd	r30, Y+1	; 0x01
    2498:	fa 81       	ldd	r31, Y+2	; 0x02
    249a:	01 80       	ldd	r0, Z+1	; 0x01
    249c:	f2 81       	ldd	r31, Z+2	; 0x02
    249e:	e0 2d       	mov	r30, r0
    24a0:	82 81       	ldd	r24, Z+2	; 0x02
    24a2:	93 81       	ldd	r25, Z+3	; 0x03
    24a4:	e9 81       	ldd	r30, Y+1	; 0x01
    24a6:	fa 81       	ldd	r31, Y+2	; 0x02
    24a8:	92 83       	std	Z+2, r25	; 0x02
    24aa:	81 83       	std	Z+1, r24	; 0x01
    24ac:	e9 81       	ldd	r30, Y+1	; 0x01
    24ae:	fa 81       	ldd	r31, Y+2	; 0x02
    24b0:	21 81       	ldd	r18, Z+1	; 0x01
    24b2:	32 81       	ldd	r19, Z+2	; 0x02
    24b4:	89 81       	ldd	r24, Y+1	; 0x01
    24b6:	9a 81       	ldd	r25, Y+2	; 0x02
    24b8:	03 96       	adiw	r24, 0x03	; 3
    24ba:	28 17       	cp	r18, r24
    24bc:	39 07       	cpc	r19, r25
    24be:	59 f4       	brne	.+22     	; 0x24d6 <vTaskSwitchContext+0xac>
    24c0:	e9 81       	ldd	r30, Y+1	; 0x01
    24c2:	fa 81       	ldd	r31, Y+2	; 0x02
    24c4:	01 80       	ldd	r0, Z+1	; 0x01
    24c6:	f2 81       	ldd	r31, Z+2	; 0x02
    24c8:	e0 2d       	mov	r30, r0
    24ca:	82 81       	ldd	r24, Z+2	; 0x02
    24cc:	93 81       	ldd	r25, Z+3	; 0x03
    24ce:	e9 81       	ldd	r30, Y+1	; 0x01
    24d0:	fa 81       	ldd	r31, Y+2	; 0x02
    24d2:	92 83       	std	Z+2, r25	; 0x02
    24d4:	81 83       	std	Z+1, r24	; 0x01
    24d6:	e9 81       	ldd	r30, Y+1	; 0x01
    24d8:	fa 81       	ldd	r31, Y+2	; 0x02
    24da:	01 80       	ldd	r0, Z+1	; 0x01
    24dc:	f2 81       	ldd	r31, Z+2	; 0x02
    24de:	e0 2d       	mov	r30, r0
    24e0:	86 81       	ldd	r24, Z+6	; 0x06
    24e2:	97 81       	ldd	r25, Z+7	; 0x07
    24e4:	90 93 1d 03 	sts	0x031D, r25
    24e8:	80 93 1c 03 	sts	0x031C, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    24ec:	0f 90       	pop	r0
    24ee:	0f 90       	pop	r0
    24f0:	cf 91       	pop	r28
    24f2:	df 91       	pop	r29
    24f4:	08 95       	ret

000024f6 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    24f6:	df 93       	push	r29
    24f8:	cf 93       	push	r28
    24fa:	00 d0       	rcall	.+0      	; 0x24fc <vTaskPlaceOnEventList+0x6>
    24fc:	00 d0       	rcall	.+0      	; 0x24fe <vTaskPlaceOnEventList+0x8>
    24fe:	00 d0       	rcall	.+0      	; 0x2500 <vTaskPlaceOnEventList+0xa>
    2500:	cd b7       	in	r28, 0x3d	; 61
    2502:	de b7       	in	r29, 0x3e	; 62
    2504:	9c 83       	std	Y+4, r25	; 0x04
    2506:	8b 83       	std	Y+3, r24	; 0x03
    2508:	7e 83       	std	Y+6, r23	; 0x06
    250a:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    250c:	4b 81       	ldd	r20, Y+3	; 0x03
    250e:	5c 81       	ldd	r21, Y+4	; 0x04
    2510:	80 91 1c 03 	lds	r24, 0x031C
    2514:	90 91 1d 03 	lds	r25, 0x031D
    2518:	9c 01       	movw	r18, r24
    251a:	24 5f       	subi	r18, 0xF4	; 244
    251c:	3f 4f       	sbci	r19, 0xFF	; 255
    251e:	ca 01       	movw	r24, r20
    2520:	b9 01       	movw	r22, r18
    2522:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2526:	80 91 1c 03 	lds	r24, 0x031C
    252a:	90 91 1d 03 	lds	r25, 0x031D
    252e:	02 96       	adiw	r24, 0x02	; 2
    2530:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2534:	20 91 20 03 	lds	r18, 0x0320
    2538:	30 91 21 03 	lds	r19, 0x0321
    253c:	8d 81       	ldd	r24, Y+5	; 0x05
    253e:	9e 81       	ldd	r25, Y+6	; 0x06
    2540:	82 0f       	add	r24, r18
    2542:	93 1f       	adc	r25, r19
    2544:	9a 83       	std	Y+2, r25	; 0x02
    2546:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2548:	89 81       	ldd	r24, Y+1	; 0x01
    254a:	9a 81       	ldd	r25, Y+2	; 0x02
    254c:	0e 94 75 14 	call	0x28ea	; 0x28ea <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2550:	26 96       	adiw	r28, 0x06	; 6
    2552:	0f b6       	in	r0, 0x3f	; 63
    2554:	f8 94       	cli
    2556:	de bf       	out	0x3e, r29	; 62
    2558:	0f be       	out	0x3f, r0	; 63
    255a:	cd bf       	out	0x3d, r28	; 61
    255c:	cf 91       	pop	r28
    255e:	df 91       	pop	r29
    2560:	08 95       	ret

00002562 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2562:	df 93       	push	r29
    2564:	cf 93       	push	r28
    2566:	00 d0       	rcall	.+0      	; 0x2568 <xTaskRemoveFromEventList+0x6>
    2568:	00 d0       	rcall	.+0      	; 0x256a <xTaskRemoveFromEventList+0x8>
    256a:	0f 92       	push	r0
    256c:	cd b7       	in	r28, 0x3d	; 61
    256e:	de b7       	in	r29, 0x3e	; 62
    2570:	9d 83       	std	Y+5, r25	; 0x05
    2572:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2574:	ec 81       	ldd	r30, Y+4	; 0x04
    2576:	fd 81       	ldd	r31, Y+5	; 0x05
    2578:	05 80       	ldd	r0, Z+5	; 0x05
    257a:	f6 81       	ldd	r31, Z+6	; 0x06
    257c:	e0 2d       	mov	r30, r0
    257e:	86 81       	ldd	r24, Z+6	; 0x06
    2580:	97 81       	ldd	r25, Z+7	; 0x07
    2582:	9b 83       	std	Y+3, r25	; 0x03
    2584:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2586:	8a 81       	ldd	r24, Y+2	; 0x02
    2588:	9b 81       	ldd	r25, Y+3	; 0x03
    258a:	0c 96       	adiw	r24, 0x0c	; 12
    258c:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2590:	80 91 25 03 	lds	r24, 0x0325
    2594:	88 23       	and	r24, r24
    2596:	61 f5       	brne	.+88     	; 0x25f0 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2598:	8a 81       	ldd	r24, Y+2	; 0x02
    259a:	9b 81       	ldd	r25, Y+3	; 0x03
    259c:	02 96       	adiw	r24, 0x02	; 2
    259e:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    25a2:	ea 81       	ldd	r30, Y+2	; 0x02
    25a4:	fb 81       	ldd	r31, Y+3	; 0x03
    25a6:	96 89       	ldd	r25, Z+22	; 0x16
    25a8:	80 91 23 03 	lds	r24, 0x0323
    25ac:	89 17       	cp	r24, r25
    25ae:	28 f4       	brcc	.+10     	; 0x25ba <xTaskRemoveFromEventList+0x58>
    25b0:	ea 81       	ldd	r30, Y+2	; 0x02
    25b2:	fb 81       	ldd	r31, Y+3	; 0x03
    25b4:	86 89       	ldd	r24, Z+22	; 0x16
    25b6:	80 93 23 03 	sts	0x0323, r24
    25ba:	ea 81       	ldd	r30, Y+2	; 0x02
    25bc:	fb 81       	ldd	r31, Y+3	; 0x03
    25be:	86 89       	ldd	r24, Z+22	; 0x16
    25c0:	28 2f       	mov	r18, r24
    25c2:	30 e0       	ldi	r19, 0x00	; 0
    25c4:	c9 01       	movw	r24, r18
    25c6:	88 0f       	add	r24, r24
    25c8:	99 1f       	adc	r25, r25
    25ca:	88 0f       	add	r24, r24
    25cc:	99 1f       	adc	r25, r25
    25ce:	88 0f       	add	r24, r24
    25d0:	99 1f       	adc	r25, r25
    25d2:	82 0f       	add	r24, r18
    25d4:	93 1f       	adc	r25, r19
    25d6:	ac 01       	movw	r20, r24
    25d8:	46 5d       	subi	r20, 0xD6	; 214
    25da:	5c 4f       	sbci	r21, 0xFC	; 252
    25dc:	8a 81       	ldd	r24, Y+2	; 0x02
    25de:	9b 81       	ldd	r25, Y+3	; 0x03
    25e0:	9c 01       	movw	r18, r24
    25e2:	2e 5f       	subi	r18, 0xFE	; 254
    25e4:	3f 4f       	sbci	r19, 0xFF	; 255
    25e6:	ca 01       	movw	r24, r20
    25e8:	b9 01       	movw	r22, r18
    25ea:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListInsertEnd>
    25ee:	0a c0       	rjmp	.+20     	; 0x2604 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    25f0:	8a 81       	ldd	r24, Y+2	; 0x02
    25f2:	9b 81       	ldd	r25, Y+3	; 0x03
    25f4:	9c 01       	movw	r18, r24
    25f6:	24 5f       	subi	r18, 0xF4	; 244
    25f8:	3f 4f       	sbci	r19, 0xFF	; 255
    25fa:	8d e6       	ldi	r24, 0x6D	; 109
    25fc:	93 e0       	ldi	r25, 0x03	; 3
    25fe:	b9 01       	movw	r22, r18
    2600:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2604:	ea 81       	ldd	r30, Y+2	; 0x02
    2606:	fb 81       	ldd	r31, Y+3	; 0x03
    2608:	96 89       	ldd	r25, Z+22	; 0x16
    260a:	e0 91 1c 03 	lds	r30, 0x031C
    260e:	f0 91 1d 03 	lds	r31, 0x031D
    2612:	86 89       	ldd	r24, Z+22	; 0x16
    2614:	98 17       	cp	r25, r24
    2616:	18 f0       	brcs	.+6      	; 0x261e <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2618:	81 e0       	ldi	r24, 0x01	; 1
    261a:	89 83       	std	Y+1, r24	; 0x01
    261c:	01 c0       	rjmp	.+2      	; 0x2620 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    261e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2620:	89 81       	ldd	r24, Y+1	; 0x01
}
    2622:	0f 90       	pop	r0
    2624:	0f 90       	pop	r0
    2626:	0f 90       	pop	r0
    2628:	0f 90       	pop	r0
    262a:	0f 90       	pop	r0
    262c:	cf 91       	pop	r28
    262e:	df 91       	pop	r29
    2630:	08 95       	ret

00002632 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2632:	df 93       	push	r29
    2634:	cf 93       	push	r28
    2636:	00 d0       	rcall	.+0      	; 0x2638 <vTaskSetTimeOutState+0x6>
    2638:	cd b7       	in	r28, 0x3d	; 61
    263a:	de b7       	in	r29, 0x3e	; 62
    263c:	9a 83       	std	Y+2, r25	; 0x02
    263e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2640:	80 91 28 03 	lds	r24, 0x0328
    2644:	e9 81       	ldd	r30, Y+1	; 0x01
    2646:	fa 81       	ldd	r31, Y+2	; 0x02
    2648:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    264a:	80 91 20 03 	lds	r24, 0x0320
    264e:	90 91 21 03 	lds	r25, 0x0321
    2652:	e9 81       	ldd	r30, Y+1	; 0x01
    2654:	fa 81       	ldd	r31, Y+2	; 0x02
    2656:	92 83       	std	Z+2, r25	; 0x02
    2658:	81 83       	std	Z+1, r24	; 0x01
}
    265a:	0f 90       	pop	r0
    265c:	0f 90       	pop	r0
    265e:	cf 91       	pop	r28
    2660:	df 91       	pop	r29
    2662:	08 95       	ret

00002664 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2664:	df 93       	push	r29
    2666:	cf 93       	push	r28
    2668:	00 d0       	rcall	.+0      	; 0x266a <xTaskCheckForTimeOut+0x6>
    266a:	00 d0       	rcall	.+0      	; 0x266c <xTaskCheckForTimeOut+0x8>
    266c:	0f 92       	push	r0
    266e:	cd b7       	in	r28, 0x3d	; 61
    2670:	de b7       	in	r29, 0x3e	; 62
    2672:	9b 83       	std	Y+3, r25	; 0x03
    2674:	8a 83       	std	Y+2, r24	; 0x02
    2676:	7d 83       	std	Y+5, r23	; 0x05
    2678:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    267a:	0f b6       	in	r0, 0x3f	; 63
    267c:	f8 94       	cli
    267e:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2680:	ea 81       	ldd	r30, Y+2	; 0x02
    2682:	fb 81       	ldd	r31, Y+3	; 0x03
    2684:	90 81       	ld	r25, Z
    2686:	80 91 28 03 	lds	r24, 0x0328
    268a:	98 17       	cp	r25, r24
    268c:	71 f0       	breq	.+28     	; 0x26aa <xTaskCheckForTimeOut+0x46>
    268e:	ea 81       	ldd	r30, Y+2	; 0x02
    2690:	fb 81       	ldd	r31, Y+3	; 0x03
    2692:	21 81       	ldd	r18, Z+1	; 0x01
    2694:	32 81       	ldd	r19, Z+2	; 0x02
    2696:	80 91 20 03 	lds	r24, 0x0320
    269a:	90 91 21 03 	lds	r25, 0x0321
    269e:	82 17       	cp	r24, r18
    26a0:	93 07       	cpc	r25, r19
    26a2:	18 f0       	brcs	.+6      	; 0x26aa <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    26a4:	81 e0       	ldi	r24, 0x01	; 1
    26a6:	89 83       	std	Y+1, r24	; 0x01
    26a8:	2f c0       	rjmp	.+94     	; 0x2708 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    26aa:	20 91 20 03 	lds	r18, 0x0320
    26ae:	30 91 21 03 	lds	r19, 0x0321
    26b2:	ea 81       	ldd	r30, Y+2	; 0x02
    26b4:	fb 81       	ldd	r31, Y+3	; 0x03
    26b6:	81 81       	ldd	r24, Z+1	; 0x01
    26b8:	92 81       	ldd	r25, Z+2	; 0x02
    26ba:	28 1b       	sub	r18, r24
    26bc:	39 0b       	sbc	r19, r25
    26be:	ec 81       	ldd	r30, Y+4	; 0x04
    26c0:	fd 81       	ldd	r31, Y+5	; 0x05
    26c2:	80 81       	ld	r24, Z
    26c4:	91 81       	ldd	r25, Z+1	; 0x01
    26c6:	28 17       	cp	r18, r24
    26c8:	39 07       	cpc	r19, r25
    26ca:	e0 f4       	brcc	.+56     	; 0x2704 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    26cc:	ec 81       	ldd	r30, Y+4	; 0x04
    26ce:	fd 81       	ldd	r31, Y+5	; 0x05
    26d0:	40 81       	ld	r20, Z
    26d2:	51 81       	ldd	r21, Z+1	; 0x01
    26d4:	ea 81       	ldd	r30, Y+2	; 0x02
    26d6:	fb 81       	ldd	r31, Y+3	; 0x03
    26d8:	21 81       	ldd	r18, Z+1	; 0x01
    26da:	32 81       	ldd	r19, Z+2	; 0x02
    26dc:	80 91 20 03 	lds	r24, 0x0320
    26e0:	90 91 21 03 	lds	r25, 0x0321
    26e4:	b9 01       	movw	r22, r18
    26e6:	68 1b       	sub	r22, r24
    26e8:	79 0b       	sbc	r23, r25
    26ea:	cb 01       	movw	r24, r22
    26ec:	84 0f       	add	r24, r20
    26ee:	95 1f       	adc	r25, r21
    26f0:	ec 81       	ldd	r30, Y+4	; 0x04
    26f2:	fd 81       	ldd	r31, Y+5	; 0x05
    26f4:	91 83       	std	Z+1, r25	; 0x01
    26f6:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    26f8:	8a 81       	ldd	r24, Y+2	; 0x02
    26fa:	9b 81       	ldd	r25, Y+3	; 0x03
    26fc:	0e 94 19 13 	call	0x2632	; 0x2632 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2700:	19 82       	std	Y+1, r1	; 0x01
    2702:	02 c0       	rjmp	.+4      	; 0x2708 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    2704:	81 e0       	ldi	r24, 0x01	; 1
    2706:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2708:	0f 90       	pop	r0
    270a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    270c:	89 81       	ldd	r24, Y+1	; 0x01
}
    270e:	0f 90       	pop	r0
    2710:	0f 90       	pop	r0
    2712:	0f 90       	pop	r0
    2714:	0f 90       	pop	r0
    2716:	0f 90       	pop	r0
    2718:	cf 91       	pop	r28
    271a:	df 91       	pop	r29
    271c:	08 95       	ret

0000271e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    271e:	df 93       	push	r29
    2720:	cf 93       	push	r28
    2722:	cd b7       	in	r28, 0x3d	; 61
    2724:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    2726:	81 e0       	ldi	r24, 0x01	; 1
    2728:	80 93 27 03 	sts	0x0327, r24
}
    272c:	cf 91       	pop	r28
    272e:	df 91       	pop	r29
    2730:	08 95       	ret

00002732 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2732:	df 93       	push	r29
    2734:	cf 93       	push	r28
    2736:	00 d0       	rcall	.+0      	; 0x2738 <prvIdleTask+0x6>
    2738:	cd b7       	in	r28, 0x3d	; 61
    273a:	de b7       	in	r29, 0x3e	; 62
    273c:	9a 83       	std	Y+2, r25	; 0x02
    273e:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    2740:	0e 94 37 14 	call	0x286e	; 0x286e <prvCheckTasksWaitingTermination>
    2744:	fd cf       	rjmp	.-6      	; 0x2740 <prvIdleTask+0xe>

00002746 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    2746:	0f 93       	push	r16
    2748:	1f 93       	push	r17
    274a:	df 93       	push	r29
    274c:	cf 93       	push	r28
    274e:	cd b7       	in	r28, 0x3d	; 61
    2750:	de b7       	in	r29, 0x3e	; 62
    2752:	29 97       	sbiw	r28, 0x09	; 9
    2754:	0f b6       	in	r0, 0x3f	; 63
    2756:	f8 94       	cli
    2758:	de bf       	out	0x3e, r29	; 62
    275a:	0f be       	out	0x3f, r0	; 63
    275c:	cd bf       	out	0x3d, r28	; 61
    275e:	9a 83       	std	Y+2, r25	; 0x02
    2760:	89 83       	std	Y+1, r24	; 0x01
    2762:	7c 83       	std	Y+4, r23	; 0x04
    2764:	6b 83       	std	Y+3, r22	; 0x03
    2766:	4d 83       	std	Y+5, r20	; 0x05
    2768:	3f 83       	std	Y+7, r19	; 0x07
    276a:	2e 83       	std	Y+6, r18	; 0x06
    276c:	19 87       	std	Y+9, r17	; 0x09
    276e:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2770:	89 81       	ldd	r24, Y+1	; 0x01
    2772:	9a 81       	ldd	r25, Y+2	; 0x02
    2774:	49 96       	adiw	r24, 0x19	; 25
    2776:	2b 81       	ldd	r18, Y+3	; 0x03
    2778:	3c 81       	ldd	r19, Y+4	; 0x04
    277a:	b9 01       	movw	r22, r18
    277c:	48 e0       	ldi	r20, 0x08	; 8
    277e:	50 e0       	ldi	r21, 0x00	; 0
    2780:	0e 94 34 15 	call	0x2a68	; 0x2a68 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    2784:	e9 81       	ldd	r30, Y+1	; 0x01
    2786:	fa 81       	ldd	r31, Y+2	; 0x02
    2788:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    278a:	8d 81       	ldd	r24, Y+5	; 0x05
    278c:	85 30       	cpi	r24, 0x05	; 5
    278e:	10 f0       	brcs	.+4      	; 0x2794 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2790:	84 e0       	ldi	r24, 0x04	; 4
    2792:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    2794:	e9 81       	ldd	r30, Y+1	; 0x01
    2796:	fa 81       	ldd	r31, Y+2	; 0x02
    2798:	8d 81       	ldd	r24, Y+5	; 0x05
    279a:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    279c:	89 81       	ldd	r24, Y+1	; 0x01
    279e:	9a 81       	ldd	r25, Y+2	; 0x02
    27a0:	02 96       	adiw	r24, 0x02	; 2
    27a2:	0e 94 f6 04 	call	0x9ec	; 0x9ec <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    27a6:	89 81       	ldd	r24, Y+1	; 0x01
    27a8:	9a 81       	ldd	r25, Y+2	; 0x02
    27aa:	0c 96       	adiw	r24, 0x0c	; 12
    27ac:	0e 94 f6 04 	call	0x9ec	; 0x9ec <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    27b0:	e9 81       	ldd	r30, Y+1	; 0x01
    27b2:	fa 81       	ldd	r31, Y+2	; 0x02
    27b4:	89 81       	ldd	r24, Y+1	; 0x01
    27b6:	9a 81       	ldd	r25, Y+2	; 0x02
    27b8:	91 87       	std	Z+9, r25	; 0x09
    27ba:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    27bc:	8d 81       	ldd	r24, Y+5	; 0x05
    27be:	28 2f       	mov	r18, r24
    27c0:	30 e0       	ldi	r19, 0x00	; 0
    27c2:	85 e0       	ldi	r24, 0x05	; 5
    27c4:	90 e0       	ldi	r25, 0x00	; 0
    27c6:	82 1b       	sub	r24, r18
    27c8:	93 0b       	sbc	r25, r19
    27ca:	e9 81       	ldd	r30, Y+1	; 0x01
    27cc:	fa 81       	ldd	r31, Y+2	; 0x02
    27ce:	95 87       	std	Z+13, r25	; 0x0d
    27d0:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    27d2:	e9 81       	ldd	r30, Y+1	; 0x01
    27d4:	fa 81       	ldd	r31, Y+2	; 0x02
    27d6:	89 81       	ldd	r24, Y+1	; 0x01
    27d8:	9a 81       	ldd	r25, Y+2	; 0x02
    27da:	93 8b       	std	Z+19, r25	; 0x13
    27dc:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    27de:	29 96       	adiw	r28, 0x09	; 9
    27e0:	0f b6       	in	r0, 0x3f	; 63
    27e2:	f8 94       	cli
    27e4:	de bf       	out	0x3e, r29	; 62
    27e6:	0f be       	out	0x3f, r0	; 63
    27e8:	cd bf       	out	0x3d, r28	; 61
    27ea:	cf 91       	pop	r28
    27ec:	df 91       	pop	r29
    27ee:	1f 91       	pop	r17
    27f0:	0f 91       	pop	r16
    27f2:	08 95       	ret

000027f4 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    27f4:	df 93       	push	r29
    27f6:	cf 93       	push	r28
    27f8:	0f 92       	push	r0
    27fa:	cd b7       	in	r28, 0x3d	; 61
    27fc:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    27fe:	19 82       	std	Y+1, r1	; 0x01
    2800:	13 c0       	rjmp	.+38     	; 0x2828 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2802:	89 81       	ldd	r24, Y+1	; 0x01
    2804:	28 2f       	mov	r18, r24
    2806:	30 e0       	ldi	r19, 0x00	; 0
    2808:	c9 01       	movw	r24, r18
    280a:	88 0f       	add	r24, r24
    280c:	99 1f       	adc	r25, r25
    280e:	88 0f       	add	r24, r24
    2810:	99 1f       	adc	r25, r25
    2812:	88 0f       	add	r24, r24
    2814:	99 1f       	adc	r25, r25
    2816:	82 0f       	add	r24, r18
    2818:	93 1f       	adc	r25, r19
    281a:	86 5d       	subi	r24, 0xD6	; 214
    281c:	9c 4f       	sbci	r25, 0xFC	; 252
    281e:	0e 94 cc 04 	call	0x998	; 0x998 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2822:	89 81       	ldd	r24, Y+1	; 0x01
    2824:	8f 5f       	subi	r24, 0xFF	; 255
    2826:	89 83       	std	Y+1, r24	; 0x01
    2828:	89 81       	ldd	r24, Y+1	; 0x01
    282a:	85 30       	cpi	r24, 0x05	; 5
    282c:	50 f3       	brcs	.-44     	; 0x2802 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    282e:	87 e5       	ldi	r24, 0x57	; 87
    2830:	93 e0       	ldi	r25, 0x03	; 3
    2832:	0e 94 cc 04 	call	0x998	; 0x998 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2836:	80 e6       	ldi	r24, 0x60	; 96
    2838:	93 e0       	ldi	r25, 0x03	; 3
    283a:	0e 94 cc 04 	call	0x998	; 0x998 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    283e:	8d e6       	ldi	r24, 0x6D	; 109
    2840:	93 e0       	ldi	r25, 0x03	; 3
    2842:	0e 94 cc 04 	call	0x998	; 0x998 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2846:	86 e7       	ldi	r24, 0x76	; 118
    2848:	93 e0       	ldi	r25, 0x03	; 3
    284a:	0e 94 cc 04 	call	0x998	; 0x998 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    284e:	87 e5       	ldi	r24, 0x57	; 87
    2850:	93 e0       	ldi	r25, 0x03	; 3
    2852:	90 93 6a 03 	sts	0x036A, r25
    2856:	80 93 69 03 	sts	0x0369, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    285a:	80 e6       	ldi	r24, 0x60	; 96
    285c:	93 e0       	ldi	r25, 0x03	; 3
    285e:	90 93 6c 03 	sts	0x036C, r25
    2862:	80 93 6b 03 	sts	0x036B, r24
}
    2866:	0f 90       	pop	r0
    2868:	cf 91       	pop	r28
    286a:	df 91       	pop	r29
    286c:	08 95       	ret

0000286e <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    286e:	df 93       	push	r29
    2870:	cf 93       	push	r28
    2872:	00 d0       	rcall	.+0      	; 0x2874 <prvCheckTasksWaitingTermination+0x6>
    2874:	0f 92       	push	r0
    2876:	cd b7       	in	r28, 0x3d	; 61
    2878:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    287a:	80 91 1e 03 	lds	r24, 0x031E
    287e:	88 23       	and	r24, r24
    2880:	71 f1       	breq	.+92     	; 0x28de <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    2882:	0e 94 75 10 	call	0x20ea	; 0x20ea <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2886:	80 91 76 03 	lds	r24, 0x0376
    288a:	1b 82       	std	Y+3, r1	; 0x03
    288c:	88 23       	and	r24, r24
    288e:	11 f4       	brne	.+4      	; 0x2894 <prvCheckTasksWaitingTermination+0x26>
    2890:	81 e0       	ldi	r24, 0x01	; 1
    2892:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    2894:	0e 94 81 10 	call	0x2102	; 0x2102 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2898:	8b 81       	ldd	r24, Y+3	; 0x03
    289a:	88 23       	and	r24, r24
    289c:	01 f5       	brne	.+64     	; 0x28de <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    289e:	0f b6       	in	r0, 0x3f	; 63
    28a0:	f8 94       	cli
    28a2:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    28a4:	e0 91 7b 03 	lds	r30, 0x037B
    28a8:	f0 91 7c 03 	lds	r31, 0x037C
    28ac:	86 81       	ldd	r24, Z+6	; 0x06
    28ae:	97 81       	ldd	r25, Z+7	; 0x07
    28b0:	9a 83       	std	Y+2, r25	; 0x02
    28b2:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    28b4:	89 81       	ldd	r24, Y+1	; 0x01
    28b6:	9a 81       	ldd	r25, Y+2	; 0x02
    28b8:	02 96       	adiw	r24, 0x02	; 2
    28ba:	0e 94 be 05 	call	0xb7c	; 0xb7c <vListRemove>
					--uxCurrentNumberOfTasks;
    28be:	80 91 1f 03 	lds	r24, 0x031F
    28c2:	81 50       	subi	r24, 0x01	; 1
    28c4:	80 93 1f 03 	sts	0x031F, r24
					--uxTasksDeleted;
    28c8:	80 91 1e 03 	lds	r24, 0x031E
    28cc:	81 50       	subi	r24, 0x01	; 1
    28ce:	80 93 1e 03 	sts	0x031E, r24
				}
				taskEXIT_CRITICAL();
    28d2:	0f 90       	pop	r0
    28d4:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    28d6:	89 81       	ldd	r24, Y+1	; 0x01
    28d8:	9a 81       	ldd	r25, Y+2	; 0x02
    28da:	0e 94 0e 15 	call	0x2a1c	; 0x2a1c <prvDeleteTCB>
			}
		}
	}
	#endif
}
    28de:	0f 90       	pop	r0
    28e0:	0f 90       	pop	r0
    28e2:	0f 90       	pop	r0
    28e4:	cf 91       	pop	r28
    28e6:	df 91       	pop	r29
    28e8:	08 95       	ret

000028ea <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    28ea:	df 93       	push	r29
    28ec:	cf 93       	push	r28
    28ee:	00 d0       	rcall	.+0      	; 0x28f0 <prvAddCurrentTaskToDelayedList+0x6>
    28f0:	cd b7       	in	r28, 0x3d	; 61
    28f2:	de b7       	in	r29, 0x3e	; 62
    28f4:	9a 83       	std	Y+2, r25	; 0x02
    28f6:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    28f8:	e0 91 1c 03 	lds	r30, 0x031C
    28fc:	f0 91 1d 03 	lds	r31, 0x031D
    2900:	89 81       	ldd	r24, Y+1	; 0x01
    2902:	9a 81       	ldd	r25, Y+2	; 0x02
    2904:	93 83       	std	Z+3, r25	; 0x03
    2906:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    2908:	20 91 20 03 	lds	r18, 0x0320
    290c:	30 91 21 03 	lds	r19, 0x0321
    2910:	89 81       	ldd	r24, Y+1	; 0x01
    2912:	9a 81       	ldd	r25, Y+2	; 0x02
    2914:	82 17       	cp	r24, r18
    2916:	93 07       	cpc	r25, r19
    2918:	70 f4       	brcc	.+28     	; 0x2936 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    291a:	80 91 6b 03 	lds	r24, 0x036B
    291e:	90 91 6c 03 	lds	r25, 0x036C
    2922:	20 91 1c 03 	lds	r18, 0x031C
    2926:	30 91 1d 03 	lds	r19, 0x031D
    292a:	2e 5f       	subi	r18, 0xFE	; 254
    292c:	3f 4f       	sbci	r19, 0xFF	; 255
    292e:	b9 01       	movw	r22, r18
    2930:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vListInsert>
    2934:	1e c0       	rjmp	.+60     	; 0x2972 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2936:	40 91 69 03 	lds	r20, 0x0369
    293a:	50 91 6a 03 	lds	r21, 0x036A
    293e:	80 91 1c 03 	lds	r24, 0x031C
    2942:	90 91 1d 03 	lds	r25, 0x031D
    2946:	9c 01       	movw	r18, r24
    2948:	2e 5f       	subi	r18, 0xFE	; 254
    294a:	3f 4f       	sbci	r19, 0xFF	; 255
    294c:	ca 01       	movw	r24, r20
    294e:	b9 01       	movw	r22, r18
    2950:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    2954:	20 91 7e 00 	lds	r18, 0x007E
    2958:	30 91 7f 00 	lds	r19, 0x007F
    295c:	89 81       	ldd	r24, Y+1	; 0x01
    295e:	9a 81       	ldd	r25, Y+2	; 0x02
    2960:	82 17       	cp	r24, r18
    2962:	93 07       	cpc	r25, r19
    2964:	30 f4       	brcc	.+12     	; 0x2972 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    2966:	89 81       	ldd	r24, Y+1	; 0x01
    2968:	9a 81       	ldd	r25, Y+2	; 0x02
    296a:	90 93 7f 00 	sts	0x007F, r25
    296e:	80 93 7e 00 	sts	0x007E, r24
		}
	}
}
    2972:	0f 90       	pop	r0
    2974:	0f 90       	pop	r0
    2976:	cf 91       	pop	r28
    2978:	df 91       	pop	r29
    297a:	08 95       	ret

0000297c <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    297c:	df 93       	push	r29
    297e:	cf 93       	push	r28
    2980:	cd b7       	in	r28, 0x3d	; 61
    2982:	de b7       	in	r29, 0x3e	; 62
    2984:	28 97       	sbiw	r28, 0x08	; 8
    2986:	0f b6       	in	r0, 0x3f	; 63
    2988:	f8 94       	cli
    298a:	de bf       	out	0x3e, r29	; 62
    298c:	0f be       	out	0x3f, r0	; 63
    298e:	cd bf       	out	0x3d, r28	; 61
    2990:	9c 83       	std	Y+4, r25	; 0x04
    2992:	8b 83       	std	Y+3, r24	; 0x03
    2994:	7e 83       	std	Y+6, r23	; 0x06
    2996:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2998:	81 e2       	ldi	r24, 0x21	; 33
    299a:	90 e0       	ldi	r25, 0x00	; 0
    299c:	0e 94 60 04 	call	0x8c0	; 0x8c0 <pvPortMalloc>
    29a0:	9a 83       	std	Y+2, r25	; 0x02
    29a2:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    29a4:	89 81       	ldd	r24, Y+1	; 0x01
    29a6:	9a 81       	ldd	r25, Y+2	; 0x02
    29a8:	00 97       	sbiw	r24, 0x00	; 0
    29aa:	69 f1       	breq	.+90     	; 0x2a06 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    29ac:	8d 81       	ldd	r24, Y+5	; 0x05
    29ae:	9e 81       	ldd	r25, Y+6	; 0x06
    29b0:	00 97       	sbiw	r24, 0x00	; 0
    29b2:	39 f4       	brne	.+14     	; 0x29c2 <prvAllocateTCBAndStack+0x46>
    29b4:	8b 81       	ldd	r24, Y+3	; 0x03
    29b6:	9c 81       	ldd	r25, Y+4	; 0x04
    29b8:	0e 94 60 04 	call	0x8c0	; 0x8c0 <pvPortMalloc>
    29bc:	98 87       	std	Y+8, r25	; 0x08
    29be:	8f 83       	std	Y+7, r24	; 0x07
    29c0:	04 c0       	rjmp	.+8      	; 0x29ca <prvAllocateTCBAndStack+0x4e>
    29c2:	8d 81       	ldd	r24, Y+5	; 0x05
    29c4:	9e 81       	ldd	r25, Y+6	; 0x06
    29c6:	98 87       	std	Y+8, r25	; 0x08
    29c8:	8f 83       	std	Y+7, r24	; 0x07
    29ca:	e9 81       	ldd	r30, Y+1	; 0x01
    29cc:	fa 81       	ldd	r31, Y+2	; 0x02
    29ce:	8f 81       	ldd	r24, Y+7	; 0x07
    29d0:	98 85       	ldd	r25, Y+8	; 0x08
    29d2:	90 8f       	std	Z+24, r25	; 0x18
    29d4:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    29d6:	e9 81       	ldd	r30, Y+1	; 0x01
    29d8:	fa 81       	ldd	r31, Y+2	; 0x02
    29da:	87 89       	ldd	r24, Z+23	; 0x17
    29dc:	90 8d       	ldd	r25, Z+24	; 0x18
    29de:	00 97       	sbiw	r24, 0x00	; 0
    29e0:	39 f4       	brne	.+14     	; 0x29f0 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    29e2:	89 81       	ldd	r24, Y+1	; 0x01
    29e4:	9a 81       	ldd	r25, Y+2	; 0x02
    29e6:	0e 94 a6 04 	call	0x94c	; 0x94c <vPortFree>
			pxNewTCB = NULL;
    29ea:	1a 82       	std	Y+2, r1	; 0x02
    29ec:	19 82       	std	Y+1, r1	; 0x01
    29ee:	0b c0       	rjmp	.+22     	; 0x2a06 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    29f0:	e9 81       	ldd	r30, Y+1	; 0x01
    29f2:	fa 81       	ldd	r31, Y+2	; 0x02
    29f4:	87 89       	ldd	r24, Z+23	; 0x17
    29f6:	90 8d       	ldd	r25, Z+24	; 0x18
    29f8:	2b 81       	ldd	r18, Y+3	; 0x03
    29fa:	3c 81       	ldd	r19, Y+4	; 0x04
    29fc:	65 ea       	ldi	r22, 0xA5	; 165
    29fe:	70 e0       	ldi	r23, 0x00	; 0
    2a00:	a9 01       	movw	r20, r18
    2a02:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <memset>
		}
	}

	return pxNewTCB;
    2a06:	89 81       	ldd	r24, Y+1	; 0x01
    2a08:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2a0a:	28 96       	adiw	r28, 0x08	; 8
    2a0c:	0f b6       	in	r0, 0x3f	; 63
    2a0e:	f8 94       	cli
    2a10:	de bf       	out	0x3e, r29	; 62
    2a12:	0f be       	out	0x3f, r0	; 63
    2a14:	cd bf       	out	0x3d, r28	; 61
    2a16:	cf 91       	pop	r28
    2a18:	df 91       	pop	r29
    2a1a:	08 95       	ret

00002a1c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    2a1c:	df 93       	push	r29
    2a1e:	cf 93       	push	r28
    2a20:	00 d0       	rcall	.+0      	; 0x2a22 <prvDeleteTCB+0x6>
    2a22:	cd b7       	in	r28, 0x3d	; 61
    2a24:	de b7       	in	r29, 0x3e	; 62
    2a26:	9a 83       	std	Y+2, r25	; 0x02
    2a28:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2a2a:	e9 81       	ldd	r30, Y+1	; 0x01
    2a2c:	fa 81       	ldd	r31, Y+2	; 0x02
    2a2e:	87 89       	ldd	r24, Z+23	; 0x17
    2a30:	90 8d       	ldd	r25, Z+24	; 0x18
    2a32:	0e 94 a6 04 	call	0x94c	; 0x94c <vPortFree>
		vPortFree( pxTCB );
    2a36:	89 81       	ldd	r24, Y+1	; 0x01
    2a38:	9a 81       	ldd	r25, Y+2	; 0x02
    2a3a:	0e 94 a6 04 	call	0x94c	; 0x94c <vPortFree>
	}
    2a3e:	0f 90       	pop	r0
    2a40:	0f 90       	pop	r0
    2a42:	cf 91       	pop	r28
    2a44:	df 91       	pop	r29
    2a46:	08 95       	ret

00002a48 <memcpy>:
    2a48:	fb 01       	movw	r30, r22
    2a4a:	dc 01       	movw	r26, r24
    2a4c:	02 c0       	rjmp	.+4      	; 0x2a52 <memcpy+0xa>
    2a4e:	01 90       	ld	r0, Z+
    2a50:	0d 92       	st	X+, r0
    2a52:	41 50       	subi	r20, 0x01	; 1
    2a54:	50 40       	sbci	r21, 0x00	; 0
    2a56:	d8 f7       	brcc	.-10     	; 0x2a4e <memcpy+0x6>
    2a58:	08 95       	ret

00002a5a <memset>:
    2a5a:	dc 01       	movw	r26, r24
    2a5c:	01 c0       	rjmp	.+2      	; 0x2a60 <memset+0x6>
    2a5e:	6d 93       	st	X+, r22
    2a60:	41 50       	subi	r20, 0x01	; 1
    2a62:	50 40       	sbci	r21, 0x00	; 0
    2a64:	e0 f7       	brcc	.-8      	; 0x2a5e <memset+0x4>
    2a66:	08 95       	ret

00002a68 <strncpy>:
    2a68:	fb 01       	movw	r30, r22
    2a6a:	dc 01       	movw	r26, r24
    2a6c:	41 50       	subi	r20, 0x01	; 1
    2a6e:	50 40       	sbci	r21, 0x00	; 0
    2a70:	48 f0       	brcs	.+18     	; 0x2a84 <strncpy+0x1c>
    2a72:	01 90       	ld	r0, Z+
    2a74:	0d 92       	st	X+, r0
    2a76:	00 20       	and	r0, r0
    2a78:	c9 f7       	brne	.-14     	; 0x2a6c <strncpy+0x4>
    2a7a:	01 c0       	rjmp	.+2      	; 0x2a7e <strncpy+0x16>
    2a7c:	1d 92       	st	X+, r1
    2a7e:	41 50       	subi	r20, 0x01	; 1
    2a80:	50 40       	sbci	r21, 0x00	; 0
    2a82:	e0 f7       	brcc	.-8      	; 0x2a7c <strncpy+0x14>
    2a84:	08 95       	ret

00002a86 <_exit>:
    2a86:	f8 94       	cli

00002a88 <__stop_program>:
    2a88:	ff cf       	rjmp	.-2      	; 0x2a88 <__stop_program>
