
RTOS_Task12_Syncronization.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000029b0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001a  00800060  000029b0  00002a44  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002fd  0080007a  0080007a  00002a5e  2**0
                  ALLOC
  3 .stab         000047ac  00000000  00000000  00002a60  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002bbf  00000000  00000000  0000720c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 69 08 	jmp	0x10d2	; 0x10d2 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 eb       	ldi	r30, 0xB0	; 176
      68:	f9 e2       	ldi	r31, 0x29	; 41
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	aa 37       	cpi	r26, 0x7A	; 122
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	aa e7       	ldi	r26, 0x7A	; 122
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a7 37       	cpi	r26, 0x77	; 119
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 49 00 	call	0x92	; 0x92 <main>
      8a:	0c 94 d6 14 	jmp	0x29ac	; 0x29ac <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <main>:
      92:	af 92       	push	r10
      94:	bf 92       	push	r11
      96:	cf 92       	push	r12
      98:	df 92       	push	r13
      9a:	ef 92       	push	r14
      9c:	ff 92       	push	r15
      9e:	0f 93       	push	r16
      a0:	df 93       	push	r29
      a2:	cf 93       	push	r28
      a4:	cd b7       	in	r28, 0x3d	; 61
      a6:	de b7       	in	r29, 0x3e	; 62
      a8:	20 e6       	ldi	r18, 0x60	; 96
      aa:	30 e0       	ldi	r19, 0x00	; 0
      ac:	80 ec       	ldi	r24, 0xC0	; 192
      ae:	90 e0       	ldi	r25, 0x00	; 0
      b0:	ee e7       	ldi	r30, 0x7E	; 126
      b2:	f0 e0       	ldi	r31, 0x00	; 0
      b4:	b9 01       	movw	r22, r18
      b6:	45 e5       	ldi	r20, 0x55	; 85
      b8:	50 e0       	ldi	r21, 0x00	; 0
      ba:	20 e0       	ldi	r18, 0x00	; 0
      bc:	30 e0       	ldi	r19, 0x00	; 0
      be:	02 e0       	ldi	r16, 0x02	; 2
      c0:	7f 01       	movw	r14, r30
      c2:	cc 24       	eor	r12, r12
      c4:	dd 24       	eor	r13, r13
      c6:	aa 24       	eor	r10, r10
      c8:	bb 24       	eor	r11, r11
      ca:	0e 94 ed 0c 	call	0x19da	; 0x19da <xTaskGenericCreate>
      ce:	2e e6       	ldi	r18, 0x6E	; 110
      d0:	30 e0       	ldi	r19, 0x00	; 0
      d2:	8d ee       	ldi	r24, 0xED	; 237
      d4:	90 e0       	ldi	r25, 0x00	; 0
      d6:	ec e7       	ldi	r30, 0x7C	; 124
      d8:	f0 e0       	ldi	r31, 0x00	; 0
      da:	b9 01       	movw	r22, r18
      dc:	45 e5       	ldi	r20, 0x55	; 85
      de:	50 e0       	ldi	r21, 0x00	; 0
      e0:	20 e0       	ldi	r18, 0x00	; 0
      e2:	30 e0       	ldi	r19, 0x00	; 0
      e4:	01 e0       	ldi	r16, 0x01	; 1
      e6:	7f 01       	movw	r14, r30
      e8:	cc 24       	eor	r12, r12
      ea:	dd 24       	eor	r13, r13
      ec:	aa 24       	eor	r10, r10
      ee:	bb 24       	eor	r11, r11
      f0:	0e 94 ed 0c 	call	0x19da	; 0x19da <xTaskGenericCreate>
      f4:	0e 94 ae 00 	call	0x15c	; 0x15c <init>
      f8:	81 e0       	ldi	r24, 0x01	; 1
      fa:	60 e0       	ldi	r22, 0x00	; 0
      fc:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <xQueueCreate>
     100:	90 93 7b 00 	sts	0x007B, r25
     104:	80 93 7a 00 	sts	0x007A, r24
     108:	80 91 7a 00 	lds	r24, 0x007A
     10c:	90 91 7b 00 	lds	r25, 0x007B
     110:	00 97       	sbiw	r24, 0x00	; 0
     112:	59 f0       	breq	.+22     	; 0x12a <main+0x98>
     114:	80 91 7a 00 	lds	r24, 0x007A
     118:	90 91 7b 00 	lds	r25, 0x007B
     11c:	60 e0       	ldi	r22, 0x00	; 0
     11e:	70 e0       	ldi	r23, 0x00	; 0
     120:	40 e0       	ldi	r20, 0x00	; 0
     122:	50 e0       	ldi	r21, 0x00	; 0
     124:	20 e0       	ldi	r18, 0x00	; 0
     126:	0e 94 15 09 	call	0x122a	; 0x122a <xQueueGenericSend>
     12a:	80 91 7a 00 	lds	r24, 0x007A
     12e:	90 91 7b 00 	lds	r25, 0x007B
     132:	60 e0       	ldi	r22, 0x00	; 0
     134:	70 e0       	ldi	r23, 0x00	; 0
     136:	44 e6       	ldi	r20, 0x64	; 100
     138:	50 e0       	ldi	r21, 0x00	; 0
     13a:	20 e0       	ldi	r18, 0x00	; 0
     13c:	0e 94 00 0a 	call	0x1400	; 0x1400 <xQueueGenericReceive>
     140:	0e 94 c5 0f 	call	0x1f8a	; 0x1f8a <vTaskStartScheduler>
     144:	80 e0       	ldi	r24, 0x00	; 0
     146:	90 e0       	ldi	r25, 0x00	; 0
     148:	cf 91       	pop	r28
     14a:	df 91       	pop	r29
     14c:	0f 91       	pop	r16
     14e:	ff 90       	pop	r15
     150:	ef 90       	pop	r14
     152:	df 90       	pop	r13
     154:	cf 90       	pop	r12
     156:	bf 90       	pop	r11
     158:	af 90       	pop	r10
     15a:	08 95       	ret

0000015c <init>:

	/*Never Enter Here */
	return 0;
}

void init(void){
     15c:	df 93       	push	r29
     15e:	cf 93       	push	r28
     160:	cd b7       	in	r28, 0x3d	; 61
     162:	de b7       	in	r29, 0x3e	; 62

	DDRB = 0xFF;
     164:	e7 e3       	ldi	r30, 0x37	; 55
     166:	f0 e0       	ldi	r31, 0x00	; 0
     168:	8f ef       	ldi	r24, 0xFF	; 255
     16a:	80 83       	st	Z, r24

	DDRC = 0x00;
     16c:	e4 e3       	ldi	r30, 0x34	; 52
     16e:	f0 e0       	ldi	r31, 0x00	; 0
     170:	10 82       	st	Z, r1

	PORTC = 0xFF;
     172:	e5 e3       	ldi	r30, 0x35	; 53
     174:	f0 e0       	ldi	r31, 0x00	; 0
     176:	8f ef       	ldi	r24, 0xFF	; 255
     178:	80 83       	st	Z, r24

}
     17a:	cf 91       	pop	r28
     17c:	df 91       	pop	r29
     17e:	08 95       	ret

00000180 <PushButton2>:



void PushButton2(void * pvparam){
     180:	df 93       	push	r29
     182:	cf 93       	push	r28
     184:	00 d0       	rcall	.+0      	; 0x186 <PushButton2+0x6>
     186:	00 d0       	rcall	.+0      	; 0x188 <PushButton2+0x8>
     188:	00 d0       	rcall	.+0      	; 0x18a <PushButton2+0xa>
     18a:	cd b7       	in	r28, 0x3d	; 61
     18c:	de b7       	in	r29, 0x3e	; 62
     18e:	9e 83       	std	Y+6, r25	; 0x06
     190:	8d 83       	std	Y+5, r24	; 0x05
	portTickType Freq = 150;
     192:	86 e9       	ldi	r24, 0x96	; 150
     194:	90 e0       	ldi	r25, 0x00	; 0
     196:	9a 83       	std	Y+2, r25	; 0x02
     198:	89 83       	std	Y+1, r24	; 0x01
	portTickType Start = xTaskGetTickCount();
     19a:	0e 94 9e 10 	call	0x213c	; 0x213c <xTaskGetTickCount>
     19e:	9c 83       	std	Y+4, r25	; 0x04
     1a0:	8b 83       	std	Y+3, r24	; 0x03
	while (1){

		if((PINC & 0x01) == 0){
     1a2:	e3 e3       	ldi	r30, 0x33	; 51
     1a4:	f0 e0       	ldi	r31, 0x00	; 0
     1a6:	80 81       	ld	r24, Z
     1a8:	88 2f       	mov	r24, r24
     1aa:	90 e0       	ldi	r25, 0x00	; 0
     1ac:	81 70       	andi	r24, 0x01	; 1
     1ae:	90 70       	andi	r25, 0x00	; 0
     1b0:	00 97       	sbiw	r24, 0x00	; 0
     1b2:	59 f4       	brne	.+22     	; 0x1ca <PushButton2+0x4a>
			xSemaphoreGive(ButtonSemaphore);
     1b4:	80 91 7a 00 	lds	r24, 0x007A
     1b8:	90 91 7b 00 	lds	r25, 0x007B
     1bc:	60 e0       	ldi	r22, 0x00	; 0
     1be:	70 e0       	ldi	r23, 0x00	; 0
     1c0:	40 e0       	ldi	r20, 0x00	; 0
     1c2:	50 e0       	ldi	r21, 0x00	; 0
     1c4:	20 e0       	ldi	r18, 0x00	; 0
     1c6:	0e 94 15 09 	call	0x122a	; 0x122a <xQueueGenericSend>
		}
		/*Make the Task Periodic with Period 50 Tick */
		vTaskDelayUntil(&Start,Freq);
     1ca:	ce 01       	movw	r24, r28
     1cc:	03 96       	adiw	r24, 0x03	; 3
     1ce:	29 81       	ldd	r18, Y+1	; 0x01
     1d0:	3a 81       	ldd	r19, Y+2	; 0x02
     1d2:	b9 01       	movw	r22, r18
     1d4:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <vTaskDelayUntil>
     1d8:	e4 cf       	rjmp	.-56     	; 0x1a2 <PushButton2+0x22>

000001da <Led>:

}



void Led(void * pvparam){
     1da:	df 93       	push	r29
     1dc:	cf 93       	push	r28
     1de:	00 d0       	rcall	.+0      	; 0x1e0 <Led+0x6>
     1e0:	00 d0       	rcall	.+0      	; 0x1e2 <Led+0x8>
     1e2:	00 d0       	rcall	.+0      	; 0x1e4 <Led+0xa>
     1e4:	cd b7       	in	r28, 0x3d	; 61
     1e6:	de b7       	in	r29, 0x3e	; 62
     1e8:	9e 83       	std	Y+6, r25	; 0x06
     1ea:	8d 83       	std	Y+5, r24	; 0x05
	portTickType Freq = 150;
     1ec:	86 e9       	ldi	r24, 0x96	; 150
     1ee:	90 e0       	ldi	r25, 0x00	; 0
     1f0:	9a 83       	std	Y+2, r25	; 0x02
     1f2:	89 83       	std	Y+1, r24	; 0x01
	portTickType Start = xTaskGetTickCount();
     1f4:	0e 94 9e 10 	call	0x213c	; 0x213c <xTaskGetTickCount>
     1f8:	9c 83       	std	Y+4, r25	; 0x04
     1fa:	8b 83       	std	Y+3, r24	; 0x03
	while (1){

		/* If the Resource No One is Using so Take the Semaphore  **/
		while(pdFALSE == xSemaphoreTake(ButtonSemaphore,100));
     1fc:	80 91 7a 00 	lds	r24, 0x007A
     200:	90 91 7b 00 	lds	r25, 0x007B
     204:	60 e0       	ldi	r22, 0x00	; 0
     206:	70 e0       	ldi	r23, 0x00	; 0
     208:	44 e6       	ldi	r20, 0x64	; 100
     20a:	50 e0       	ldi	r21, 0x00	; 0
     20c:	20 e0       	ldi	r18, 0x00	; 0
     20e:	0e 94 00 0a 	call	0x1400	; 0x1400 <xQueueGenericReceive>
     212:	88 23       	and	r24, r24
     214:	99 f3       	breq	.-26     	; 0x1fc <Led+0x22>
		PORTB ^= 0x01;
     216:	a8 e3       	ldi	r26, 0x38	; 56
     218:	b0 e0       	ldi	r27, 0x00	; 0
     21a:	e8 e3       	ldi	r30, 0x38	; 56
     21c:	f0 e0       	ldi	r31, 0x00	; 0
     21e:	90 81       	ld	r25, Z
     220:	81 e0       	ldi	r24, 0x01	; 1
     222:	89 27       	eor	r24, r25
     224:	8c 93       	st	X, r24
		/*Make the Task Periodic with Period 50 Tick */
		vTaskDelayUntil(&Start,Freq);
     226:	ce 01       	movw	r24, r28
     228:	03 96       	adiw	r24, 0x03	; 3
     22a:	29 81       	ldd	r18, Y+1	; 0x01
     22c:	3a 81       	ldd	r19, Y+2	; 0x02
     22e:	b9 01       	movw	r22, r18
     230:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <vTaskDelayUntil>
     234:	e3 cf       	rjmp	.-58     	; 0x1fc <Led+0x22>

00000236 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     236:	df 93       	push	r29
     238:	cf 93       	push	r28
     23a:	cd b7       	in	r28, 0x3d	; 61
     23c:	de b7       	in	r29, 0x3e	; 62
     23e:	27 97       	sbiw	r28, 0x07	; 7
     240:	0f b6       	in	r0, 0x3f	; 63
     242:	f8 94       	cli
     244:	de bf       	out	0x3e, r29	; 62
     246:	0f be       	out	0x3f, r0	; 63
     248:	cd bf       	out	0x3d, r28	; 61
     24a:	9d 83       	std	Y+5, r25	; 0x05
     24c:	8c 83       	std	Y+4, r24	; 0x04
     24e:	6e 83       	std	Y+6, r22	; 0x06
     250:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     252:	8a e1       	ldi	r24, 0x1A	; 26
     254:	90 e0       	ldi	r25, 0x00	; 0
     256:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <pvPortMalloc>
     25a:	9a 83       	std	Y+2, r25	; 0x02
     25c:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     25e:	89 81       	ldd	r24, Y+1	; 0x01
     260:	9a 81       	ldd	r25, Y+2	; 0x02
     262:	00 97       	sbiw	r24, 0x00	; 0
     264:	09 f4       	brne	.+2      	; 0x268 <xCoRoutineCreate+0x32>
     266:	6f c0       	rjmp	.+222    	; 0x346 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     268:	80 91 80 00 	lds	r24, 0x0080
     26c:	90 91 81 00 	lds	r25, 0x0081
     270:	00 97       	sbiw	r24, 0x00	; 0
     272:	41 f4       	brne	.+16     	; 0x284 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     274:	89 81       	ldd	r24, Y+1	; 0x01
     276:	9a 81       	ldd	r25, Y+2	; 0x02
     278:	90 93 81 00 	sts	0x0081, r25
     27c:	80 93 80 00 	sts	0x0080, r24
			prvInitialiseCoRoutineLists();
     280:	0e 94 82 03 	call	0x704	; 0x704 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     284:	8e 81       	ldd	r24, Y+6	; 0x06
     286:	82 30       	cpi	r24, 0x02	; 2
     288:	10 f0       	brcs	.+4      	; 0x28e <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     28a:	81 e0       	ldi	r24, 0x01	; 1
     28c:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     28e:	e9 81       	ldd	r30, Y+1	; 0x01
     290:	fa 81       	ldd	r31, Y+2	; 0x02
     292:	11 8e       	std	Z+25, r1	; 0x19
     294:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     296:	e9 81       	ldd	r30, Y+1	; 0x01
     298:	fa 81       	ldd	r31, Y+2	; 0x02
     29a:	8e 81       	ldd	r24, Y+6	; 0x06
     29c:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     29e:	e9 81       	ldd	r30, Y+1	; 0x01
     2a0:	fa 81       	ldd	r31, Y+2	; 0x02
     2a2:	8f 81       	ldd	r24, Y+7	; 0x07
     2a4:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     2a6:	e9 81       	ldd	r30, Y+1	; 0x01
     2a8:	fa 81       	ldd	r31, Y+2	; 0x02
     2aa:	8c 81       	ldd	r24, Y+4	; 0x04
     2ac:	9d 81       	ldd	r25, Y+5	; 0x05
     2ae:	91 83       	std	Z+1, r25	; 0x01
     2b0:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     2b2:	89 81       	ldd	r24, Y+1	; 0x01
     2b4:	9a 81       	ldd	r25, Y+2	; 0x02
     2b6:	02 96       	adiw	r24, 0x02	; 2
     2b8:	0e 94 89 04 	call	0x912	; 0x912 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     2bc:	89 81       	ldd	r24, Y+1	; 0x01
     2be:	9a 81       	ldd	r25, Y+2	; 0x02
     2c0:	0c 96       	adiw	r24, 0x0c	; 12
     2c2:	0e 94 89 04 	call	0x912	; 0x912 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     2c6:	e9 81       	ldd	r30, Y+1	; 0x01
     2c8:	fa 81       	ldd	r31, Y+2	; 0x02
     2ca:	89 81       	ldd	r24, Y+1	; 0x01
     2cc:	9a 81       	ldd	r25, Y+2	; 0x02
     2ce:	91 87       	std	Z+9, r25	; 0x09
     2d0:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     2d2:	e9 81       	ldd	r30, Y+1	; 0x01
     2d4:	fa 81       	ldd	r31, Y+2	; 0x02
     2d6:	89 81       	ldd	r24, Y+1	; 0x01
     2d8:	9a 81       	ldd	r25, Y+2	; 0x02
     2da:	93 8b       	std	Z+19, r25	; 0x13
     2dc:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     2de:	8e 81       	ldd	r24, Y+6	; 0x06
     2e0:	28 2f       	mov	r18, r24
     2e2:	30 e0       	ldi	r19, 0x00	; 0
     2e4:	85 e0       	ldi	r24, 0x05	; 5
     2e6:	90 e0       	ldi	r25, 0x00	; 0
     2e8:	82 1b       	sub	r24, r18
     2ea:	93 0b       	sbc	r25, r19
     2ec:	e9 81       	ldd	r30, Y+1	; 0x01
     2ee:	fa 81       	ldd	r31, Y+2	; 0x02
     2f0:	95 87       	std	Z+13, r25	; 0x0d
     2f2:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     2f4:	e9 81       	ldd	r30, Y+1	; 0x01
     2f6:	fa 81       	ldd	r31, Y+2	; 0x02
     2f8:	96 89       	ldd	r25, Z+22	; 0x16
     2fa:	80 91 82 00 	lds	r24, 0x0082
     2fe:	89 17       	cp	r24, r25
     300:	28 f4       	brcc	.+10     	; 0x30c <xCoRoutineCreate+0xd6>
     302:	e9 81       	ldd	r30, Y+1	; 0x01
     304:	fa 81       	ldd	r31, Y+2	; 0x02
     306:	86 89       	ldd	r24, Z+22	; 0x16
     308:	80 93 82 00 	sts	0x0082, r24
     30c:	e9 81       	ldd	r30, Y+1	; 0x01
     30e:	fa 81       	ldd	r31, Y+2	; 0x02
     310:	86 89       	ldd	r24, Z+22	; 0x16
     312:	28 2f       	mov	r18, r24
     314:	30 e0       	ldi	r19, 0x00	; 0
     316:	c9 01       	movw	r24, r18
     318:	88 0f       	add	r24, r24
     31a:	99 1f       	adc	r25, r25
     31c:	88 0f       	add	r24, r24
     31e:	99 1f       	adc	r25, r25
     320:	88 0f       	add	r24, r24
     322:	99 1f       	adc	r25, r25
     324:	82 0f       	add	r24, r18
     326:	93 1f       	adc	r25, r19
     328:	ac 01       	movw	r20, r24
     32a:	47 57       	subi	r20, 0x77	; 119
     32c:	5f 4f       	sbci	r21, 0xFF	; 255
     32e:	89 81       	ldd	r24, Y+1	; 0x01
     330:	9a 81       	ldd	r25, Y+2	; 0x02
     332:	9c 01       	movw	r18, r24
     334:	2e 5f       	subi	r18, 0xFE	; 254
     336:	3f 4f       	sbci	r19, 0xFF	; 255
     338:	ca 01       	movw	r24, r20
     33a:	b9 01       	movw	r22, r18
     33c:	0e 94 99 04 	call	0x932	; 0x932 <vListInsertEnd>

		xReturn = pdPASS;
     340:	81 e0       	ldi	r24, 0x01	; 1
     342:	8b 83       	std	Y+3, r24	; 0x03
     344:	02 c0       	rjmp	.+4      	; 0x34a <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     346:	8f ef       	ldi	r24, 0xFF	; 255
     348:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     34a:	8b 81       	ldd	r24, Y+3	; 0x03
}
     34c:	27 96       	adiw	r28, 0x07	; 7
     34e:	0f b6       	in	r0, 0x3f	; 63
     350:	f8 94       	cli
     352:	de bf       	out	0x3e, r29	; 62
     354:	0f be       	out	0x3f, r0	; 63
     356:	cd bf       	out	0x3d, r28	; 61
     358:	cf 91       	pop	r28
     35a:	df 91       	pop	r29
     35c:	08 95       	ret

0000035e <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     35e:	df 93       	push	r29
     360:	cf 93       	push	r28
     362:	00 d0       	rcall	.+0      	; 0x364 <vCoRoutineAddToDelayedList+0x6>
     364:	00 d0       	rcall	.+0      	; 0x366 <vCoRoutineAddToDelayedList+0x8>
     366:	00 d0       	rcall	.+0      	; 0x368 <vCoRoutineAddToDelayedList+0xa>
     368:	cd b7       	in	r28, 0x3d	; 61
     36a:	de b7       	in	r29, 0x3e	; 62
     36c:	9c 83       	std	Y+4, r25	; 0x04
     36e:	8b 83       	std	Y+3, r24	; 0x03
     370:	7e 83       	std	Y+6, r23	; 0x06
     372:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     374:	20 91 83 00 	lds	r18, 0x0083
     378:	30 91 84 00 	lds	r19, 0x0084
     37c:	8b 81       	ldd	r24, Y+3	; 0x03
     37e:	9c 81       	ldd	r25, Y+4	; 0x04
     380:	82 0f       	add	r24, r18
     382:	93 1f       	adc	r25, r19
     384:	9a 83       	std	Y+2, r25	; 0x02
     386:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     388:	80 91 80 00 	lds	r24, 0x0080
     38c:	90 91 81 00 	lds	r25, 0x0081
     390:	02 96       	adiw	r24, 0x02	; 2
     392:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     396:	e0 91 80 00 	lds	r30, 0x0080
     39a:	f0 91 81 00 	lds	r31, 0x0081
     39e:	89 81       	ldd	r24, Y+1	; 0x01
     3a0:	9a 81       	ldd	r25, Y+2	; 0x02
     3a2:	93 83       	std	Z+3, r25	; 0x03
     3a4:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     3a6:	20 91 83 00 	lds	r18, 0x0083
     3aa:	30 91 84 00 	lds	r19, 0x0084
     3ae:	89 81       	ldd	r24, Y+1	; 0x01
     3b0:	9a 81       	ldd	r25, Y+2	; 0x02
     3b2:	82 17       	cp	r24, r18
     3b4:	93 07       	cpc	r25, r19
     3b6:	70 f4       	brcc	.+28     	; 0x3d4 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     3b8:	80 91 af 00 	lds	r24, 0x00AF
     3bc:	90 91 b0 00 	lds	r25, 0x00B0
     3c0:	20 91 80 00 	lds	r18, 0x0080
     3c4:	30 91 81 00 	lds	r19, 0x0081
     3c8:	2e 5f       	subi	r18, 0xFE	; 254
     3ca:	3f 4f       	sbci	r19, 0xFF	; 255
     3cc:	b9 01       	movw	r22, r18
     3ce:	0e 94 e5 04 	call	0x9ca	; 0x9ca <vListInsert>
     3d2:	0d c0       	rjmp	.+26     	; 0x3ee <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     3d4:	80 91 ad 00 	lds	r24, 0x00AD
     3d8:	90 91 ae 00 	lds	r25, 0x00AE
     3dc:	20 91 80 00 	lds	r18, 0x0080
     3e0:	30 91 81 00 	lds	r19, 0x0081
     3e4:	2e 5f       	subi	r18, 0xFE	; 254
     3e6:	3f 4f       	sbci	r19, 0xFF	; 255
     3e8:	b9 01       	movw	r22, r18
     3ea:	0e 94 e5 04 	call	0x9ca	; 0x9ca <vListInsert>
	}

	if( pxEventList )
     3ee:	8d 81       	ldd	r24, Y+5	; 0x05
     3f0:	9e 81       	ldd	r25, Y+6	; 0x06
     3f2:	00 97       	sbiw	r24, 0x00	; 0
     3f4:	61 f0       	breq	.+24     	; 0x40e <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     3f6:	80 91 80 00 	lds	r24, 0x0080
     3fa:	90 91 81 00 	lds	r25, 0x0081
     3fe:	9c 01       	movw	r18, r24
     400:	24 5f       	subi	r18, 0xF4	; 244
     402:	3f 4f       	sbci	r19, 0xFF	; 255
     404:	8d 81       	ldd	r24, Y+5	; 0x05
     406:	9e 81       	ldd	r25, Y+6	; 0x06
     408:	b9 01       	movw	r22, r18
     40a:	0e 94 e5 04 	call	0x9ca	; 0x9ca <vListInsert>
	}
}
     40e:	26 96       	adiw	r28, 0x06	; 6
     410:	0f b6       	in	r0, 0x3f	; 63
     412:	f8 94       	cli
     414:	de bf       	out	0x3e, r29	; 62
     416:	0f be       	out	0x3f, r0	; 63
     418:	cd bf       	out	0x3d, r28	; 61
     41a:	cf 91       	pop	r28
     41c:	df 91       	pop	r29
     41e:	08 95       	ret

00000420 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     420:	df 93       	push	r29
     422:	cf 93       	push	r28
     424:	00 d0       	rcall	.+0      	; 0x426 <prvCheckPendingReadyList+0x6>
     426:	cd b7       	in	r28, 0x3d	; 61
     428:	de b7       	in	r29, 0x3e	; 62
     42a:	3a c0       	rjmp	.+116    	; 0x4a0 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     42c:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     42e:	e0 91 b6 00 	lds	r30, 0x00B6
     432:	f0 91 b7 00 	lds	r31, 0x00B7
     436:	86 81       	ldd	r24, Z+6	; 0x06
     438:	97 81       	ldd	r25, Z+7	; 0x07
     43a:	9a 83       	std	Y+2, r25	; 0x02
     43c:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     43e:	89 81       	ldd	r24, Y+1	; 0x01
     440:	9a 81       	ldd	r25, Y+2	; 0x02
     442:	0c 96       	adiw	r24, 0x0c	; 12
     444:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     448:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     44a:	89 81       	ldd	r24, Y+1	; 0x01
     44c:	9a 81       	ldd	r25, Y+2	; 0x02
     44e:	02 96       	adiw	r24, 0x02	; 2
     450:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     454:	e9 81       	ldd	r30, Y+1	; 0x01
     456:	fa 81       	ldd	r31, Y+2	; 0x02
     458:	96 89       	ldd	r25, Z+22	; 0x16
     45a:	80 91 82 00 	lds	r24, 0x0082
     45e:	89 17       	cp	r24, r25
     460:	28 f4       	brcc	.+10     	; 0x46c <prvCheckPendingReadyList+0x4c>
     462:	e9 81       	ldd	r30, Y+1	; 0x01
     464:	fa 81       	ldd	r31, Y+2	; 0x02
     466:	86 89       	ldd	r24, Z+22	; 0x16
     468:	80 93 82 00 	sts	0x0082, r24
     46c:	e9 81       	ldd	r30, Y+1	; 0x01
     46e:	fa 81       	ldd	r31, Y+2	; 0x02
     470:	86 89       	ldd	r24, Z+22	; 0x16
     472:	28 2f       	mov	r18, r24
     474:	30 e0       	ldi	r19, 0x00	; 0
     476:	c9 01       	movw	r24, r18
     478:	88 0f       	add	r24, r24
     47a:	99 1f       	adc	r25, r25
     47c:	88 0f       	add	r24, r24
     47e:	99 1f       	adc	r25, r25
     480:	88 0f       	add	r24, r24
     482:	99 1f       	adc	r25, r25
     484:	82 0f       	add	r24, r18
     486:	93 1f       	adc	r25, r19
     488:	ac 01       	movw	r20, r24
     48a:	47 57       	subi	r20, 0x77	; 119
     48c:	5f 4f       	sbci	r21, 0xFF	; 255
     48e:	89 81       	ldd	r24, Y+1	; 0x01
     490:	9a 81       	ldd	r25, Y+2	; 0x02
     492:	9c 01       	movw	r18, r24
     494:	2e 5f       	subi	r18, 0xFE	; 254
     496:	3f 4f       	sbci	r19, 0xFF	; 255
     498:	ca 01       	movw	r24, r20
     49a:	b9 01       	movw	r22, r18
     49c:	0e 94 99 04 	call	0x932	; 0x932 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     4a0:	80 91 b1 00 	lds	r24, 0x00B1
     4a4:	88 23       	and	r24, r24
     4a6:	09 f0       	breq	.+2      	; 0x4aa <prvCheckPendingReadyList+0x8a>
     4a8:	c1 cf       	rjmp	.-126    	; 0x42c <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     4aa:	0f 90       	pop	r0
     4ac:	0f 90       	pop	r0
     4ae:	cf 91       	pop	r28
     4b0:	df 91       	pop	r29
     4b2:	08 95       	ret

000004b4 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     4b4:	df 93       	push	r29
     4b6:	cf 93       	push	r28
     4b8:	00 d0       	rcall	.+0      	; 0x4ba <prvCheckDelayedList+0x6>
     4ba:	00 d0       	rcall	.+0      	; 0x4bc <prvCheckDelayedList+0x8>
     4bc:	cd b7       	in	r28, 0x3d	; 61
     4be:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     4c0:	0e 94 9e 10 	call	0x213c	; 0x213c <xTaskGetTickCount>
     4c4:	20 91 85 00 	lds	r18, 0x0085
     4c8:	30 91 86 00 	lds	r19, 0x0086
     4cc:	82 1b       	sub	r24, r18
     4ce:	93 0b       	sbc	r25, r19
     4d0:	90 93 88 00 	sts	0x0088, r25
     4d4:	80 93 87 00 	sts	0x0087, r24
     4d8:	85 c0       	rjmp	.+266    	; 0x5e4 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     4da:	80 91 83 00 	lds	r24, 0x0083
     4de:	90 91 84 00 	lds	r25, 0x0084
     4e2:	01 96       	adiw	r24, 0x01	; 1
     4e4:	90 93 84 00 	sts	0x0084, r25
     4e8:	80 93 83 00 	sts	0x0083, r24
		xPassedTicks--;
     4ec:	80 91 87 00 	lds	r24, 0x0087
     4f0:	90 91 88 00 	lds	r25, 0x0088
     4f4:	01 97       	sbiw	r24, 0x01	; 1
     4f6:	90 93 88 00 	sts	0x0088, r25
     4fa:	80 93 87 00 	sts	0x0087, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     4fe:	80 91 83 00 	lds	r24, 0x0083
     502:	90 91 84 00 	lds	r25, 0x0084
     506:	00 97       	sbiw	r24, 0x00	; 0
     508:	09 f0       	breq	.+2      	; 0x50c <prvCheckDelayedList+0x58>
     50a:	64 c0       	rjmp	.+200    	; 0x5d4 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     50c:	80 91 ad 00 	lds	r24, 0x00AD
     510:	90 91 ae 00 	lds	r25, 0x00AE
     514:	9a 83       	std	Y+2, r25	; 0x02
     516:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     518:	80 91 af 00 	lds	r24, 0x00AF
     51c:	90 91 b0 00 	lds	r25, 0x00B0
     520:	90 93 ae 00 	sts	0x00AE, r25
     524:	80 93 ad 00 	sts	0x00AD, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     528:	89 81       	ldd	r24, Y+1	; 0x01
     52a:	9a 81       	ldd	r25, Y+2	; 0x02
     52c:	90 93 b0 00 	sts	0x00B0, r25
     530:	80 93 af 00 	sts	0x00AF, r24
     534:	4f c0       	rjmp	.+158    	; 0x5d4 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     536:	e0 91 ad 00 	lds	r30, 0x00AD
     53a:	f0 91 ae 00 	lds	r31, 0x00AE
     53e:	05 80       	ldd	r0, Z+5	; 0x05
     540:	f6 81       	ldd	r31, Z+6	; 0x06
     542:	e0 2d       	mov	r30, r0
     544:	86 81       	ldd	r24, Z+6	; 0x06
     546:	97 81       	ldd	r25, Z+7	; 0x07
     548:	9c 83       	std	Y+4, r25	; 0x04
     54a:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     54c:	eb 81       	ldd	r30, Y+3	; 0x03
     54e:	fc 81       	ldd	r31, Y+4	; 0x04
     550:	22 81       	ldd	r18, Z+2	; 0x02
     552:	33 81       	ldd	r19, Z+3	; 0x03
     554:	80 91 83 00 	lds	r24, 0x0083
     558:	90 91 84 00 	lds	r25, 0x0084
     55c:	82 17       	cp	r24, r18
     55e:	93 07       	cpc	r25, r19
     560:	08 f4       	brcc	.+2      	; 0x564 <prvCheckDelayedList+0xb0>
     562:	40 c0       	rjmp	.+128    	; 0x5e4 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     564:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     566:	8b 81       	ldd	r24, Y+3	; 0x03
     568:	9c 81       	ldd	r25, Y+4	; 0x04
     56a:	02 96       	adiw	r24, 0x02	; 2
     56c:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     570:	eb 81       	ldd	r30, Y+3	; 0x03
     572:	fc 81       	ldd	r31, Y+4	; 0x04
     574:	84 89       	ldd	r24, Z+20	; 0x14
     576:	95 89       	ldd	r25, Z+21	; 0x15
     578:	00 97       	sbiw	r24, 0x00	; 0
     57a:	29 f0       	breq	.+10     	; 0x586 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     57c:	8b 81       	ldd	r24, Y+3	; 0x03
     57e:	9c 81       	ldd	r25, Y+4	; 0x04
     580:	0c 96       	adiw	r24, 0x0c	; 12
     582:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     586:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     588:	eb 81       	ldd	r30, Y+3	; 0x03
     58a:	fc 81       	ldd	r31, Y+4	; 0x04
     58c:	96 89       	ldd	r25, Z+22	; 0x16
     58e:	80 91 82 00 	lds	r24, 0x0082
     592:	89 17       	cp	r24, r25
     594:	28 f4       	brcc	.+10     	; 0x5a0 <prvCheckDelayedList+0xec>
     596:	eb 81       	ldd	r30, Y+3	; 0x03
     598:	fc 81       	ldd	r31, Y+4	; 0x04
     59a:	86 89       	ldd	r24, Z+22	; 0x16
     59c:	80 93 82 00 	sts	0x0082, r24
     5a0:	eb 81       	ldd	r30, Y+3	; 0x03
     5a2:	fc 81       	ldd	r31, Y+4	; 0x04
     5a4:	86 89       	ldd	r24, Z+22	; 0x16
     5a6:	28 2f       	mov	r18, r24
     5a8:	30 e0       	ldi	r19, 0x00	; 0
     5aa:	c9 01       	movw	r24, r18
     5ac:	88 0f       	add	r24, r24
     5ae:	99 1f       	adc	r25, r25
     5b0:	88 0f       	add	r24, r24
     5b2:	99 1f       	adc	r25, r25
     5b4:	88 0f       	add	r24, r24
     5b6:	99 1f       	adc	r25, r25
     5b8:	82 0f       	add	r24, r18
     5ba:	93 1f       	adc	r25, r19
     5bc:	ac 01       	movw	r20, r24
     5be:	47 57       	subi	r20, 0x77	; 119
     5c0:	5f 4f       	sbci	r21, 0xFF	; 255
     5c2:	8b 81       	ldd	r24, Y+3	; 0x03
     5c4:	9c 81       	ldd	r25, Y+4	; 0x04
     5c6:	9c 01       	movw	r18, r24
     5c8:	2e 5f       	subi	r18, 0xFE	; 254
     5ca:	3f 4f       	sbci	r19, 0xFF	; 255
     5cc:	ca 01       	movw	r24, r20
     5ce:	b9 01       	movw	r22, r18
     5d0:	0e 94 99 04 	call	0x932	; 0x932 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     5d4:	e0 91 ad 00 	lds	r30, 0x00AD
     5d8:	f0 91 ae 00 	lds	r31, 0x00AE
     5dc:	80 81       	ld	r24, Z
     5de:	88 23       	and	r24, r24
     5e0:	09 f0       	breq	.+2      	; 0x5e4 <prvCheckDelayedList+0x130>
     5e2:	a9 cf       	rjmp	.-174    	; 0x536 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     5e4:	80 91 87 00 	lds	r24, 0x0087
     5e8:	90 91 88 00 	lds	r25, 0x0088
     5ec:	00 97       	sbiw	r24, 0x00	; 0
     5ee:	09 f0       	breq	.+2      	; 0x5f2 <prvCheckDelayedList+0x13e>
     5f0:	74 cf       	rjmp	.-280    	; 0x4da <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     5f2:	80 91 83 00 	lds	r24, 0x0083
     5f6:	90 91 84 00 	lds	r25, 0x0084
     5fa:	90 93 86 00 	sts	0x0086, r25
     5fe:	80 93 85 00 	sts	0x0085, r24
}
     602:	0f 90       	pop	r0
     604:	0f 90       	pop	r0
     606:	0f 90       	pop	r0
     608:	0f 90       	pop	r0
     60a:	cf 91       	pop	r28
     60c:	df 91       	pop	r29
     60e:	08 95       	ret

00000610 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     610:	df 93       	push	r29
     612:	cf 93       	push	r28
     614:	00 d0       	rcall	.+0      	; 0x616 <vCoRoutineSchedule+0x6>
     616:	cd b7       	in	r28, 0x3d	; 61
     618:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     61a:	0e 94 10 02 	call	0x420	; 0x420 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     61e:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <prvCheckDelayedList>
     622:	0a c0       	rjmp	.+20     	; 0x638 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     624:	80 91 82 00 	lds	r24, 0x0082
     628:	88 23       	and	r24, r24
     62a:	09 f4       	brne	.+2      	; 0x62e <vCoRoutineSchedule+0x1e>
     62c:	66 c0       	rjmp	.+204    	; 0x6fa <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     62e:	80 91 82 00 	lds	r24, 0x0082
     632:	81 50       	subi	r24, 0x01	; 1
     634:	80 93 82 00 	sts	0x0082, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     638:	80 91 82 00 	lds	r24, 0x0082
     63c:	28 2f       	mov	r18, r24
     63e:	30 e0       	ldi	r19, 0x00	; 0
     640:	c9 01       	movw	r24, r18
     642:	88 0f       	add	r24, r24
     644:	99 1f       	adc	r25, r25
     646:	88 0f       	add	r24, r24
     648:	99 1f       	adc	r25, r25
     64a:	88 0f       	add	r24, r24
     64c:	99 1f       	adc	r25, r25
     64e:	82 0f       	add	r24, r18
     650:	93 1f       	adc	r25, r19
     652:	fc 01       	movw	r30, r24
     654:	e7 57       	subi	r30, 0x77	; 119
     656:	ff 4f       	sbci	r31, 0xFF	; 255
     658:	80 81       	ld	r24, Z
     65a:	88 23       	and	r24, r24
     65c:	19 f3       	breq	.-58     	; 0x624 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     65e:	80 91 82 00 	lds	r24, 0x0082
     662:	28 2f       	mov	r18, r24
     664:	30 e0       	ldi	r19, 0x00	; 0
     666:	c9 01       	movw	r24, r18
     668:	88 0f       	add	r24, r24
     66a:	99 1f       	adc	r25, r25
     66c:	88 0f       	add	r24, r24
     66e:	99 1f       	adc	r25, r25
     670:	88 0f       	add	r24, r24
     672:	99 1f       	adc	r25, r25
     674:	82 0f       	add	r24, r18
     676:	93 1f       	adc	r25, r19
     678:	87 57       	subi	r24, 0x77	; 119
     67a:	9f 4f       	sbci	r25, 0xFF	; 255
     67c:	9a 83       	std	Y+2, r25	; 0x02
     67e:	89 83       	std	Y+1, r24	; 0x01
     680:	e9 81       	ldd	r30, Y+1	; 0x01
     682:	fa 81       	ldd	r31, Y+2	; 0x02
     684:	01 80       	ldd	r0, Z+1	; 0x01
     686:	f2 81       	ldd	r31, Z+2	; 0x02
     688:	e0 2d       	mov	r30, r0
     68a:	82 81       	ldd	r24, Z+2	; 0x02
     68c:	93 81       	ldd	r25, Z+3	; 0x03
     68e:	e9 81       	ldd	r30, Y+1	; 0x01
     690:	fa 81       	ldd	r31, Y+2	; 0x02
     692:	92 83       	std	Z+2, r25	; 0x02
     694:	81 83       	std	Z+1, r24	; 0x01
     696:	e9 81       	ldd	r30, Y+1	; 0x01
     698:	fa 81       	ldd	r31, Y+2	; 0x02
     69a:	21 81       	ldd	r18, Z+1	; 0x01
     69c:	32 81       	ldd	r19, Z+2	; 0x02
     69e:	89 81       	ldd	r24, Y+1	; 0x01
     6a0:	9a 81       	ldd	r25, Y+2	; 0x02
     6a2:	03 96       	adiw	r24, 0x03	; 3
     6a4:	28 17       	cp	r18, r24
     6a6:	39 07       	cpc	r19, r25
     6a8:	59 f4       	brne	.+22     	; 0x6c0 <vCoRoutineSchedule+0xb0>
     6aa:	e9 81       	ldd	r30, Y+1	; 0x01
     6ac:	fa 81       	ldd	r31, Y+2	; 0x02
     6ae:	01 80       	ldd	r0, Z+1	; 0x01
     6b0:	f2 81       	ldd	r31, Z+2	; 0x02
     6b2:	e0 2d       	mov	r30, r0
     6b4:	82 81       	ldd	r24, Z+2	; 0x02
     6b6:	93 81       	ldd	r25, Z+3	; 0x03
     6b8:	e9 81       	ldd	r30, Y+1	; 0x01
     6ba:	fa 81       	ldd	r31, Y+2	; 0x02
     6bc:	92 83       	std	Z+2, r25	; 0x02
     6be:	81 83       	std	Z+1, r24	; 0x01
     6c0:	e9 81       	ldd	r30, Y+1	; 0x01
     6c2:	fa 81       	ldd	r31, Y+2	; 0x02
     6c4:	01 80       	ldd	r0, Z+1	; 0x01
     6c6:	f2 81       	ldd	r31, Z+2	; 0x02
     6c8:	e0 2d       	mov	r30, r0
     6ca:	86 81       	ldd	r24, Z+6	; 0x06
     6cc:	97 81       	ldd	r25, Z+7	; 0x07
     6ce:	90 93 81 00 	sts	0x0081, r25
     6d2:	80 93 80 00 	sts	0x0080, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     6d6:	e0 91 80 00 	lds	r30, 0x0080
     6da:	f0 91 81 00 	lds	r31, 0x0081
     6de:	40 81       	ld	r20, Z
     6e0:	51 81       	ldd	r21, Z+1	; 0x01
     6e2:	80 91 80 00 	lds	r24, 0x0080
     6e6:	90 91 81 00 	lds	r25, 0x0081
     6ea:	e0 91 80 00 	lds	r30, 0x0080
     6ee:	f0 91 81 00 	lds	r31, 0x0081
     6f2:	27 89       	ldd	r18, Z+23	; 0x17
     6f4:	62 2f       	mov	r22, r18
     6f6:	fa 01       	movw	r30, r20
     6f8:	09 95       	icall

	return;
}
     6fa:	0f 90       	pop	r0
     6fc:	0f 90       	pop	r0
     6fe:	cf 91       	pop	r28
     700:	df 91       	pop	r29
     702:	08 95       	ret

00000704 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     704:	df 93       	push	r29
     706:	cf 93       	push	r28
     708:	0f 92       	push	r0
     70a:	cd b7       	in	r28, 0x3d	; 61
     70c:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     70e:	19 82       	std	Y+1, r1	; 0x01
     710:	13 c0       	rjmp	.+38     	; 0x738 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     712:	89 81       	ldd	r24, Y+1	; 0x01
     714:	28 2f       	mov	r18, r24
     716:	30 e0       	ldi	r19, 0x00	; 0
     718:	c9 01       	movw	r24, r18
     71a:	88 0f       	add	r24, r24
     71c:	99 1f       	adc	r25, r25
     71e:	88 0f       	add	r24, r24
     720:	99 1f       	adc	r25, r25
     722:	88 0f       	add	r24, r24
     724:	99 1f       	adc	r25, r25
     726:	82 0f       	add	r24, r18
     728:	93 1f       	adc	r25, r19
     72a:	87 57       	subi	r24, 0x77	; 119
     72c:	9f 4f       	sbci	r25, 0xFF	; 255
     72e:	0e 94 5f 04 	call	0x8be	; 0x8be <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     732:	89 81       	ldd	r24, Y+1	; 0x01
     734:	8f 5f       	subi	r24, 0xFF	; 255
     736:	89 83       	std	Y+1, r24	; 0x01
     738:	89 81       	ldd	r24, Y+1	; 0x01
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	50 f3       	brcs	.-44     	; 0x712 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     73e:	8b e9       	ldi	r24, 0x9B	; 155
     740:	90 e0       	ldi	r25, 0x00	; 0
     742:	0e 94 5f 04 	call	0x8be	; 0x8be <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     746:	84 ea       	ldi	r24, 0xA4	; 164
     748:	90 e0       	ldi	r25, 0x00	; 0
     74a:	0e 94 5f 04 	call	0x8be	; 0x8be <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     74e:	81 eb       	ldi	r24, 0xB1	; 177
     750:	90 e0       	ldi	r25, 0x00	; 0
     752:	0e 94 5f 04 	call	0x8be	; 0x8be <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     756:	8b e9       	ldi	r24, 0x9B	; 155
     758:	90 e0       	ldi	r25, 0x00	; 0
     75a:	90 93 ae 00 	sts	0x00AE, r25
     75e:	80 93 ad 00 	sts	0x00AD, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     762:	84 ea       	ldi	r24, 0xA4	; 164
     764:	90 e0       	ldi	r25, 0x00	; 0
     766:	90 93 b0 00 	sts	0x00B0, r25
     76a:	80 93 af 00 	sts	0x00AF, r24
}
     76e:	0f 90       	pop	r0
     770:	cf 91       	pop	r28
     772:	df 91       	pop	r29
     774:	08 95       	ret

00000776 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     776:	df 93       	push	r29
     778:	cf 93       	push	r28
     77a:	00 d0       	rcall	.+0      	; 0x77c <xCoRoutineRemoveFromEventList+0x6>
     77c:	00 d0       	rcall	.+0      	; 0x77e <xCoRoutineRemoveFromEventList+0x8>
     77e:	0f 92       	push	r0
     780:	cd b7       	in	r28, 0x3d	; 61
     782:	de b7       	in	r29, 0x3e	; 62
     784:	9d 83       	std	Y+5, r25	; 0x05
     786:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     788:	ec 81       	ldd	r30, Y+4	; 0x04
     78a:	fd 81       	ldd	r31, Y+5	; 0x05
     78c:	05 80       	ldd	r0, Z+5	; 0x05
     78e:	f6 81       	ldd	r31, Z+6	; 0x06
     790:	e0 2d       	mov	r30, r0
     792:	86 81       	ldd	r24, Z+6	; 0x06
     794:	97 81       	ldd	r25, Z+7	; 0x07
     796:	9b 83       	std	Y+3, r25	; 0x03
     798:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     79a:	8a 81       	ldd	r24, Y+2	; 0x02
     79c:	9b 81       	ldd	r25, Y+3	; 0x03
     79e:	0c 96       	adiw	r24, 0x0c	; 12
     7a0:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     7a4:	8a 81       	ldd	r24, Y+2	; 0x02
     7a6:	9b 81       	ldd	r25, Y+3	; 0x03
     7a8:	9c 01       	movw	r18, r24
     7aa:	24 5f       	subi	r18, 0xF4	; 244
     7ac:	3f 4f       	sbci	r19, 0xFF	; 255
     7ae:	81 eb       	ldi	r24, 0xB1	; 177
     7b0:	90 e0       	ldi	r25, 0x00	; 0
     7b2:	b9 01       	movw	r22, r18
     7b4:	0e 94 99 04 	call	0x932	; 0x932 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     7b8:	ea 81       	ldd	r30, Y+2	; 0x02
     7ba:	fb 81       	ldd	r31, Y+3	; 0x03
     7bc:	96 89       	ldd	r25, Z+22	; 0x16
     7be:	e0 91 80 00 	lds	r30, 0x0080
     7c2:	f0 91 81 00 	lds	r31, 0x0081
     7c6:	86 89       	ldd	r24, Z+22	; 0x16
     7c8:	98 17       	cp	r25, r24
     7ca:	18 f0       	brcs	.+6      	; 0x7d2 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     7cc:	81 e0       	ldi	r24, 0x01	; 1
     7ce:	89 83       	std	Y+1, r24	; 0x01
     7d0:	01 c0       	rjmp	.+2      	; 0x7d4 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     7d2:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     7d4:	89 81       	ldd	r24, Y+1	; 0x01
}
     7d6:	0f 90       	pop	r0
     7d8:	0f 90       	pop	r0
     7da:	0f 90       	pop	r0
     7dc:	0f 90       	pop	r0
     7de:	0f 90       	pop	r0
     7e0:	cf 91       	pop	r28
     7e2:	df 91       	pop	r29
     7e4:	08 95       	ret

000007e6 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     7e6:	df 93       	push	r29
     7e8:	cf 93       	push	r28
     7ea:	00 d0       	rcall	.+0      	; 0x7ec <pvPortMalloc+0x6>
     7ec:	00 d0       	rcall	.+0      	; 0x7ee <pvPortMalloc+0x8>
     7ee:	cd b7       	in	r28, 0x3d	; 61
     7f0:	de b7       	in	r29, 0x3e	; 62
     7f2:	9c 83       	std	Y+4, r25	; 0x04
     7f4:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     7f6:	1a 82       	std	Y+2, r1	; 0x02
     7f8:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     7fa:	0e 94 08 10 	call	0x2010	; 0x2010 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     7fe:	80 91 ba 00 	lds	r24, 0x00BA
     802:	90 91 bb 00 	lds	r25, 0x00BB
     806:	2b 81       	ldd	r18, Y+3	; 0x03
     808:	3c 81       	ldd	r19, Y+4	; 0x04
     80a:	82 0f       	add	r24, r18
     80c:	93 1f       	adc	r25, r19
     80e:	22 e0       	ldi	r18, 0x02	; 2
     810:	88 35       	cpi	r24, 0x58	; 88
     812:	92 07       	cpc	r25, r18
     814:	18 f5       	brcc	.+70     	; 0x85c <pvPortMalloc+0x76>
     816:	20 91 ba 00 	lds	r18, 0x00BA
     81a:	30 91 bb 00 	lds	r19, 0x00BB
     81e:	8b 81       	ldd	r24, Y+3	; 0x03
     820:	9c 81       	ldd	r25, Y+4	; 0x04
     822:	28 0f       	add	r18, r24
     824:	39 1f       	adc	r19, r25
     826:	80 91 ba 00 	lds	r24, 0x00BA
     82a:	90 91 bb 00 	lds	r25, 0x00BB
     82e:	82 17       	cp	r24, r18
     830:	93 07       	cpc	r25, r19
     832:	a0 f4       	brcc	.+40     	; 0x85c <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     834:	80 91 ba 00 	lds	r24, 0x00BA
     838:	90 91 bb 00 	lds	r25, 0x00BB
     83c:	84 54       	subi	r24, 0x44	; 68
     83e:	9f 4f       	sbci	r25, 0xFF	; 255
     840:	9a 83       	std	Y+2, r25	; 0x02
     842:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     844:	20 91 ba 00 	lds	r18, 0x00BA
     848:	30 91 bb 00 	lds	r19, 0x00BB
     84c:	8b 81       	ldd	r24, Y+3	; 0x03
     84e:	9c 81       	ldd	r25, Y+4	; 0x04
     850:	82 0f       	add	r24, r18
     852:	93 1f       	adc	r25, r19
     854:	90 93 bb 00 	sts	0x00BB, r25
     858:	80 93 ba 00 	sts	0x00BA, r24
		}	
	}
	xTaskResumeAll();
     85c:	0e 94 14 10 	call	0x2028	; 0x2028 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     860:	89 81       	ldd	r24, Y+1	; 0x01
     862:	9a 81       	ldd	r25, Y+2	; 0x02
}
     864:	0f 90       	pop	r0
     866:	0f 90       	pop	r0
     868:	0f 90       	pop	r0
     86a:	0f 90       	pop	r0
     86c:	cf 91       	pop	r28
     86e:	df 91       	pop	r29
     870:	08 95       	ret

00000872 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     872:	df 93       	push	r29
     874:	cf 93       	push	r28
     876:	00 d0       	rcall	.+0      	; 0x878 <vPortFree+0x6>
     878:	cd b7       	in	r28, 0x3d	; 61
     87a:	de b7       	in	r29, 0x3e	; 62
     87c:	9a 83       	std	Y+2, r25	; 0x02
     87e:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     880:	0f 90       	pop	r0
     882:	0f 90       	pop	r0
     884:	cf 91       	pop	r28
     886:	df 91       	pop	r29
     888:	08 95       	ret

0000088a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     88a:	df 93       	push	r29
     88c:	cf 93       	push	r28
     88e:	cd b7       	in	r28, 0x3d	; 61
     890:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     892:	10 92 bb 00 	sts	0x00BB, r1
     896:	10 92 ba 00 	sts	0x00BA, r1
}
     89a:	cf 91       	pop	r28
     89c:	df 91       	pop	r29
     89e:	08 95       	ret

000008a0 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     8a0:	df 93       	push	r29
     8a2:	cf 93       	push	r28
     8a4:	cd b7       	in	r28, 0x3d	; 61
     8a6:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     8a8:	20 91 ba 00 	lds	r18, 0x00BA
     8ac:	30 91 bb 00 	lds	r19, 0x00BB
     8b0:	88 e5       	ldi	r24, 0x58	; 88
     8b2:	92 e0       	ldi	r25, 0x02	; 2
     8b4:	82 1b       	sub	r24, r18
     8b6:	93 0b       	sbc	r25, r19
}
     8b8:	cf 91       	pop	r28
     8ba:	df 91       	pop	r29
     8bc:	08 95       	ret

000008be <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     8be:	df 93       	push	r29
     8c0:	cf 93       	push	r28
     8c2:	00 d0       	rcall	.+0      	; 0x8c4 <vListInitialise+0x6>
     8c4:	cd b7       	in	r28, 0x3d	; 61
     8c6:	de b7       	in	r29, 0x3e	; 62
     8c8:	9a 83       	std	Y+2, r25	; 0x02
     8ca:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     8cc:	89 81       	ldd	r24, Y+1	; 0x01
     8ce:	9a 81       	ldd	r25, Y+2	; 0x02
     8d0:	03 96       	adiw	r24, 0x03	; 3
     8d2:	e9 81       	ldd	r30, Y+1	; 0x01
     8d4:	fa 81       	ldd	r31, Y+2	; 0x02
     8d6:	92 83       	std	Z+2, r25	; 0x02
     8d8:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     8da:	e9 81       	ldd	r30, Y+1	; 0x01
     8dc:	fa 81       	ldd	r31, Y+2	; 0x02
     8de:	8f ef       	ldi	r24, 0xFF	; 255
     8e0:	9f ef       	ldi	r25, 0xFF	; 255
     8e2:	94 83       	std	Z+4, r25	; 0x04
     8e4:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     8e6:	89 81       	ldd	r24, Y+1	; 0x01
     8e8:	9a 81       	ldd	r25, Y+2	; 0x02
     8ea:	03 96       	adiw	r24, 0x03	; 3
     8ec:	e9 81       	ldd	r30, Y+1	; 0x01
     8ee:	fa 81       	ldd	r31, Y+2	; 0x02
     8f0:	96 83       	std	Z+6, r25	; 0x06
     8f2:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     8f4:	89 81       	ldd	r24, Y+1	; 0x01
     8f6:	9a 81       	ldd	r25, Y+2	; 0x02
     8f8:	03 96       	adiw	r24, 0x03	; 3
     8fa:	e9 81       	ldd	r30, Y+1	; 0x01
     8fc:	fa 81       	ldd	r31, Y+2	; 0x02
     8fe:	90 87       	std	Z+8, r25	; 0x08
     900:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     902:	e9 81       	ldd	r30, Y+1	; 0x01
     904:	fa 81       	ldd	r31, Y+2	; 0x02
     906:	10 82       	st	Z, r1
}
     908:	0f 90       	pop	r0
     90a:	0f 90       	pop	r0
     90c:	cf 91       	pop	r28
     90e:	df 91       	pop	r29
     910:	08 95       	ret

00000912 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     912:	df 93       	push	r29
     914:	cf 93       	push	r28
     916:	00 d0       	rcall	.+0      	; 0x918 <vListInitialiseItem+0x6>
     918:	cd b7       	in	r28, 0x3d	; 61
     91a:	de b7       	in	r29, 0x3e	; 62
     91c:	9a 83       	std	Y+2, r25	; 0x02
     91e:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     920:	e9 81       	ldd	r30, Y+1	; 0x01
     922:	fa 81       	ldd	r31, Y+2	; 0x02
     924:	11 86       	std	Z+9, r1	; 0x09
     926:	10 86       	std	Z+8, r1	; 0x08
}
     928:	0f 90       	pop	r0
     92a:	0f 90       	pop	r0
     92c:	cf 91       	pop	r28
     92e:	df 91       	pop	r29
     930:	08 95       	ret

00000932 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     932:	df 93       	push	r29
     934:	cf 93       	push	r28
     936:	00 d0       	rcall	.+0      	; 0x938 <vListInsertEnd+0x6>
     938:	00 d0       	rcall	.+0      	; 0x93a <vListInsertEnd+0x8>
     93a:	00 d0       	rcall	.+0      	; 0x93c <vListInsertEnd+0xa>
     93c:	cd b7       	in	r28, 0x3d	; 61
     93e:	de b7       	in	r29, 0x3e	; 62
     940:	9c 83       	std	Y+4, r25	; 0x04
     942:	8b 83       	std	Y+3, r24	; 0x03
     944:	7e 83       	std	Y+6, r23	; 0x06
     946:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     948:	eb 81       	ldd	r30, Y+3	; 0x03
     94a:	fc 81       	ldd	r31, Y+4	; 0x04
     94c:	81 81       	ldd	r24, Z+1	; 0x01
     94e:	92 81       	ldd	r25, Z+2	; 0x02
     950:	9a 83       	std	Y+2, r25	; 0x02
     952:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     954:	e9 81       	ldd	r30, Y+1	; 0x01
     956:	fa 81       	ldd	r31, Y+2	; 0x02
     958:	82 81       	ldd	r24, Z+2	; 0x02
     95a:	93 81       	ldd	r25, Z+3	; 0x03
     95c:	ed 81       	ldd	r30, Y+5	; 0x05
     95e:	fe 81       	ldd	r31, Y+6	; 0x06
     960:	93 83       	std	Z+3, r25	; 0x03
     962:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     964:	eb 81       	ldd	r30, Y+3	; 0x03
     966:	fc 81       	ldd	r31, Y+4	; 0x04
     968:	81 81       	ldd	r24, Z+1	; 0x01
     96a:	92 81       	ldd	r25, Z+2	; 0x02
     96c:	ed 81       	ldd	r30, Y+5	; 0x05
     96e:	fe 81       	ldd	r31, Y+6	; 0x06
     970:	95 83       	std	Z+5, r25	; 0x05
     972:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     974:	e9 81       	ldd	r30, Y+1	; 0x01
     976:	fa 81       	ldd	r31, Y+2	; 0x02
     978:	02 80       	ldd	r0, Z+2	; 0x02
     97a:	f3 81       	ldd	r31, Z+3	; 0x03
     97c:	e0 2d       	mov	r30, r0
     97e:	8d 81       	ldd	r24, Y+5	; 0x05
     980:	9e 81       	ldd	r25, Y+6	; 0x06
     982:	95 83       	std	Z+5, r25	; 0x05
     984:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     986:	8d 81       	ldd	r24, Y+5	; 0x05
     988:	9e 81       	ldd	r25, Y+6	; 0x06
     98a:	e9 81       	ldd	r30, Y+1	; 0x01
     98c:	fa 81       	ldd	r31, Y+2	; 0x02
     98e:	93 83       	std	Z+3, r25	; 0x03
     990:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     992:	8d 81       	ldd	r24, Y+5	; 0x05
     994:	9e 81       	ldd	r25, Y+6	; 0x06
     996:	eb 81       	ldd	r30, Y+3	; 0x03
     998:	fc 81       	ldd	r31, Y+4	; 0x04
     99a:	92 83       	std	Z+2, r25	; 0x02
     99c:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     99e:	ed 81       	ldd	r30, Y+5	; 0x05
     9a0:	fe 81       	ldd	r31, Y+6	; 0x06
     9a2:	8b 81       	ldd	r24, Y+3	; 0x03
     9a4:	9c 81       	ldd	r25, Y+4	; 0x04
     9a6:	91 87       	std	Z+9, r25	; 0x09
     9a8:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     9aa:	eb 81       	ldd	r30, Y+3	; 0x03
     9ac:	fc 81       	ldd	r31, Y+4	; 0x04
     9ae:	80 81       	ld	r24, Z
     9b0:	8f 5f       	subi	r24, 0xFF	; 255
     9b2:	eb 81       	ldd	r30, Y+3	; 0x03
     9b4:	fc 81       	ldd	r31, Y+4	; 0x04
     9b6:	80 83       	st	Z, r24
}
     9b8:	26 96       	adiw	r28, 0x06	; 6
     9ba:	0f b6       	in	r0, 0x3f	; 63
     9bc:	f8 94       	cli
     9be:	de bf       	out	0x3e, r29	; 62
     9c0:	0f be       	out	0x3f, r0	; 63
     9c2:	cd bf       	out	0x3d, r28	; 61
     9c4:	cf 91       	pop	r28
     9c6:	df 91       	pop	r29
     9c8:	08 95       	ret

000009ca <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     9ca:	df 93       	push	r29
     9cc:	cf 93       	push	r28
     9ce:	cd b7       	in	r28, 0x3d	; 61
     9d0:	de b7       	in	r29, 0x3e	; 62
     9d2:	28 97       	sbiw	r28, 0x08	; 8
     9d4:	0f b6       	in	r0, 0x3f	; 63
     9d6:	f8 94       	cli
     9d8:	de bf       	out	0x3e, r29	; 62
     9da:	0f be       	out	0x3f, r0	; 63
     9dc:	cd bf       	out	0x3d, r28	; 61
     9de:	9e 83       	std	Y+6, r25	; 0x06
     9e0:	8d 83       	std	Y+5, r24	; 0x05
     9e2:	78 87       	std	Y+8, r23	; 0x08
     9e4:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     9e6:	ef 81       	ldd	r30, Y+7	; 0x07
     9e8:	f8 85       	ldd	r31, Y+8	; 0x08
     9ea:	80 81       	ld	r24, Z
     9ec:	91 81       	ldd	r25, Z+1	; 0x01
     9ee:	9a 83       	std	Y+2, r25	; 0x02
     9f0:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     9f2:	89 81       	ldd	r24, Y+1	; 0x01
     9f4:	9a 81       	ldd	r25, Y+2	; 0x02
     9f6:	2f ef       	ldi	r18, 0xFF	; 255
     9f8:	8f 3f       	cpi	r24, 0xFF	; 255
     9fa:	92 07       	cpc	r25, r18
     9fc:	39 f4       	brne	.+14     	; 0xa0c <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     9fe:	ed 81       	ldd	r30, Y+5	; 0x05
     a00:	fe 81       	ldd	r31, Y+6	; 0x06
     a02:	87 81       	ldd	r24, Z+7	; 0x07
     a04:	90 85       	ldd	r25, Z+8	; 0x08
     a06:	9c 83       	std	Y+4, r25	; 0x04
     a08:	8b 83       	std	Y+3, r24	; 0x03
     a0a:	18 c0       	rjmp	.+48     	; 0xa3c <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     a0c:	8d 81       	ldd	r24, Y+5	; 0x05
     a0e:	9e 81       	ldd	r25, Y+6	; 0x06
     a10:	03 96       	adiw	r24, 0x03	; 3
     a12:	9c 83       	std	Y+4, r25	; 0x04
     a14:	8b 83       	std	Y+3, r24	; 0x03
     a16:	06 c0       	rjmp	.+12     	; 0xa24 <vListInsert+0x5a>
     a18:	eb 81       	ldd	r30, Y+3	; 0x03
     a1a:	fc 81       	ldd	r31, Y+4	; 0x04
     a1c:	82 81       	ldd	r24, Z+2	; 0x02
     a1e:	93 81       	ldd	r25, Z+3	; 0x03
     a20:	9c 83       	std	Y+4, r25	; 0x04
     a22:	8b 83       	std	Y+3, r24	; 0x03
     a24:	eb 81       	ldd	r30, Y+3	; 0x03
     a26:	fc 81       	ldd	r31, Y+4	; 0x04
     a28:	02 80       	ldd	r0, Z+2	; 0x02
     a2a:	f3 81       	ldd	r31, Z+3	; 0x03
     a2c:	e0 2d       	mov	r30, r0
     a2e:	20 81       	ld	r18, Z
     a30:	31 81       	ldd	r19, Z+1	; 0x01
     a32:	89 81       	ldd	r24, Y+1	; 0x01
     a34:	9a 81       	ldd	r25, Y+2	; 0x02
     a36:	82 17       	cp	r24, r18
     a38:	93 07       	cpc	r25, r19
     a3a:	70 f7       	brcc	.-36     	; 0xa18 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a3c:	eb 81       	ldd	r30, Y+3	; 0x03
     a3e:	fc 81       	ldd	r31, Y+4	; 0x04
     a40:	82 81       	ldd	r24, Z+2	; 0x02
     a42:	93 81       	ldd	r25, Z+3	; 0x03
     a44:	ef 81       	ldd	r30, Y+7	; 0x07
     a46:	f8 85       	ldd	r31, Y+8	; 0x08
     a48:	93 83       	std	Z+3, r25	; 0x03
     a4a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     a4c:	ef 81       	ldd	r30, Y+7	; 0x07
     a4e:	f8 85       	ldd	r31, Y+8	; 0x08
     a50:	02 80       	ldd	r0, Z+2	; 0x02
     a52:	f3 81       	ldd	r31, Z+3	; 0x03
     a54:	e0 2d       	mov	r30, r0
     a56:	8f 81       	ldd	r24, Y+7	; 0x07
     a58:	98 85       	ldd	r25, Y+8	; 0x08
     a5a:	95 83       	std	Z+5, r25	; 0x05
     a5c:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     a5e:	ef 81       	ldd	r30, Y+7	; 0x07
     a60:	f8 85       	ldd	r31, Y+8	; 0x08
     a62:	8b 81       	ldd	r24, Y+3	; 0x03
     a64:	9c 81       	ldd	r25, Y+4	; 0x04
     a66:	95 83       	std	Z+5, r25	; 0x05
     a68:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     a6a:	8f 81       	ldd	r24, Y+7	; 0x07
     a6c:	98 85       	ldd	r25, Y+8	; 0x08
     a6e:	eb 81       	ldd	r30, Y+3	; 0x03
     a70:	fc 81       	ldd	r31, Y+4	; 0x04
     a72:	93 83       	std	Z+3, r25	; 0x03
     a74:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a76:	ef 81       	ldd	r30, Y+7	; 0x07
     a78:	f8 85       	ldd	r31, Y+8	; 0x08
     a7a:	8d 81       	ldd	r24, Y+5	; 0x05
     a7c:	9e 81       	ldd	r25, Y+6	; 0x06
     a7e:	91 87       	std	Z+9, r25	; 0x09
     a80:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     a82:	ed 81       	ldd	r30, Y+5	; 0x05
     a84:	fe 81       	ldd	r31, Y+6	; 0x06
     a86:	80 81       	ld	r24, Z
     a88:	8f 5f       	subi	r24, 0xFF	; 255
     a8a:	ed 81       	ldd	r30, Y+5	; 0x05
     a8c:	fe 81       	ldd	r31, Y+6	; 0x06
     a8e:	80 83       	st	Z, r24
}
     a90:	28 96       	adiw	r28, 0x08	; 8
     a92:	0f b6       	in	r0, 0x3f	; 63
     a94:	f8 94       	cli
     a96:	de bf       	out	0x3e, r29	; 62
     a98:	0f be       	out	0x3f, r0	; 63
     a9a:	cd bf       	out	0x3d, r28	; 61
     a9c:	cf 91       	pop	r28
     a9e:	df 91       	pop	r29
     aa0:	08 95       	ret

00000aa2 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     aa2:	df 93       	push	r29
     aa4:	cf 93       	push	r28
     aa6:	00 d0       	rcall	.+0      	; 0xaa8 <vListRemove+0x6>
     aa8:	00 d0       	rcall	.+0      	; 0xaaa <vListRemove+0x8>
     aaa:	cd b7       	in	r28, 0x3d	; 61
     aac:	de b7       	in	r29, 0x3e	; 62
     aae:	9c 83       	std	Y+4, r25	; 0x04
     ab0:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     ab2:	eb 81       	ldd	r30, Y+3	; 0x03
     ab4:	fc 81       	ldd	r31, Y+4	; 0x04
     ab6:	a2 81       	ldd	r26, Z+2	; 0x02
     ab8:	b3 81       	ldd	r27, Z+3	; 0x03
     aba:	eb 81       	ldd	r30, Y+3	; 0x03
     abc:	fc 81       	ldd	r31, Y+4	; 0x04
     abe:	84 81       	ldd	r24, Z+4	; 0x04
     ac0:	95 81       	ldd	r25, Z+5	; 0x05
     ac2:	15 96       	adiw	r26, 0x05	; 5
     ac4:	9c 93       	st	X, r25
     ac6:	8e 93       	st	-X, r24
     ac8:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     aca:	eb 81       	ldd	r30, Y+3	; 0x03
     acc:	fc 81       	ldd	r31, Y+4	; 0x04
     ace:	a4 81       	ldd	r26, Z+4	; 0x04
     ad0:	b5 81       	ldd	r27, Z+5	; 0x05
     ad2:	eb 81       	ldd	r30, Y+3	; 0x03
     ad4:	fc 81       	ldd	r31, Y+4	; 0x04
     ad6:	82 81       	ldd	r24, Z+2	; 0x02
     ad8:	93 81       	ldd	r25, Z+3	; 0x03
     ada:	13 96       	adiw	r26, 0x03	; 3
     adc:	9c 93       	st	X, r25
     ade:	8e 93       	st	-X, r24
     ae0:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     ae2:	eb 81       	ldd	r30, Y+3	; 0x03
     ae4:	fc 81       	ldd	r31, Y+4	; 0x04
     ae6:	80 85       	ldd	r24, Z+8	; 0x08
     ae8:	91 85       	ldd	r25, Z+9	; 0x09
     aea:	9a 83       	std	Y+2, r25	; 0x02
     aec:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     aee:	e9 81       	ldd	r30, Y+1	; 0x01
     af0:	fa 81       	ldd	r31, Y+2	; 0x02
     af2:	21 81       	ldd	r18, Z+1	; 0x01
     af4:	32 81       	ldd	r19, Z+2	; 0x02
     af6:	8b 81       	ldd	r24, Y+3	; 0x03
     af8:	9c 81       	ldd	r25, Y+4	; 0x04
     afa:	28 17       	cp	r18, r24
     afc:	39 07       	cpc	r19, r25
     afe:	41 f4       	brne	.+16     	; 0xb10 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     b00:	eb 81       	ldd	r30, Y+3	; 0x03
     b02:	fc 81       	ldd	r31, Y+4	; 0x04
     b04:	84 81       	ldd	r24, Z+4	; 0x04
     b06:	95 81       	ldd	r25, Z+5	; 0x05
     b08:	e9 81       	ldd	r30, Y+1	; 0x01
     b0a:	fa 81       	ldd	r31, Y+2	; 0x02
     b0c:	92 83       	std	Z+2, r25	; 0x02
     b0e:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     b10:	eb 81       	ldd	r30, Y+3	; 0x03
     b12:	fc 81       	ldd	r31, Y+4	; 0x04
     b14:	11 86       	std	Z+9, r1	; 0x09
     b16:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     b18:	e9 81       	ldd	r30, Y+1	; 0x01
     b1a:	fa 81       	ldd	r31, Y+2	; 0x02
     b1c:	80 81       	ld	r24, Z
     b1e:	81 50       	subi	r24, 0x01	; 1
     b20:	e9 81       	ldd	r30, Y+1	; 0x01
     b22:	fa 81       	ldd	r31, Y+2	; 0x02
     b24:	80 83       	st	Z, r24
}
     b26:	0f 90       	pop	r0
     b28:	0f 90       	pop	r0
     b2a:	0f 90       	pop	r0
     b2c:	0f 90       	pop	r0
     b2e:	cf 91       	pop	r28
     b30:	df 91       	pop	r29
     b32:	08 95       	ret

00000b34 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
     b34:	df 93       	push	r29
     b36:	cf 93       	push	r28
     b38:	cd b7       	in	r28, 0x3d	; 61
     b3a:	de b7       	in	r29, 0x3e	; 62
     b3c:	28 97       	sbiw	r28, 0x08	; 8
     b3e:	0f b6       	in	r0, 0x3f	; 63
     b40:	f8 94       	cli
     b42:	de bf       	out	0x3e, r29	; 62
     b44:	0f be       	out	0x3f, r0	; 63
     b46:	cd bf       	out	0x3d, r28	; 61
     b48:	9c 83       	std	Y+4, r25	; 0x04
     b4a:	8b 83       	std	Y+3, r24	; 0x03
     b4c:	7e 83       	std	Y+6, r23	; 0x06
     b4e:	6d 83       	std	Y+5, r22	; 0x05
     b50:	58 87       	std	Y+8, r21	; 0x08
     b52:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     b54:	eb 81       	ldd	r30, Y+3	; 0x03
     b56:	fc 81       	ldd	r31, Y+4	; 0x04
     b58:	81 e1       	ldi	r24, 0x11	; 17
     b5a:	80 83       	st	Z, r24
	pxTopOfStack--;
     b5c:	8b 81       	ldd	r24, Y+3	; 0x03
     b5e:	9c 81       	ldd	r25, Y+4	; 0x04
     b60:	01 97       	sbiw	r24, 0x01	; 1
     b62:	9c 83       	std	Y+4, r25	; 0x04
     b64:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     b66:	eb 81       	ldd	r30, Y+3	; 0x03
     b68:	fc 81       	ldd	r31, Y+4	; 0x04
     b6a:	82 e2       	ldi	r24, 0x22	; 34
     b6c:	80 83       	st	Z, r24
	pxTopOfStack--;
     b6e:	8b 81       	ldd	r24, Y+3	; 0x03
     b70:	9c 81       	ldd	r25, Y+4	; 0x04
     b72:	01 97       	sbiw	r24, 0x01	; 1
     b74:	9c 83       	std	Y+4, r25	; 0x04
     b76:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     b78:	eb 81       	ldd	r30, Y+3	; 0x03
     b7a:	fc 81       	ldd	r31, Y+4	; 0x04
     b7c:	83 e3       	ldi	r24, 0x33	; 51
     b7e:	80 83       	st	Z, r24
	pxTopOfStack--;
     b80:	8b 81       	ldd	r24, Y+3	; 0x03
     b82:	9c 81       	ldd	r25, Y+4	; 0x04
     b84:	01 97       	sbiw	r24, 0x01	; 1
     b86:	9c 83       	std	Y+4, r25	; 0x04
     b88:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
     b8a:	8d 81       	ldd	r24, Y+5	; 0x05
     b8c:	9e 81       	ldd	r25, Y+6	; 0x06
     b8e:	9a 83       	std	Y+2, r25	; 0x02
     b90:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     b92:	89 81       	ldd	r24, Y+1	; 0x01
     b94:	eb 81       	ldd	r30, Y+3	; 0x03
     b96:	fc 81       	ldd	r31, Y+4	; 0x04
     b98:	80 83       	st	Z, r24
	pxTopOfStack--;
     b9a:	8b 81       	ldd	r24, Y+3	; 0x03
     b9c:	9c 81       	ldd	r25, Y+4	; 0x04
     b9e:	01 97       	sbiw	r24, 0x01	; 1
     ba0:	9c 83       	std	Y+4, r25	; 0x04
     ba2:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     ba4:	89 81       	ldd	r24, Y+1	; 0x01
     ba6:	9a 81       	ldd	r25, Y+2	; 0x02
     ba8:	89 2f       	mov	r24, r25
     baa:	99 27       	eor	r25, r25
     bac:	9a 83       	std	Y+2, r25	; 0x02
     bae:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     bb0:	89 81       	ldd	r24, Y+1	; 0x01
     bb2:	eb 81       	ldd	r30, Y+3	; 0x03
     bb4:	fc 81       	ldd	r31, Y+4	; 0x04
     bb6:	80 83       	st	Z, r24
	pxTopOfStack--;
     bb8:	8b 81       	ldd	r24, Y+3	; 0x03
     bba:	9c 81       	ldd	r25, Y+4	; 0x04
     bbc:	01 97       	sbiw	r24, 0x01	; 1
     bbe:	9c 83       	std	Y+4, r25	; 0x04
     bc0:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     bc2:	eb 81       	ldd	r30, Y+3	; 0x03
     bc4:	fc 81       	ldd	r31, Y+4	; 0x04
     bc6:	10 82       	st	Z, r1
	pxTopOfStack--;
     bc8:	8b 81       	ldd	r24, Y+3	; 0x03
     bca:	9c 81       	ldd	r25, Y+4	; 0x04
     bcc:	01 97       	sbiw	r24, 0x01	; 1
     bce:	9c 83       	std	Y+4, r25	; 0x04
     bd0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     bd2:	eb 81       	ldd	r30, Y+3	; 0x03
     bd4:	fc 81       	ldd	r31, Y+4	; 0x04
     bd6:	80 e8       	ldi	r24, 0x80	; 128
     bd8:	80 83       	st	Z, r24
	pxTopOfStack--;
     bda:	8b 81       	ldd	r24, Y+3	; 0x03
     bdc:	9c 81       	ldd	r25, Y+4	; 0x04
     bde:	01 97       	sbiw	r24, 0x01	; 1
     be0:	9c 83       	std	Y+4, r25	; 0x04
     be2:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     be4:	eb 81       	ldd	r30, Y+3	; 0x03
     be6:	fc 81       	ldd	r31, Y+4	; 0x04
     be8:	10 82       	st	Z, r1
	pxTopOfStack--;
     bea:	8b 81       	ldd	r24, Y+3	; 0x03
     bec:	9c 81       	ldd	r25, Y+4	; 0x04
     bee:	01 97       	sbiw	r24, 0x01	; 1
     bf0:	9c 83       	std	Y+4, r25	; 0x04
     bf2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     bf4:	eb 81       	ldd	r30, Y+3	; 0x03
     bf6:	fc 81       	ldd	r31, Y+4	; 0x04
     bf8:	82 e0       	ldi	r24, 0x02	; 2
     bfa:	80 83       	st	Z, r24
	pxTopOfStack--;
     bfc:	8b 81       	ldd	r24, Y+3	; 0x03
     bfe:	9c 81       	ldd	r25, Y+4	; 0x04
     c00:	01 97       	sbiw	r24, 0x01	; 1
     c02:	9c 83       	std	Y+4, r25	; 0x04
     c04:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     c06:	eb 81       	ldd	r30, Y+3	; 0x03
     c08:	fc 81       	ldd	r31, Y+4	; 0x04
     c0a:	83 e0       	ldi	r24, 0x03	; 3
     c0c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c0e:	8b 81       	ldd	r24, Y+3	; 0x03
     c10:	9c 81       	ldd	r25, Y+4	; 0x04
     c12:	01 97       	sbiw	r24, 0x01	; 1
     c14:	9c 83       	std	Y+4, r25	; 0x04
     c16:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     c18:	eb 81       	ldd	r30, Y+3	; 0x03
     c1a:	fc 81       	ldd	r31, Y+4	; 0x04
     c1c:	84 e0       	ldi	r24, 0x04	; 4
     c1e:	80 83       	st	Z, r24
	pxTopOfStack--;
     c20:	8b 81       	ldd	r24, Y+3	; 0x03
     c22:	9c 81       	ldd	r25, Y+4	; 0x04
     c24:	01 97       	sbiw	r24, 0x01	; 1
     c26:	9c 83       	std	Y+4, r25	; 0x04
     c28:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     c2a:	eb 81       	ldd	r30, Y+3	; 0x03
     c2c:	fc 81       	ldd	r31, Y+4	; 0x04
     c2e:	85 e0       	ldi	r24, 0x05	; 5
     c30:	80 83       	st	Z, r24
	pxTopOfStack--;
     c32:	8b 81       	ldd	r24, Y+3	; 0x03
     c34:	9c 81       	ldd	r25, Y+4	; 0x04
     c36:	01 97       	sbiw	r24, 0x01	; 1
     c38:	9c 83       	std	Y+4, r25	; 0x04
     c3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     c3c:	eb 81       	ldd	r30, Y+3	; 0x03
     c3e:	fc 81       	ldd	r31, Y+4	; 0x04
     c40:	86 e0       	ldi	r24, 0x06	; 6
     c42:	80 83       	st	Z, r24
	pxTopOfStack--;
     c44:	8b 81       	ldd	r24, Y+3	; 0x03
     c46:	9c 81       	ldd	r25, Y+4	; 0x04
     c48:	01 97       	sbiw	r24, 0x01	; 1
     c4a:	9c 83       	std	Y+4, r25	; 0x04
     c4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     c4e:	eb 81       	ldd	r30, Y+3	; 0x03
     c50:	fc 81       	ldd	r31, Y+4	; 0x04
     c52:	87 e0       	ldi	r24, 0x07	; 7
     c54:	80 83       	st	Z, r24
	pxTopOfStack--;
     c56:	8b 81       	ldd	r24, Y+3	; 0x03
     c58:	9c 81       	ldd	r25, Y+4	; 0x04
     c5a:	01 97       	sbiw	r24, 0x01	; 1
     c5c:	9c 83       	std	Y+4, r25	; 0x04
     c5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     c60:	eb 81       	ldd	r30, Y+3	; 0x03
     c62:	fc 81       	ldd	r31, Y+4	; 0x04
     c64:	88 e0       	ldi	r24, 0x08	; 8
     c66:	80 83       	st	Z, r24
	pxTopOfStack--;
     c68:	8b 81       	ldd	r24, Y+3	; 0x03
     c6a:	9c 81       	ldd	r25, Y+4	; 0x04
     c6c:	01 97       	sbiw	r24, 0x01	; 1
     c6e:	9c 83       	std	Y+4, r25	; 0x04
     c70:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     c72:	eb 81       	ldd	r30, Y+3	; 0x03
     c74:	fc 81       	ldd	r31, Y+4	; 0x04
     c76:	89 e0       	ldi	r24, 0x09	; 9
     c78:	80 83       	st	Z, r24
	pxTopOfStack--;
     c7a:	8b 81       	ldd	r24, Y+3	; 0x03
     c7c:	9c 81       	ldd	r25, Y+4	; 0x04
     c7e:	01 97       	sbiw	r24, 0x01	; 1
     c80:	9c 83       	std	Y+4, r25	; 0x04
     c82:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     c84:	eb 81       	ldd	r30, Y+3	; 0x03
     c86:	fc 81       	ldd	r31, Y+4	; 0x04
     c88:	80 e1       	ldi	r24, 0x10	; 16
     c8a:	80 83       	st	Z, r24
	pxTopOfStack--;
     c8c:	8b 81       	ldd	r24, Y+3	; 0x03
     c8e:	9c 81       	ldd	r25, Y+4	; 0x04
     c90:	01 97       	sbiw	r24, 0x01	; 1
     c92:	9c 83       	std	Y+4, r25	; 0x04
     c94:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     c96:	eb 81       	ldd	r30, Y+3	; 0x03
     c98:	fc 81       	ldd	r31, Y+4	; 0x04
     c9a:	81 e1       	ldi	r24, 0x11	; 17
     c9c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c9e:	8b 81       	ldd	r24, Y+3	; 0x03
     ca0:	9c 81       	ldd	r25, Y+4	; 0x04
     ca2:	01 97       	sbiw	r24, 0x01	; 1
     ca4:	9c 83       	std	Y+4, r25	; 0x04
     ca6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     ca8:	eb 81       	ldd	r30, Y+3	; 0x03
     caa:	fc 81       	ldd	r31, Y+4	; 0x04
     cac:	82 e1       	ldi	r24, 0x12	; 18
     cae:	80 83       	st	Z, r24
	pxTopOfStack--;
     cb0:	8b 81       	ldd	r24, Y+3	; 0x03
     cb2:	9c 81       	ldd	r25, Y+4	; 0x04
     cb4:	01 97       	sbiw	r24, 0x01	; 1
     cb6:	9c 83       	std	Y+4, r25	; 0x04
     cb8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     cba:	eb 81       	ldd	r30, Y+3	; 0x03
     cbc:	fc 81       	ldd	r31, Y+4	; 0x04
     cbe:	83 e1       	ldi	r24, 0x13	; 19
     cc0:	80 83       	st	Z, r24
	pxTopOfStack--;
     cc2:	8b 81       	ldd	r24, Y+3	; 0x03
     cc4:	9c 81       	ldd	r25, Y+4	; 0x04
     cc6:	01 97       	sbiw	r24, 0x01	; 1
     cc8:	9c 83       	std	Y+4, r25	; 0x04
     cca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     ccc:	eb 81       	ldd	r30, Y+3	; 0x03
     cce:	fc 81       	ldd	r31, Y+4	; 0x04
     cd0:	84 e1       	ldi	r24, 0x14	; 20
     cd2:	80 83       	st	Z, r24
	pxTopOfStack--;
     cd4:	8b 81       	ldd	r24, Y+3	; 0x03
     cd6:	9c 81       	ldd	r25, Y+4	; 0x04
     cd8:	01 97       	sbiw	r24, 0x01	; 1
     cda:	9c 83       	std	Y+4, r25	; 0x04
     cdc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     cde:	eb 81       	ldd	r30, Y+3	; 0x03
     ce0:	fc 81       	ldd	r31, Y+4	; 0x04
     ce2:	85 e1       	ldi	r24, 0x15	; 21
     ce4:	80 83       	st	Z, r24
	pxTopOfStack--;
     ce6:	8b 81       	ldd	r24, Y+3	; 0x03
     ce8:	9c 81       	ldd	r25, Y+4	; 0x04
     cea:	01 97       	sbiw	r24, 0x01	; 1
     cec:	9c 83       	std	Y+4, r25	; 0x04
     cee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     cf0:	eb 81       	ldd	r30, Y+3	; 0x03
     cf2:	fc 81       	ldd	r31, Y+4	; 0x04
     cf4:	86 e1       	ldi	r24, 0x16	; 22
     cf6:	80 83       	st	Z, r24
	pxTopOfStack--;
     cf8:	8b 81       	ldd	r24, Y+3	; 0x03
     cfa:	9c 81       	ldd	r25, Y+4	; 0x04
     cfc:	01 97       	sbiw	r24, 0x01	; 1
     cfe:	9c 83       	std	Y+4, r25	; 0x04
     d00:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     d02:	eb 81       	ldd	r30, Y+3	; 0x03
     d04:	fc 81       	ldd	r31, Y+4	; 0x04
     d06:	87 e1       	ldi	r24, 0x17	; 23
     d08:	80 83       	st	Z, r24
	pxTopOfStack--;
     d0a:	8b 81       	ldd	r24, Y+3	; 0x03
     d0c:	9c 81       	ldd	r25, Y+4	; 0x04
     d0e:	01 97       	sbiw	r24, 0x01	; 1
     d10:	9c 83       	std	Y+4, r25	; 0x04
     d12:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     d14:	eb 81       	ldd	r30, Y+3	; 0x03
     d16:	fc 81       	ldd	r31, Y+4	; 0x04
     d18:	88 e1       	ldi	r24, 0x18	; 24
     d1a:	80 83       	st	Z, r24
	pxTopOfStack--;
     d1c:	8b 81       	ldd	r24, Y+3	; 0x03
     d1e:	9c 81       	ldd	r25, Y+4	; 0x04
     d20:	01 97       	sbiw	r24, 0x01	; 1
     d22:	9c 83       	std	Y+4, r25	; 0x04
     d24:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     d26:	eb 81       	ldd	r30, Y+3	; 0x03
     d28:	fc 81       	ldd	r31, Y+4	; 0x04
     d2a:	89 e1       	ldi	r24, 0x19	; 25
     d2c:	80 83       	st	Z, r24
	pxTopOfStack--;
     d2e:	8b 81       	ldd	r24, Y+3	; 0x03
     d30:	9c 81       	ldd	r25, Y+4	; 0x04
     d32:	01 97       	sbiw	r24, 0x01	; 1
     d34:	9c 83       	std	Y+4, r25	; 0x04
     d36:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     d38:	eb 81       	ldd	r30, Y+3	; 0x03
     d3a:	fc 81       	ldd	r31, Y+4	; 0x04
     d3c:	80 e2       	ldi	r24, 0x20	; 32
     d3e:	80 83       	st	Z, r24
	pxTopOfStack--;
     d40:	8b 81       	ldd	r24, Y+3	; 0x03
     d42:	9c 81       	ldd	r25, Y+4	; 0x04
     d44:	01 97       	sbiw	r24, 0x01	; 1
     d46:	9c 83       	std	Y+4, r25	; 0x04
     d48:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     d4a:	eb 81       	ldd	r30, Y+3	; 0x03
     d4c:	fc 81       	ldd	r31, Y+4	; 0x04
     d4e:	81 e2       	ldi	r24, 0x21	; 33
     d50:	80 83       	st	Z, r24
	pxTopOfStack--;
     d52:	8b 81       	ldd	r24, Y+3	; 0x03
     d54:	9c 81       	ldd	r25, Y+4	; 0x04
     d56:	01 97       	sbiw	r24, 0x01	; 1
     d58:	9c 83       	std	Y+4, r25	; 0x04
     d5a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     d5c:	eb 81       	ldd	r30, Y+3	; 0x03
     d5e:	fc 81       	ldd	r31, Y+4	; 0x04
     d60:	82 e2       	ldi	r24, 0x22	; 34
     d62:	80 83       	st	Z, r24
	pxTopOfStack--;
     d64:	8b 81       	ldd	r24, Y+3	; 0x03
     d66:	9c 81       	ldd	r25, Y+4	; 0x04
     d68:	01 97       	sbiw	r24, 0x01	; 1
     d6a:	9c 83       	std	Y+4, r25	; 0x04
     d6c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     d6e:	eb 81       	ldd	r30, Y+3	; 0x03
     d70:	fc 81       	ldd	r31, Y+4	; 0x04
     d72:	83 e2       	ldi	r24, 0x23	; 35
     d74:	80 83       	st	Z, r24
	pxTopOfStack--;
     d76:	8b 81       	ldd	r24, Y+3	; 0x03
     d78:	9c 81       	ldd	r25, Y+4	; 0x04
     d7a:	01 97       	sbiw	r24, 0x01	; 1
     d7c:	9c 83       	std	Y+4, r25	; 0x04
     d7e:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
     d80:	8f 81       	ldd	r24, Y+7	; 0x07
     d82:	98 85       	ldd	r25, Y+8	; 0x08
     d84:	9a 83       	std	Y+2, r25	; 0x02
     d86:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     d88:	89 81       	ldd	r24, Y+1	; 0x01
     d8a:	eb 81       	ldd	r30, Y+3	; 0x03
     d8c:	fc 81       	ldd	r31, Y+4	; 0x04
     d8e:	80 83       	st	Z, r24
	pxTopOfStack--;
     d90:	8b 81       	ldd	r24, Y+3	; 0x03
     d92:	9c 81       	ldd	r25, Y+4	; 0x04
     d94:	01 97       	sbiw	r24, 0x01	; 1
     d96:	9c 83       	std	Y+4, r25	; 0x04
     d98:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     d9a:	89 81       	ldd	r24, Y+1	; 0x01
     d9c:	9a 81       	ldd	r25, Y+2	; 0x02
     d9e:	89 2f       	mov	r24, r25
     da0:	99 27       	eor	r25, r25
     da2:	9a 83       	std	Y+2, r25	; 0x02
     da4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     da6:	89 81       	ldd	r24, Y+1	; 0x01
     da8:	eb 81       	ldd	r30, Y+3	; 0x03
     daa:	fc 81       	ldd	r31, Y+4	; 0x04
     dac:	80 83       	st	Z, r24
	pxTopOfStack--;
     dae:	8b 81       	ldd	r24, Y+3	; 0x03
     db0:	9c 81       	ldd	r25, Y+4	; 0x04
     db2:	01 97       	sbiw	r24, 0x01	; 1
     db4:	9c 83       	std	Y+4, r25	; 0x04
     db6:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     db8:	eb 81       	ldd	r30, Y+3	; 0x03
     dba:	fc 81       	ldd	r31, Y+4	; 0x04
     dbc:	86 e2       	ldi	r24, 0x26	; 38
     dbe:	80 83       	st	Z, r24
	pxTopOfStack--;
     dc0:	8b 81       	ldd	r24, Y+3	; 0x03
     dc2:	9c 81       	ldd	r25, Y+4	; 0x04
     dc4:	01 97       	sbiw	r24, 0x01	; 1
     dc6:	9c 83       	std	Y+4, r25	; 0x04
     dc8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     dca:	eb 81       	ldd	r30, Y+3	; 0x03
     dcc:	fc 81       	ldd	r31, Y+4	; 0x04
     dce:	87 e2       	ldi	r24, 0x27	; 39
     dd0:	80 83       	st	Z, r24
	pxTopOfStack--;
     dd2:	8b 81       	ldd	r24, Y+3	; 0x03
     dd4:	9c 81       	ldd	r25, Y+4	; 0x04
     dd6:	01 97       	sbiw	r24, 0x01	; 1
     dd8:	9c 83       	std	Y+4, r25	; 0x04
     dda:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     ddc:	eb 81       	ldd	r30, Y+3	; 0x03
     dde:	fc 81       	ldd	r31, Y+4	; 0x04
     de0:	88 e2       	ldi	r24, 0x28	; 40
     de2:	80 83       	st	Z, r24
	pxTopOfStack--;
     de4:	8b 81       	ldd	r24, Y+3	; 0x03
     de6:	9c 81       	ldd	r25, Y+4	; 0x04
     de8:	01 97       	sbiw	r24, 0x01	; 1
     dea:	9c 83       	std	Y+4, r25	; 0x04
     dec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     dee:	eb 81       	ldd	r30, Y+3	; 0x03
     df0:	fc 81       	ldd	r31, Y+4	; 0x04
     df2:	89 e2       	ldi	r24, 0x29	; 41
     df4:	80 83       	st	Z, r24
	pxTopOfStack--;
     df6:	8b 81       	ldd	r24, Y+3	; 0x03
     df8:	9c 81       	ldd	r25, Y+4	; 0x04
     dfa:	01 97       	sbiw	r24, 0x01	; 1
     dfc:	9c 83       	std	Y+4, r25	; 0x04
     dfe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     e00:	eb 81       	ldd	r30, Y+3	; 0x03
     e02:	fc 81       	ldd	r31, Y+4	; 0x04
     e04:	80 e3       	ldi	r24, 0x30	; 48
     e06:	80 83       	st	Z, r24
	pxTopOfStack--;
     e08:	8b 81       	ldd	r24, Y+3	; 0x03
     e0a:	9c 81       	ldd	r25, Y+4	; 0x04
     e0c:	01 97       	sbiw	r24, 0x01	; 1
     e0e:	9c 83       	std	Y+4, r25	; 0x04
     e10:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     e12:	eb 81       	ldd	r30, Y+3	; 0x03
     e14:	fc 81       	ldd	r31, Y+4	; 0x04
     e16:	81 e3       	ldi	r24, 0x31	; 49
     e18:	80 83       	st	Z, r24
	pxTopOfStack--;
     e1a:	8b 81       	ldd	r24, Y+3	; 0x03
     e1c:	9c 81       	ldd	r25, Y+4	; 0x04
     e1e:	01 97       	sbiw	r24, 0x01	; 1
     e20:	9c 83       	std	Y+4, r25	; 0x04
     e22:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     e24:	8b 81       	ldd	r24, Y+3	; 0x03
     e26:	9c 81       	ldd	r25, Y+4	; 0x04
}
     e28:	28 96       	adiw	r28, 0x08	; 8
     e2a:	0f b6       	in	r0, 0x3f	; 63
     e2c:	f8 94       	cli
     e2e:	de bf       	out	0x3e, r29	; 62
     e30:	0f be       	out	0x3f, r0	; 63
     e32:	cd bf       	out	0x3d, r28	; 61
     e34:	cf 91       	pop	r28
     e36:	df 91       	pop	r29
     e38:	08 95       	ret

00000e3a <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
     e3a:	df 93       	push	r29
     e3c:	cf 93       	push	r28
     e3e:	cd b7       	in	r28, 0x3d	; 61
     e40:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     e42:	0e 94 0d 08 	call	0x101a	; 0x101a <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     e46:	a0 91 14 03 	lds	r26, 0x0314
     e4a:	b0 91 15 03 	lds	r27, 0x0315
     e4e:	cd 91       	ld	r28, X+
     e50:	cd bf       	out	0x3d, r28	; 61
     e52:	dd 91       	ld	r29, X+
     e54:	de bf       	out	0x3e, r29	; 62
     e56:	ff 91       	pop	r31
     e58:	ef 91       	pop	r30
     e5a:	df 91       	pop	r29
     e5c:	cf 91       	pop	r28
     e5e:	bf 91       	pop	r27
     e60:	af 91       	pop	r26
     e62:	9f 91       	pop	r25
     e64:	8f 91       	pop	r24
     e66:	7f 91       	pop	r23
     e68:	6f 91       	pop	r22
     e6a:	5f 91       	pop	r21
     e6c:	4f 91       	pop	r20
     e6e:	3f 91       	pop	r19
     e70:	2f 91       	pop	r18
     e72:	1f 91       	pop	r17
     e74:	0f 91       	pop	r16
     e76:	ff 90       	pop	r15
     e78:	ef 90       	pop	r14
     e7a:	df 90       	pop	r13
     e7c:	cf 90       	pop	r12
     e7e:	bf 90       	pop	r11
     e80:	af 90       	pop	r10
     e82:	9f 90       	pop	r9
     e84:	8f 90       	pop	r8
     e86:	7f 90       	pop	r7
     e88:	6f 90       	pop	r6
     e8a:	5f 90       	pop	r5
     e8c:	4f 90       	pop	r4
     e8e:	3f 90       	pop	r3
     e90:	2f 90       	pop	r2
     e92:	1f 90       	pop	r1
     e94:	0f 90       	pop	r0
     e96:	0f be       	out	0x3f, r0	; 63
     e98:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     e9a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     e9c:	81 e0       	ldi	r24, 0x01	; 1
}
     e9e:	cf 91       	pop	r28
     ea0:	df 91       	pop	r29
     ea2:	08 95       	ret

00000ea4 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     ea4:	df 93       	push	r29
     ea6:	cf 93       	push	r28
     ea8:	cd b7       	in	r28, 0x3d	; 61
     eaa:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     eac:	cf 91       	pop	r28
     eae:	df 91       	pop	r29
     eb0:	08 95       	ret

00000eb2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     eb2:	0f 92       	push	r0
     eb4:	0f b6       	in	r0, 0x3f	; 63
     eb6:	f8 94       	cli
     eb8:	0f 92       	push	r0
     eba:	1f 92       	push	r1
     ebc:	11 24       	eor	r1, r1
     ebe:	2f 92       	push	r2
     ec0:	3f 92       	push	r3
     ec2:	4f 92       	push	r4
     ec4:	5f 92       	push	r5
     ec6:	6f 92       	push	r6
     ec8:	7f 92       	push	r7
     eca:	8f 92       	push	r8
     ecc:	9f 92       	push	r9
     ece:	af 92       	push	r10
     ed0:	bf 92       	push	r11
     ed2:	cf 92       	push	r12
     ed4:	df 92       	push	r13
     ed6:	ef 92       	push	r14
     ed8:	ff 92       	push	r15
     eda:	0f 93       	push	r16
     edc:	1f 93       	push	r17
     ede:	2f 93       	push	r18
     ee0:	3f 93       	push	r19
     ee2:	4f 93       	push	r20
     ee4:	5f 93       	push	r21
     ee6:	6f 93       	push	r22
     ee8:	7f 93       	push	r23
     eea:	8f 93       	push	r24
     eec:	9f 93       	push	r25
     eee:	af 93       	push	r26
     ef0:	bf 93       	push	r27
     ef2:	cf 93       	push	r28
     ef4:	df 93       	push	r29
     ef6:	ef 93       	push	r30
     ef8:	ff 93       	push	r31
     efa:	a0 91 14 03 	lds	r26, 0x0314
     efe:	b0 91 15 03 	lds	r27, 0x0315
     f02:	0d b6       	in	r0, 0x3d	; 61
     f04:	0d 92       	st	X+, r0
     f06:	0e b6       	in	r0, 0x3e	; 62
     f08:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     f0a:	0e 94 a8 11 	call	0x2350	; 0x2350 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     f0e:	a0 91 14 03 	lds	r26, 0x0314
     f12:	b0 91 15 03 	lds	r27, 0x0315
     f16:	cd 91       	ld	r28, X+
     f18:	cd bf       	out	0x3d, r28	; 61
     f1a:	dd 91       	ld	r29, X+
     f1c:	de bf       	out	0x3e, r29	; 62
     f1e:	ff 91       	pop	r31
     f20:	ef 91       	pop	r30
     f22:	df 91       	pop	r29
     f24:	cf 91       	pop	r28
     f26:	bf 91       	pop	r27
     f28:	af 91       	pop	r26
     f2a:	9f 91       	pop	r25
     f2c:	8f 91       	pop	r24
     f2e:	7f 91       	pop	r23
     f30:	6f 91       	pop	r22
     f32:	5f 91       	pop	r21
     f34:	4f 91       	pop	r20
     f36:	3f 91       	pop	r19
     f38:	2f 91       	pop	r18
     f3a:	1f 91       	pop	r17
     f3c:	0f 91       	pop	r16
     f3e:	ff 90       	pop	r15
     f40:	ef 90       	pop	r14
     f42:	df 90       	pop	r13
     f44:	cf 90       	pop	r12
     f46:	bf 90       	pop	r11
     f48:	af 90       	pop	r10
     f4a:	9f 90       	pop	r9
     f4c:	8f 90       	pop	r8
     f4e:	7f 90       	pop	r7
     f50:	6f 90       	pop	r6
     f52:	5f 90       	pop	r5
     f54:	4f 90       	pop	r4
     f56:	3f 90       	pop	r3
     f58:	2f 90       	pop	r2
     f5a:	1f 90       	pop	r1
     f5c:	0f 90       	pop	r0
     f5e:	0f be       	out	0x3f, r0	; 63
     f60:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f62:	08 95       	ret

00000f64 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     f64:	0f 92       	push	r0
     f66:	0f b6       	in	r0, 0x3f	; 63
     f68:	f8 94       	cli
     f6a:	0f 92       	push	r0
     f6c:	1f 92       	push	r1
     f6e:	11 24       	eor	r1, r1
     f70:	2f 92       	push	r2
     f72:	3f 92       	push	r3
     f74:	4f 92       	push	r4
     f76:	5f 92       	push	r5
     f78:	6f 92       	push	r6
     f7a:	7f 92       	push	r7
     f7c:	8f 92       	push	r8
     f7e:	9f 92       	push	r9
     f80:	af 92       	push	r10
     f82:	bf 92       	push	r11
     f84:	cf 92       	push	r12
     f86:	df 92       	push	r13
     f88:	ef 92       	push	r14
     f8a:	ff 92       	push	r15
     f8c:	0f 93       	push	r16
     f8e:	1f 93       	push	r17
     f90:	2f 93       	push	r18
     f92:	3f 93       	push	r19
     f94:	4f 93       	push	r20
     f96:	5f 93       	push	r21
     f98:	6f 93       	push	r22
     f9a:	7f 93       	push	r23
     f9c:	8f 93       	push	r24
     f9e:	9f 93       	push	r25
     fa0:	af 93       	push	r26
     fa2:	bf 93       	push	r27
     fa4:	cf 93       	push	r28
     fa6:	df 93       	push	r29
     fa8:	ef 93       	push	r30
     faa:	ff 93       	push	r31
     fac:	a0 91 14 03 	lds	r26, 0x0314
     fb0:	b0 91 15 03 	lds	r27, 0x0315
     fb4:	0d b6       	in	r0, 0x3d	; 61
     fb6:	0d 92       	st	X+, r0
     fb8:	0e b6       	in	r0, 0x3e	; 62
     fba:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     fbc:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <vTaskIncrementTick>
	vTaskSwitchContext();
     fc0:	0e 94 a8 11 	call	0x2350	; 0x2350 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     fc4:	a0 91 14 03 	lds	r26, 0x0314
     fc8:	b0 91 15 03 	lds	r27, 0x0315
     fcc:	cd 91       	ld	r28, X+
     fce:	cd bf       	out	0x3d, r28	; 61
     fd0:	dd 91       	ld	r29, X+
     fd2:	de bf       	out	0x3e, r29	; 62
     fd4:	ff 91       	pop	r31
     fd6:	ef 91       	pop	r30
     fd8:	df 91       	pop	r29
     fda:	cf 91       	pop	r28
     fdc:	bf 91       	pop	r27
     fde:	af 91       	pop	r26
     fe0:	9f 91       	pop	r25
     fe2:	8f 91       	pop	r24
     fe4:	7f 91       	pop	r23
     fe6:	6f 91       	pop	r22
     fe8:	5f 91       	pop	r21
     fea:	4f 91       	pop	r20
     fec:	3f 91       	pop	r19
     fee:	2f 91       	pop	r18
     ff0:	1f 91       	pop	r17
     ff2:	0f 91       	pop	r16
     ff4:	ff 90       	pop	r15
     ff6:	ef 90       	pop	r14
     ff8:	df 90       	pop	r13
     ffa:	cf 90       	pop	r12
     ffc:	bf 90       	pop	r11
     ffe:	af 90       	pop	r10
    1000:	9f 90       	pop	r9
    1002:	8f 90       	pop	r8
    1004:	7f 90       	pop	r7
    1006:	6f 90       	pop	r6
    1008:	5f 90       	pop	r5
    100a:	4f 90       	pop	r4
    100c:	3f 90       	pop	r3
    100e:	2f 90       	pop	r2
    1010:	1f 90       	pop	r1
    1012:	0f 90       	pop	r0
    1014:	0f be       	out	0x3f, r0	; 63
    1016:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1018:	08 95       	ret

0000101a <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    101a:	df 93       	push	r29
    101c:	cf 93       	push	r28
    101e:	00 d0       	rcall	.+0      	; 0x1020 <prvSetupTimerInterrupt+0x6>
    1020:	00 d0       	rcall	.+0      	; 0x1022 <prvSetupTimerInterrupt+0x8>
    1022:	00 d0       	rcall	.+0      	; 0x1024 <prvSetupTimerInterrupt+0xa>
    1024:	cd b7       	in	r28, 0x3d	; 61
    1026:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1028:	80 e4       	ldi	r24, 0x40	; 64
    102a:	9f e1       	ldi	r25, 0x1F	; 31
    102c:	a0 e0       	ldi	r26, 0x00	; 0
    102e:	b0 e0       	ldi	r27, 0x00	; 0
    1030:	8b 83       	std	Y+3, r24	; 0x03
    1032:	9c 83       	std	Y+4, r25	; 0x04
    1034:	ad 83       	std	Y+5, r26	; 0x05
    1036:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1038:	8b 81       	ldd	r24, Y+3	; 0x03
    103a:	9c 81       	ldd	r25, Y+4	; 0x04
    103c:	ad 81       	ldd	r26, Y+5	; 0x05
    103e:	be 81       	ldd	r27, Y+6	; 0x06
    1040:	68 94       	set
    1042:	15 f8       	bld	r1, 5
    1044:	b6 95       	lsr	r27
    1046:	a7 95       	ror	r26
    1048:	97 95       	ror	r25
    104a:	87 95       	ror	r24
    104c:	16 94       	lsr	r1
    104e:	d1 f7       	brne	.-12     	; 0x1044 <prvSetupTimerInterrupt+0x2a>
    1050:	8b 83       	std	Y+3, r24	; 0x03
    1052:	9c 83       	std	Y+4, r25	; 0x04
    1054:	ad 83       	std	Y+5, r26	; 0x05
    1056:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    1058:	8b 81       	ldd	r24, Y+3	; 0x03
    105a:	9c 81       	ldd	r25, Y+4	; 0x04
    105c:	ad 81       	ldd	r26, Y+5	; 0x05
    105e:	be 81       	ldd	r27, Y+6	; 0x06
    1060:	01 97       	sbiw	r24, 0x01	; 1
    1062:	a1 09       	sbc	r26, r1
    1064:	b1 09       	sbc	r27, r1
    1066:	8b 83       	std	Y+3, r24	; 0x03
    1068:	9c 83       	std	Y+4, r25	; 0x04
    106a:	ad 83       	std	Y+5, r26	; 0x05
    106c:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    106e:	8b 81       	ldd	r24, Y+3	; 0x03
    1070:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1072:	8b 81       	ldd	r24, Y+3	; 0x03
    1074:	9c 81       	ldd	r25, Y+4	; 0x04
    1076:	ad 81       	ldd	r26, Y+5	; 0x05
    1078:	be 81       	ldd	r27, Y+6	; 0x06
    107a:	89 2f       	mov	r24, r25
    107c:	9a 2f       	mov	r25, r26
    107e:	ab 2f       	mov	r26, r27
    1080:	bb 27       	eor	r27, r27
    1082:	8b 83       	std	Y+3, r24	; 0x03
    1084:	9c 83       	std	Y+4, r25	; 0x04
    1086:	ad 83       	std	Y+5, r26	; 0x05
    1088:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    108a:	8b 81       	ldd	r24, Y+3	; 0x03
    108c:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    108e:	eb e4       	ldi	r30, 0x4B	; 75
    1090:	f0 e0       	ldi	r31, 0x00	; 0
    1092:	8a 81       	ldd	r24, Y+2	; 0x02
    1094:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1096:	ea e4       	ldi	r30, 0x4A	; 74
    1098:	f0 e0       	ldi	r31, 0x00	; 0
    109a:	89 81       	ldd	r24, Y+1	; 0x01
    109c:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    109e:	8b e0       	ldi	r24, 0x0B	; 11
    10a0:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    10a2:	ee e4       	ldi	r30, 0x4E	; 78
    10a4:	f0 e0       	ldi	r31, 0x00	; 0
    10a6:	89 81       	ldd	r24, Y+1	; 0x01
    10a8:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    10aa:	e9 e5       	ldi	r30, 0x59	; 89
    10ac:	f0 e0       	ldi	r31, 0x00	; 0
    10ae:	80 81       	ld	r24, Z
    10b0:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    10b2:	89 81       	ldd	r24, Y+1	; 0x01
    10b4:	80 61       	ori	r24, 0x10	; 16
    10b6:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    10b8:	e9 e5       	ldi	r30, 0x59	; 89
    10ba:	f0 e0       	ldi	r31, 0x00	; 0
    10bc:	89 81       	ldd	r24, Y+1	; 0x01
    10be:	80 83       	st	Z, r24
}
    10c0:	26 96       	adiw	r28, 0x06	; 6
    10c2:	0f b6       	in	r0, 0x3f	; 63
    10c4:	f8 94       	cli
    10c6:	de bf       	out	0x3e, r29	; 62
    10c8:	0f be       	out	0x3f, r0	; 63
    10ca:	cd bf       	out	0x3d, r28	; 61
    10cc:	cf 91       	pop	r28
    10ce:	df 91       	pop	r29
    10d0:	08 95       	ret

000010d2 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    10d2:	0e 94 b2 07 	call	0xf64	; 0xf64 <vPortYieldFromTick>
		asm volatile ( "reti" );
    10d6:	18 95       	reti

000010d8 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    10d8:	df 93       	push	r29
    10da:	cf 93       	push	r28
    10dc:	cd b7       	in	r28, 0x3d	; 61
    10de:	de b7       	in	r29, 0x3e	; 62
    10e0:	28 97       	sbiw	r28, 0x08	; 8
    10e2:	0f b6       	in	r0, 0x3f	; 63
    10e4:	f8 94       	cli
    10e6:	de bf       	out	0x3e, r29	; 62
    10e8:	0f be       	out	0x3f, r0	; 63
    10ea:	cd bf       	out	0x3d, r28	; 61
    10ec:	8f 83       	std	Y+7, r24	; 0x07
    10ee:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    10f0:	1a 82       	std	Y+2, r1	; 0x02
    10f2:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    10f4:	8f 81       	ldd	r24, Y+7	; 0x07
    10f6:	88 23       	and	r24, r24
    10f8:	09 f4       	brne	.+2      	; 0x10fc <xQueueCreate+0x24>
    10fa:	8c c0       	rjmp	.+280    	; 0x1214 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    10fc:	8f e1       	ldi	r24, 0x1F	; 31
    10fe:	90 e0       	ldi	r25, 0x00	; 0
    1100:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <pvPortMalloc>
    1104:	9e 83       	std	Y+6, r25	; 0x06
    1106:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1108:	8d 81       	ldd	r24, Y+5	; 0x05
    110a:	9e 81       	ldd	r25, Y+6	; 0x06
    110c:	00 97       	sbiw	r24, 0x00	; 0
    110e:	09 f4       	brne	.+2      	; 0x1112 <xQueueCreate+0x3a>
    1110:	81 c0       	rjmp	.+258    	; 0x1214 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1112:	8f 81       	ldd	r24, Y+7	; 0x07
    1114:	28 2f       	mov	r18, r24
    1116:	30 e0       	ldi	r19, 0x00	; 0
    1118:	88 85       	ldd	r24, Y+8	; 0x08
    111a:	88 2f       	mov	r24, r24
    111c:	90 e0       	ldi	r25, 0x00	; 0
    111e:	ac 01       	movw	r20, r24
    1120:	24 9f       	mul	r18, r20
    1122:	c0 01       	movw	r24, r0
    1124:	25 9f       	mul	r18, r21
    1126:	90 0d       	add	r25, r0
    1128:	34 9f       	mul	r19, r20
    112a:	90 0d       	add	r25, r0
    112c:	11 24       	eor	r1, r1
    112e:	01 96       	adiw	r24, 0x01	; 1
    1130:	9c 83       	std	Y+4, r25	; 0x04
    1132:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1134:	8b 81       	ldd	r24, Y+3	; 0x03
    1136:	9c 81       	ldd	r25, Y+4	; 0x04
    1138:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <pvPortMalloc>
    113c:	ed 81       	ldd	r30, Y+5	; 0x05
    113e:	fe 81       	ldd	r31, Y+6	; 0x06
    1140:	91 83       	std	Z+1, r25	; 0x01
    1142:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    1144:	ed 81       	ldd	r30, Y+5	; 0x05
    1146:	fe 81       	ldd	r31, Y+6	; 0x06
    1148:	80 81       	ld	r24, Z
    114a:	91 81       	ldd	r25, Z+1	; 0x01
    114c:	00 97       	sbiw	r24, 0x00	; 0
    114e:	09 f4       	brne	.+2      	; 0x1152 <xQueueCreate+0x7a>
    1150:	5d c0       	rjmp	.+186    	; 0x120c <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1152:	ed 81       	ldd	r30, Y+5	; 0x05
    1154:	fe 81       	ldd	r31, Y+6	; 0x06
    1156:	40 81       	ld	r20, Z
    1158:	51 81       	ldd	r21, Z+1	; 0x01
    115a:	8f 81       	ldd	r24, Y+7	; 0x07
    115c:	28 2f       	mov	r18, r24
    115e:	30 e0       	ldi	r19, 0x00	; 0
    1160:	88 85       	ldd	r24, Y+8	; 0x08
    1162:	88 2f       	mov	r24, r24
    1164:	90 e0       	ldi	r25, 0x00	; 0
    1166:	bc 01       	movw	r22, r24
    1168:	26 9f       	mul	r18, r22
    116a:	c0 01       	movw	r24, r0
    116c:	27 9f       	mul	r18, r23
    116e:	90 0d       	add	r25, r0
    1170:	36 9f       	mul	r19, r22
    1172:	90 0d       	add	r25, r0
    1174:	11 24       	eor	r1, r1
    1176:	84 0f       	add	r24, r20
    1178:	95 1f       	adc	r25, r21
    117a:	ed 81       	ldd	r30, Y+5	; 0x05
    117c:	fe 81       	ldd	r31, Y+6	; 0x06
    117e:	93 83       	std	Z+3, r25	; 0x03
    1180:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1182:	ed 81       	ldd	r30, Y+5	; 0x05
    1184:	fe 81       	ldd	r31, Y+6	; 0x06
    1186:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1188:	ed 81       	ldd	r30, Y+5	; 0x05
    118a:	fe 81       	ldd	r31, Y+6	; 0x06
    118c:	80 81       	ld	r24, Z
    118e:	91 81       	ldd	r25, Z+1	; 0x01
    1190:	ed 81       	ldd	r30, Y+5	; 0x05
    1192:	fe 81       	ldd	r31, Y+6	; 0x06
    1194:	95 83       	std	Z+5, r25	; 0x05
    1196:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    1198:	ed 81       	ldd	r30, Y+5	; 0x05
    119a:	fe 81       	ldd	r31, Y+6	; 0x06
    119c:	40 81       	ld	r20, Z
    119e:	51 81       	ldd	r21, Z+1	; 0x01
    11a0:	8f 81       	ldd	r24, Y+7	; 0x07
    11a2:	88 2f       	mov	r24, r24
    11a4:	90 e0       	ldi	r25, 0x00	; 0
    11a6:	9c 01       	movw	r18, r24
    11a8:	21 50       	subi	r18, 0x01	; 1
    11aa:	30 40       	sbci	r19, 0x00	; 0
    11ac:	88 85       	ldd	r24, Y+8	; 0x08
    11ae:	88 2f       	mov	r24, r24
    11b0:	90 e0       	ldi	r25, 0x00	; 0
    11b2:	bc 01       	movw	r22, r24
    11b4:	26 9f       	mul	r18, r22
    11b6:	c0 01       	movw	r24, r0
    11b8:	27 9f       	mul	r18, r23
    11ba:	90 0d       	add	r25, r0
    11bc:	36 9f       	mul	r19, r22
    11be:	90 0d       	add	r25, r0
    11c0:	11 24       	eor	r1, r1
    11c2:	84 0f       	add	r24, r20
    11c4:	95 1f       	adc	r25, r21
    11c6:	ed 81       	ldd	r30, Y+5	; 0x05
    11c8:	fe 81       	ldd	r31, Y+6	; 0x06
    11ca:	97 83       	std	Z+7, r25	; 0x07
    11cc:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    11ce:	ed 81       	ldd	r30, Y+5	; 0x05
    11d0:	fe 81       	ldd	r31, Y+6	; 0x06
    11d2:	8f 81       	ldd	r24, Y+7	; 0x07
    11d4:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    11d6:	ed 81       	ldd	r30, Y+5	; 0x05
    11d8:	fe 81       	ldd	r31, Y+6	; 0x06
    11da:	88 85       	ldd	r24, Y+8	; 0x08
    11dc:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    11de:	ed 81       	ldd	r30, Y+5	; 0x05
    11e0:	fe 81       	ldd	r31, Y+6	; 0x06
    11e2:	8f ef       	ldi	r24, 0xFF	; 255
    11e4:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    11e6:	ed 81       	ldd	r30, Y+5	; 0x05
    11e8:	fe 81       	ldd	r31, Y+6	; 0x06
    11ea:	8f ef       	ldi	r24, 0xFF	; 255
    11ec:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    11ee:	8d 81       	ldd	r24, Y+5	; 0x05
    11f0:	9e 81       	ldd	r25, Y+6	; 0x06
    11f2:	08 96       	adiw	r24, 0x08	; 8
    11f4:	0e 94 5f 04 	call	0x8be	; 0x8be <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    11f8:	8d 81       	ldd	r24, Y+5	; 0x05
    11fa:	9e 81       	ldd	r25, Y+6	; 0x06
    11fc:	41 96       	adiw	r24, 0x11	; 17
    11fe:	0e 94 5f 04 	call	0x8be	; 0x8be <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1202:	8d 81       	ldd	r24, Y+5	; 0x05
    1204:	9e 81       	ldd	r25, Y+6	; 0x06
    1206:	9a 83       	std	Y+2, r25	; 0x02
    1208:	89 83       	std	Y+1, r24	; 0x01
    120a:	04 c0       	rjmp	.+8      	; 0x1214 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    120c:	8d 81       	ldd	r24, Y+5	; 0x05
    120e:	9e 81       	ldd	r25, Y+6	; 0x06
    1210:	0e 94 39 04 	call	0x872	; 0x872 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1214:	89 81       	ldd	r24, Y+1	; 0x01
    1216:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1218:	28 96       	adiw	r28, 0x08	; 8
    121a:	0f b6       	in	r0, 0x3f	; 63
    121c:	f8 94       	cli
    121e:	de bf       	out	0x3e, r29	; 62
    1220:	0f be       	out	0x3f, r0	; 63
    1222:	cd bf       	out	0x3d, r28	; 61
    1224:	cf 91       	pop	r28
    1226:	df 91       	pop	r29
    1228:	08 95       	ret

0000122a <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    122a:	df 93       	push	r29
    122c:	cf 93       	push	r28
    122e:	cd b7       	in	r28, 0x3d	; 61
    1230:	de b7       	in	r29, 0x3e	; 62
    1232:	2c 97       	sbiw	r28, 0x0c	; 12
    1234:	0f b6       	in	r0, 0x3f	; 63
    1236:	f8 94       	cli
    1238:	de bf       	out	0x3e, r29	; 62
    123a:	0f be       	out	0x3f, r0	; 63
    123c:	cd bf       	out	0x3d, r28	; 61
    123e:	9e 83       	std	Y+6, r25	; 0x06
    1240:	8d 83       	std	Y+5, r24	; 0x05
    1242:	78 87       	std	Y+8, r23	; 0x08
    1244:	6f 83       	std	Y+7, r22	; 0x07
    1246:	5a 87       	std	Y+10, r21	; 0x0a
    1248:	49 87       	std	Y+9, r20	; 0x09
    124a:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    124c:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    124e:	0f b6       	in	r0, 0x3f	; 63
    1250:	f8 94       	cli
    1252:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1254:	ed 81       	ldd	r30, Y+5	; 0x05
    1256:	fe 81       	ldd	r31, Y+6	; 0x06
    1258:	92 8d       	ldd	r25, Z+26	; 0x1a
    125a:	ed 81       	ldd	r30, Y+5	; 0x05
    125c:	fe 81       	ldd	r31, Y+6	; 0x06
    125e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1260:	98 17       	cp	r25, r24
    1262:	d8 f4       	brcc	.+54     	; 0x129a <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1264:	8d 81       	ldd	r24, Y+5	; 0x05
    1266:	9e 81       	ldd	r25, Y+6	; 0x06
    1268:	2f 81       	ldd	r18, Y+7	; 0x07
    126a:	38 85       	ldd	r19, Y+8	; 0x08
    126c:	b9 01       	movw	r22, r18
    126e:	4b 85       	ldd	r20, Y+11	; 0x0b
    1270:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1274:	ed 81       	ldd	r30, Y+5	; 0x05
    1276:	fe 81       	ldd	r31, Y+6	; 0x06
    1278:	81 89       	ldd	r24, Z+17	; 0x11
    127a:	88 23       	and	r24, r24
    127c:	49 f0       	breq	.+18     	; 0x1290 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    127e:	8d 81       	ldd	r24, Y+5	; 0x05
    1280:	9e 81       	ldd	r25, Y+6	; 0x06
    1282:	41 96       	adiw	r24, 0x11	; 17
    1284:	0e 94 44 12 	call	0x2488	; 0x2488 <xTaskRemoveFromEventList>
    1288:	81 30       	cpi	r24, 0x01	; 1
    128a:	11 f4       	brne	.+4      	; 0x1290 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    128c:	0e 94 59 07 	call	0xeb2	; 0xeb2 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1290:	0f 90       	pop	r0
    1292:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1294:	81 e0       	ldi	r24, 0x01	; 1
    1296:	8c 87       	std	Y+12, r24	; 0x0c
    1298:	5c c0       	rjmp	.+184    	; 0x1352 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    129a:	89 85       	ldd	r24, Y+9	; 0x09
    129c:	9a 85       	ldd	r25, Y+10	; 0x0a
    129e:	00 97       	sbiw	r24, 0x00	; 0
    12a0:	21 f4       	brne	.+8      	; 0x12aa <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    12a2:	0f 90       	pop	r0
    12a4:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    12a6:	1c 86       	std	Y+12, r1	; 0x0c
    12a8:	54 c0       	rjmp	.+168    	; 0x1352 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    12aa:	89 81       	ldd	r24, Y+1	; 0x01
    12ac:	88 23       	and	r24, r24
    12ae:	31 f4       	brne	.+12     	; 0x12bc <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    12b0:	ce 01       	movw	r24, r28
    12b2:	02 96       	adiw	r24, 0x02	; 2
    12b4:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    12b8:	81 e0       	ldi	r24, 0x01	; 1
    12ba:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    12bc:	0f 90       	pop	r0
    12be:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    12c0:	0e 94 08 10 	call	0x2010	; 0x2010 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    12c4:	0f b6       	in	r0, 0x3f	; 63
    12c6:	f8 94       	cli
    12c8:	0f 92       	push	r0
    12ca:	ed 81       	ldd	r30, Y+5	; 0x05
    12cc:	fe 81       	ldd	r31, Y+6	; 0x06
    12ce:	85 8d       	ldd	r24, Z+29	; 0x1d
    12d0:	8f 3f       	cpi	r24, 0xFF	; 255
    12d2:	19 f4       	brne	.+6      	; 0x12da <xQueueGenericSend+0xb0>
    12d4:	ed 81       	ldd	r30, Y+5	; 0x05
    12d6:	fe 81       	ldd	r31, Y+6	; 0x06
    12d8:	15 8e       	std	Z+29, r1	; 0x1d
    12da:	ed 81       	ldd	r30, Y+5	; 0x05
    12dc:	fe 81       	ldd	r31, Y+6	; 0x06
    12de:	86 8d       	ldd	r24, Z+30	; 0x1e
    12e0:	8f 3f       	cpi	r24, 0xFF	; 255
    12e2:	19 f4       	brne	.+6      	; 0x12ea <xQueueGenericSend+0xc0>
    12e4:	ed 81       	ldd	r30, Y+5	; 0x05
    12e6:	fe 81       	ldd	r31, Y+6	; 0x06
    12e8:	16 8e       	std	Z+30, r1	; 0x1e
    12ea:	0f 90       	pop	r0
    12ec:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    12ee:	ce 01       	movw	r24, r28
    12f0:	02 96       	adiw	r24, 0x02	; 2
    12f2:	9e 01       	movw	r18, r28
    12f4:	27 5f       	subi	r18, 0xF7	; 247
    12f6:	3f 4f       	sbci	r19, 0xFF	; 255
    12f8:	b9 01       	movw	r22, r18
    12fa:	0e 94 c5 12 	call	0x258a	; 0x258a <xTaskCheckForTimeOut>
    12fe:	88 23       	and	r24, r24
    1300:	09 f5       	brne	.+66     	; 0x1344 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1302:	8d 81       	ldd	r24, Y+5	; 0x05
    1304:	9e 81       	ldd	r25, Y+6	; 0x06
    1306:	0e 94 b4 0c 	call	0x1968	; 0x1968 <prvIsQueueFull>
    130a:	88 23       	and	r24, r24
    130c:	a1 f0       	breq	.+40     	; 0x1336 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    130e:	8d 81       	ldd	r24, Y+5	; 0x05
    1310:	9e 81       	ldd	r25, Y+6	; 0x06
    1312:	08 96       	adiw	r24, 0x08	; 8
    1314:	29 85       	ldd	r18, Y+9	; 0x09
    1316:	3a 85       	ldd	r19, Y+10	; 0x0a
    1318:	b9 01       	movw	r22, r18
    131a:	0e 94 0e 12 	call	0x241c	; 0x241c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    131e:	8d 81       	ldd	r24, Y+5	; 0x05
    1320:	9e 81       	ldd	r25, Y+6	; 0x06
    1322:	0e 94 2d 0c 	call	0x185a	; 0x185a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1326:	0e 94 14 10 	call	0x2028	; 0x2028 <xTaskResumeAll>
    132a:	88 23       	and	r24, r24
    132c:	09 f0       	breq	.+2      	; 0x1330 <xQueueGenericSend+0x106>
    132e:	8f cf       	rjmp	.-226    	; 0x124e <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    1330:	0e 94 59 07 	call	0xeb2	; 0xeb2 <vPortYield>
    1334:	8c cf       	rjmp	.-232    	; 0x124e <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1336:	8d 81       	ldd	r24, Y+5	; 0x05
    1338:	9e 81       	ldd	r25, Y+6	; 0x06
    133a:	0e 94 2d 0c 	call	0x185a	; 0x185a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    133e:	0e 94 14 10 	call	0x2028	; 0x2028 <xTaskResumeAll>
    1342:	85 cf       	rjmp	.-246    	; 0x124e <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1344:	8d 81       	ldd	r24, Y+5	; 0x05
    1346:	9e 81       	ldd	r25, Y+6	; 0x06
    1348:	0e 94 2d 0c 	call	0x185a	; 0x185a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    134c:	0e 94 14 10 	call	0x2028	; 0x2028 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1350:	1c 86       	std	Y+12, r1	; 0x0c
    1352:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    1354:	2c 96       	adiw	r28, 0x0c	; 12
    1356:	0f b6       	in	r0, 0x3f	; 63
    1358:	f8 94       	cli
    135a:	de bf       	out	0x3e, r29	; 62
    135c:	0f be       	out	0x3f, r0	; 63
    135e:	cd bf       	out	0x3d, r28	; 61
    1360:	cf 91       	pop	r28
    1362:	df 91       	pop	r29
    1364:	08 95       	ret

00001366 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1366:	df 93       	push	r29
    1368:	cf 93       	push	r28
    136a:	cd b7       	in	r28, 0x3d	; 61
    136c:	de b7       	in	r29, 0x3e	; 62
    136e:	29 97       	sbiw	r28, 0x09	; 9
    1370:	0f b6       	in	r0, 0x3f	; 63
    1372:	f8 94       	cli
    1374:	de bf       	out	0x3e, r29	; 62
    1376:	0f be       	out	0x3f, r0	; 63
    1378:	cd bf       	out	0x3d, r28	; 61
    137a:	9c 83       	std	Y+4, r25	; 0x04
    137c:	8b 83       	std	Y+3, r24	; 0x03
    137e:	7e 83       	std	Y+6, r23	; 0x06
    1380:	6d 83       	std	Y+5, r22	; 0x05
    1382:	58 87       	std	Y+8, r21	; 0x08
    1384:	4f 83       	std	Y+7, r20	; 0x07
    1386:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1388:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    138a:	eb 81       	ldd	r30, Y+3	; 0x03
    138c:	fc 81       	ldd	r31, Y+4	; 0x04
    138e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1390:	eb 81       	ldd	r30, Y+3	; 0x03
    1392:	fc 81       	ldd	r31, Y+4	; 0x04
    1394:	83 8d       	ldd	r24, Z+27	; 0x1b
    1396:	98 17       	cp	r25, r24
    1398:	40 f5       	brcc	.+80     	; 0x13ea <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    139a:	8b 81       	ldd	r24, Y+3	; 0x03
    139c:	9c 81       	ldd	r25, Y+4	; 0x04
    139e:	2d 81       	ldd	r18, Y+5	; 0x05
    13a0:	3e 81       	ldd	r19, Y+6	; 0x06
    13a2:	b9 01       	movw	r22, r18
    13a4:	49 85       	ldd	r20, Y+9	; 0x09
    13a6:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    13aa:	eb 81       	ldd	r30, Y+3	; 0x03
    13ac:	fc 81       	ldd	r31, Y+4	; 0x04
    13ae:	86 8d       	ldd	r24, Z+30	; 0x1e
    13b0:	8f 3f       	cpi	r24, 0xFF	; 255
    13b2:	89 f4       	brne	.+34     	; 0x13d6 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13b4:	eb 81       	ldd	r30, Y+3	; 0x03
    13b6:	fc 81       	ldd	r31, Y+4	; 0x04
    13b8:	81 89       	ldd	r24, Z+17	; 0x11
    13ba:	88 23       	and	r24, r24
    13bc:	99 f0       	breq	.+38     	; 0x13e4 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13be:	8b 81       	ldd	r24, Y+3	; 0x03
    13c0:	9c 81       	ldd	r25, Y+4	; 0x04
    13c2:	41 96       	adiw	r24, 0x11	; 17
    13c4:	0e 94 44 12 	call	0x2488	; 0x2488 <xTaskRemoveFromEventList>
    13c8:	88 23       	and	r24, r24
    13ca:	61 f0       	breq	.+24     	; 0x13e4 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    13cc:	ef 81       	ldd	r30, Y+7	; 0x07
    13ce:	f8 85       	ldd	r31, Y+8	; 0x08
    13d0:	81 e0       	ldi	r24, 0x01	; 1
    13d2:	80 83       	st	Z, r24
    13d4:	07 c0       	rjmp	.+14     	; 0x13e4 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    13d6:	eb 81       	ldd	r30, Y+3	; 0x03
    13d8:	fc 81       	ldd	r31, Y+4	; 0x04
    13da:	86 8d       	ldd	r24, Z+30	; 0x1e
    13dc:	8f 5f       	subi	r24, 0xFF	; 255
    13de:	eb 81       	ldd	r30, Y+3	; 0x03
    13e0:	fc 81       	ldd	r31, Y+4	; 0x04
    13e2:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    13e4:	81 e0       	ldi	r24, 0x01	; 1
    13e6:	8a 83       	std	Y+2, r24	; 0x02
    13e8:	01 c0       	rjmp	.+2      	; 0x13ec <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    13ea:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    13ec:	8a 81       	ldd	r24, Y+2	; 0x02
}
    13ee:	29 96       	adiw	r28, 0x09	; 9
    13f0:	0f b6       	in	r0, 0x3f	; 63
    13f2:	f8 94       	cli
    13f4:	de bf       	out	0x3e, r29	; 62
    13f6:	0f be       	out	0x3f, r0	; 63
    13f8:	cd bf       	out	0x3d, r28	; 61
    13fa:	cf 91       	pop	r28
    13fc:	df 91       	pop	r29
    13fe:	08 95       	ret

00001400 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1400:	df 93       	push	r29
    1402:	cf 93       	push	r28
    1404:	cd b7       	in	r28, 0x3d	; 61
    1406:	de b7       	in	r29, 0x3e	; 62
    1408:	2e 97       	sbiw	r28, 0x0e	; 14
    140a:	0f b6       	in	r0, 0x3f	; 63
    140c:	f8 94       	cli
    140e:	de bf       	out	0x3e, r29	; 62
    1410:	0f be       	out	0x3f, r0	; 63
    1412:	cd bf       	out	0x3d, r28	; 61
    1414:	98 87       	std	Y+8, r25	; 0x08
    1416:	8f 83       	std	Y+7, r24	; 0x07
    1418:	7a 87       	std	Y+10, r23	; 0x0a
    141a:	69 87       	std	Y+9, r22	; 0x09
    141c:	5c 87       	std	Y+12, r21	; 0x0c
    141e:	4b 87       	std	Y+11, r20	; 0x0b
    1420:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1422:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1424:	0f b6       	in	r0, 0x3f	; 63
    1426:	f8 94       	cli
    1428:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    142a:	ef 81       	ldd	r30, Y+7	; 0x07
    142c:	f8 85       	ldd	r31, Y+8	; 0x08
    142e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1430:	88 23       	and	r24, r24
    1432:	09 f4       	brne	.+2      	; 0x1436 <xQueueGenericReceive+0x36>
    1434:	3f c0       	rjmp	.+126    	; 0x14b4 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1436:	ef 81       	ldd	r30, Y+7	; 0x07
    1438:	f8 85       	ldd	r31, Y+8	; 0x08
    143a:	86 81       	ldd	r24, Z+6	; 0x06
    143c:	97 81       	ldd	r25, Z+7	; 0x07
    143e:	9a 83       	std	Y+2, r25	; 0x02
    1440:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1442:	8f 81       	ldd	r24, Y+7	; 0x07
    1444:	98 85       	ldd	r25, Y+8	; 0x08
    1446:	29 85       	ldd	r18, Y+9	; 0x09
    1448:	3a 85       	ldd	r19, Y+10	; 0x0a
    144a:	b9 01       	movw	r22, r18
    144c:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1450:	8d 85       	ldd	r24, Y+13	; 0x0d
    1452:	88 23       	and	r24, r24
    1454:	b1 f4       	brne	.+44     	; 0x1482 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1456:	ef 81       	ldd	r30, Y+7	; 0x07
    1458:	f8 85       	ldd	r31, Y+8	; 0x08
    145a:	82 8d       	ldd	r24, Z+26	; 0x1a
    145c:	81 50       	subi	r24, 0x01	; 1
    145e:	ef 81       	ldd	r30, Y+7	; 0x07
    1460:	f8 85       	ldd	r31, Y+8	; 0x08
    1462:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1464:	ef 81       	ldd	r30, Y+7	; 0x07
    1466:	f8 85       	ldd	r31, Y+8	; 0x08
    1468:	80 85       	ldd	r24, Z+8	; 0x08
    146a:	88 23       	and	r24, r24
    146c:	f1 f0       	breq	.+60     	; 0x14aa <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    146e:	8f 81       	ldd	r24, Y+7	; 0x07
    1470:	98 85       	ldd	r25, Y+8	; 0x08
    1472:	08 96       	adiw	r24, 0x08	; 8
    1474:	0e 94 44 12 	call	0x2488	; 0x2488 <xTaskRemoveFromEventList>
    1478:	81 30       	cpi	r24, 0x01	; 1
    147a:	b9 f4       	brne	.+46     	; 0x14aa <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    147c:	0e 94 59 07 	call	0xeb2	; 0xeb2 <vPortYield>
    1480:	14 c0       	rjmp	.+40     	; 0x14aa <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1482:	ef 81       	ldd	r30, Y+7	; 0x07
    1484:	f8 85       	ldd	r31, Y+8	; 0x08
    1486:	89 81       	ldd	r24, Y+1	; 0x01
    1488:	9a 81       	ldd	r25, Y+2	; 0x02
    148a:	97 83       	std	Z+7, r25	; 0x07
    148c:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    148e:	ef 81       	ldd	r30, Y+7	; 0x07
    1490:	f8 85       	ldd	r31, Y+8	; 0x08
    1492:	81 89       	ldd	r24, Z+17	; 0x11
    1494:	88 23       	and	r24, r24
    1496:	49 f0       	breq	.+18     	; 0x14aa <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1498:	8f 81       	ldd	r24, Y+7	; 0x07
    149a:	98 85       	ldd	r25, Y+8	; 0x08
    149c:	41 96       	adiw	r24, 0x11	; 17
    149e:	0e 94 44 12 	call	0x2488	; 0x2488 <xTaskRemoveFromEventList>
    14a2:	88 23       	and	r24, r24
    14a4:	11 f0       	breq	.+4      	; 0x14aa <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    14a6:	0e 94 59 07 	call	0xeb2	; 0xeb2 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    14aa:	0f 90       	pop	r0
    14ac:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    14ae:	81 e0       	ldi	r24, 0x01	; 1
    14b0:	8e 87       	std	Y+14, r24	; 0x0e
    14b2:	5c c0       	rjmp	.+184    	; 0x156c <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    14b4:	8b 85       	ldd	r24, Y+11	; 0x0b
    14b6:	9c 85       	ldd	r25, Y+12	; 0x0c
    14b8:	00 97       	sbiw	r24, 0x00	; 0
    14ba:	21 f4       	brne	.+8      	; 0x14c4 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    14bc:	0f 90       	pop	r0
    14be:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    14c0:	1e 86       	std	Y+14, r1	; 0x0e
    14c2:	54 c0       	rjmp	.+168    	; 0x156c <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    14c4:	8b 81       	ldd	r24, Y+3	; 0x03
    14c6:	88 23       	and	r24, r24
    14c8:	31 f4       	brne	.+12     	; 0x14d6 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    14ca:	ce 01       	movw	r24, r28
    14cc:	04 96       	adiw	r24, 0x04	; 4
    14ce:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    14d2:	81 e0       	ldi	r24, 0x01	; 1
    14d4:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    14d6:	0f 90       	pop	r0
    14d8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    14da:	0e 94 08 10 	call	0x2010	; 0x2010 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    14de:	0f b6       	in	r0, 0x3f	; 63
    14e0:	f8 94       	cli
    14e2:	0f 92       	push	r0
    14e4:	ef 81       	ldd	r30, Y+7	; 0x07
    14e6:	f8 85       	ldd	r31, Y+8	; 0x08
    14e8:	85 8d       	ldd	r24, Z+29	; 0x1d
    14ea:	8f 3f       	cpi	r24, 0xFF	; 255
    14ec:	19 f4       	brne	.+6      	; 0x14f4 <xQueueGenericReceive+0xf4>
    14ee:	ef 81       	ldd	r30, Y+7	; 0x07
    14f0:	f8 85       	ldd	r31, Y+8	; 0x08
    14f2:	15 8e       	std	Z+29, r1	; 0x1d
    14f4:	ef 81       	ldd	r30, Y+7	; 0x07
    14f6:	f8 85       	ldd	r31, Y+8	; 0x08
    14f8:	86 8d       	ldd	r24, Z+30	; 0x1e
    14fa:	8f 3f       	cpi	r24, 0xFF	; 255
    14fc:	19 f4       	brne	.+6      	; 0x1504 <xQueueGenericReceive+0x104>
    14fe:	ef 81       	ldd	r30, Y+7	; 0x07
    1500:	f8 85       	ldd	r31, Y+8	; 0x08
    1502:	16 8e       	std	Z+30, r1	; 0x1e
    1504:	0f 90       	pop	r0
    1506:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1508:	ce 01       	movw	r24, r28
    150a:	04 96       	adiw	r24, 0x04	; 4
    150c:	9e 01       	movw	r18, r28
    150e:	25 5f       	subi	r18, 0xF5	; 245
    1510:	3f 4f       	sbci	r19, 0xFF	; 255
    1512:	b9 01       	movw	r22, r18
    1514:	0e 94 c5 12 	call	0x258a	; 0x258a <xTaskCheckForTimeOut>
    1518:	88 23       	and	r24, r24
    151a:	09 f5       	brne	.+66     	; 0x155e <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    151c:	8f 81       	ldd	r24, Y+7	; 0x07
    151e:	98 85       	ldd	r25, Y+8	; 0x08
    1520:	0e 94 81 0c 	call	0x1902	; 0x1902 <prvIsQueueEmpty>
    1524:	88 23       	and	r24, r24
    1526:	a1 f0       	breq	.+40     	; 0x1550 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1528:	8f 81       	ldd	r24, Y+7	; 0x07
    152a:	98 85       	ldd	r25, Y+8	; 0x08
    152c:	41 96       	adiw	r24, 0x11	; 17
    152e:	2b 85       	ldd	r18, Y+11	; 0x0b
    1530:	3c 85       	ldd	r19, Y+12	; 0x0c
    1532:	b9 01       	movw	r22, r18
    1534:	0e 94 0e 12 	call	0x241c	; 0x241c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1538:	8f 81       	ldd	r24, Y+7	; 0x07
    153a:	98 85       	ldd	r25, Y+8	; 0x08
    153c:	0e 94 2d 0c 	call	0x185a	; 0x185a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1540:	0e 94 14 10 	call	0x2028	; 0x2028 <xTaskResumeAll>
    1544:	88 23       	and	r24, r24
    1546:	09 f0       	breq	.+2      	; 0x154a <xQueueGenericReceive+0x14a>
    1548:	6d cf       	rjmp	.-294    	; 0x1424 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    154a:	0e 94 59 07 	call	0xeb2	; 0xeb2 <vPortYield>
    154e:	6a cf       	rjmp	.-300    	; 0x1424 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1550:	8f 81       	ldd	r24, Y+7	; 0x07
    1552:	98 85       	ldd	r25, Y+8	; 0x08
    1554:	0e 94 2d 0c 	call	0x185a	; 0x185a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1558:	0e 94 14 10 	call	0x2028	; 0x2028 <xTaskResumeAll>
    155c:	63 cf       	rjmp	.-314    	; 0x1424 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    155e:	8f 81       	ldd	r24, Y+7	; 0x07
    1560:	98 85       	ldd	r25, Y+8	; 0x08
    1562:	0e 94 2d 0c 	call	0x185a	; 0x185a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1566:	0e 94 14 10 	call	0x2028	; 0x2028 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    156a:	1e 86       	std	Y+14, r1	; 0x0e
    156c:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    156e:	2e 96       	adiw	r28, 0x0e	; 14
    1570:	0f b6       	in	r0, 0x3f	; 63
    1572:	f8 94       	cli
    1574:	de bf       	out	0x3e, r29	; 62
    1576:	0f be       	out	0x3f, r0	; 63
    1578:	cd bf       	out	0x3d, r28	; 61
    157a:	cf 91       	pop	r28
    157c:	df 91       	pop	r29
    157e:	08 95       	ret

00001580 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1580:	df 93       	push	r29
    1582:	cf 93       	push	r28
    1584:	cd b7       	in	r28, 0x3d	; 61
    1586:	de b7       	in	r29, 0x3e	; 62
    1588:	28 97       	sbiw	r28, 0x08	; 8
    158a:	0f b6       	in	r0, 0x3f	; 63
    158c:	f8 94       	cli
    158e:	de bf       	out	0x3e, r29	; 62
    1590:	0f be       	out	0x3f, r0	; 63
    1592:	cd bf       	out	0x3d, r28	; 61
    1594:	9c 83       	std	Y+4, r25	; 0x04
    1596:	8b 83       	std	Y+3, r24	; 0x03
    1598:	7e 83       	std	Y+6, r23	; 0x06
    159a:	6d 83       	std	Y+5, r22	; 0x05
    159c:	58 87       	std	Y+8, r21	; 0x08
    159e:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    15a0:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    15a2:	eb 81       	ldd	r30, Y+3	; 0x03
    15a4:	fc 81       	ldd	r31, Y+4	; 0x04
    15a6:	82 8d       	ldd	r24, Z+26	; 0x1a
    15a8:	88 23       	and	r24, r24
    15aa:	71 f1       	breq	.+92     	; 0x1608 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    15ac:	8b 81       	ldd	r24, Y+3	; 0x03
    15ae:	9c 81       	ldd	r25, Y+4	; 0x04
    15b0:	2d 81       	ldd	r18, Y+5	; 0x05
    15b2:	3e 81       	ldd	r19, Y+6	; 0x06
    15b4:	b9 01       	movw	r22, r18
    15b6:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    15ba:	eb 81       	ldd	r30, Y+3	; 0x03
    15bc:	fc 81       	ldd	r31, Y+4	; 0x04
    15be:	82 8d       	ldd	r24, Z+26	; 0x1a
    15c0:	81 50       	subi	r24, 0x01	; 1
    15c2:	eb 81       	ldd	r30, Y+3	; 0x03
    15c4:	fc 81       	ldd	r31, Y+4	; 0x04
    15c6:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    15c8:	eb 81       	ldd	r30, Y+3	; 0x03
    15ca:	fc 81       	ldd	r31, Y+4	; 0x04
    15cc:	85 8d       	ldd	r24, Z+29	; 0x1d
    15ce:	8f 3f       	cpi	r24, 0xFF	; 255
    15d0:	89 f4       	brne	.+34     	; 0x15f4 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    15d2:	eb 81       	ldd	r30, Y+3	; 0x03
    15d4:	fc 81       	ldd	r31, Y+4	; 0x04
    15d6:	80 85       	ldd	r24, Z+8	; 0x08
    15d8:	88 23       	and	r24, r24
    15da:	99 f0       	breq	.+38     	; 0x1602 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    15dc:	8b 81       	ldd	r24, Y+3	; 0x03
    15de:	9c 81       	ldd	r25, Y+4	; 0x04
    15e0:	08 96       	adiw	r24, 0x08	; 8
    15e2:	0e 94 44 12 	call	0x2488	; 0x2488 <xTaskRemoveFromEventList>
    15e6:	88 23       	and	r24, r24
    15e8:	61 f0       	breq	.+24     	; 0x1602 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    15ea:	ef 81       	ldd	r30, Y+7	; 0x07
    15ec:	f8 85       	ldd	r31, Y+8	; 0x08
    15ee:	81 e0       	ldi	r24, 0x01	; 1
    15f0:	80 83       	st	Z, r24
    15f2:	07 c0       	rjmp	.+14     	; 0x1602 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    15f4:	eb 81       	ldd	r30, Y+3	; 0x03
    15f6:	fc 81       	ldd	r31, Y+4	; 0x04
    15f8:	85 8d       	ldd	r24, Z+29	; 0x1d
    15fa:	8f 5f       	subi	r24, 0xFF	; 255
    15fc:	eb 81       	ldd	r30, Y+3	; 0x03
    15fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1600:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1602:	81 e0       	ldi	r24, 0x01	; 1
    1604:	8a 83       	std	Y+2, r24	; 0x02
    1606:	01 c0       	rjmp	.+2      	; 0x160a <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    1608:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    160a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    160c:	28 96       	adiw	r28, 0x08	; 8
    160e:	0f b6       	in	r0, 0x3f	; 63
    1610:	f8 94       	cli
    1612:	de bf       	out	0x3e, r29	; 62
    1614:	0f be       	out	0x3f, r0	; 63
    1616:	cd bf       	out	0x3d, r28	; 61
    1618:	cf 91       	pop	r28
    161a:	df 91       	pop	r29
    161c:	08 95       	ret

0000161e <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    161e:	df 93       	push	r29
    1620:	cf 93       	push	r28
    1622:	00 d0       	rcall	.+0      	; 0x1624 <uxQueueMessagesWaiting+0x6>
    1624:	0f 92       	push	r0
    1626:	cd b7       	in	r28, 0x3d	; 61
    1628:	de b7       	in	r29, 0x3e	; 62
    162a:	9b 83       	std	Y+3, r25	; 0x03
    162c:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    162e:	0f b6       	in	r0, 0x3f	; 63
    1630:	f8 94       	cli
    1632:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1634:	ea 81       	ldd	r30, Y+2	; 0x02
    1636:	fb 81       	ldd	r31, Y+3	; 0x03
    1638:	82 8d       	ldd	r24, Z+26	; 0x1a
    163a:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    163c:	0f 90       	pop	r0
    163e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1640:	89 81       	ldd	r24, Y+1	; 0x01
}
    1642:	0f 90       	pop	r0
    1644:	0f 90       	pop	r0
    1646:	0f 90       	pop	r0
    1648:	cf 91       	pop	r28
    164a:	df 91       	pop	r29
    164c:	08 95       	ret

0000164e <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    164e:	df 93       	push	r29
    1650:	cf 93       	push	r28
    1652:	00 d0       	rcall	.+0      	; 0x1654 <uxQueueMessagesWaitingFromISR+0x6>
    1654:	0f 92       	push	r0
    1656:	cd b7       	in	r28, 0x3d	; 61
    1658:	de b7       	in	r29, 0x3e	; 62
    165a:	9b 83       	std	Y+3, r25	; 0x03
    165c:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    165e:	ea 81       	ldd	r30, Y+2	; 0x02
    1660:	fb 81       	ldd	r31, Y+3	; 0x03
    1662:	82 8d       	ldd	r24, Z+26	; 0x1a
    1664:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1666:	89 81       	ldd	r24, Y+1	; 0x01
}
    1668:	0f 90       	pop	r0
    166a:	0f 90       	pop	r0
    166c:	0f 90       	pop	r0
    166e:	cf 91       	pop	r28
    1670:	df 91       	pop	r29
    1672:	08 95       	ret

00001674 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1674:	df 93       	push	r29
    1676:	cf 93       	push	r28
    1678:	00 d0       	rcall	.+0      	; 0x167a <vQueueDelete+0x6>
    167a:	cd b7       	in	r28, 0x3d	; 61
    167c:	de b7       	in	r29, 0x3e	; 62
    167e:	9a 83       	std	Y+2, r25	; 0x02
    1680:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1682:	e9 81       	ldd	r30, Y+1	; 0x01
    1684:	fa 81       	ldd	r31, Y+2	; 0x02
    1686:	80 81       	ld	r24, Z
    1688:	91 81       	ldd	r25, Z+1	; 0x01
    168a:	0e 94 39 04 	call	0x872	; 0x872 <vPortFree>
	vPortFree( pxQueue );
    168e:	89 81       	ldd	r24, Y+1	; 0x01
    1690:	9a 81       	ldd	r25, Y+2	; 0x02
    1692:	0e 94 39 04 	call	0x872	; 0x872 <vPortFree>
}
    1696:	0f 90       	pop	r0
    1698:	0f 90       	pop	r0
    169a:	cf 91       	pop	r28
    169c:	df 91       	pop	r29
    169e:	08 95       	ret

000016a0 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    16a0:	df 93       	push	r29
    16a2:	cf 93       	push	r28
    16a4:	00 d0       	rcall	.+0      	; 0x16a6 <prvCopyDataToQueue+0x6>
    16a6:	00 d0       	rcall	.+0      	; 0x16a8 <prvCopyDataToQueue+0x8>
    16a8:	0f 92       	push	r0
    16aa:	cd b7       	in	r28, 0x3d	; 61
    16ac:	de b7       	in	r29, 0x3e	; 62
    16ae:	9a 83       	std	Y+2, r25	; 0x02
    16b0:	89 83       	std	Y+1, r24	; 0x01
    16b2:	7c 83       	std	Y+4, r23	; 0x04
    16b4:	6b 83       	std	Y+3, r22	; 0x03
    16b6:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    16b8:	e9 81       	ldd	r30, Y+1	; 0x01
    16ba:	fa 81       	ldd	r31, Y+2	; 0x02
    16bc:	84 8d       	ldd	r24, Z+28	; 0x1c
    16be:	88 23       	and	r24, r24
    16c0:	09 f4       	brne	.+2      	; 0x16c4 <prvCopyDataToQueue+0x24>
    16c2:	74 c0       	rjmp	.+232    	; 0x17ac <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    16c4:	8d 81       	ldd	r24, Y+5	; 0x05
    16c6:	88 23       	and	r24, r24
    16c8:	99 f5       	brne	.+102    	; 0x1730 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    16ca:	e9 81       	ldd	r30, Y+1	; 0x01
    16cc:	fa 81       	ldd	r31, Y+2	; 0x02
    16ce:	64 81       	ldd	r22, Z+4	; 0x04
    16d0:	75 81       	ldd	r23, Z+5	; 0x05
    16d2:	e9 81       	ldd	r30, Y+1	; 0x01
    16d4:	fa 81       	ldd	r31, Y+2	; 0x02
    16d6:	84 8d       	ldd	r24, Z+28	; 0x1c
    16d8:	48 2f       	mov	r20, r24
    16da:	50 e0       	ldi	r21, 0x00	; 0
    16dc:	2b 81       	ldd	r18, Y+3	; 0x03
    16de:	3c 81       	ldd	r19, Y+4	; 0x04
    16e0:	cb 01       	movw	r24, r22
    16e2:	b9 01       	movw	r22, r18
    16e4:	0e 94 b7 14 	call	0x296e	; 0x296e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    16e8:	e9 81       	ldd	r30, Y+1	; 0x01
    16ea:	fa 81       	ldd	r31, Y+2	; 0x02
    16ec:	24 81       	ldd	r18, Z+4	; 0x04
    16ee:	35 81       	ldd	r19, Z+5	; 0x05
    16f0:	e9 81       	ldd	r30, Y+1	; 0x01
    16f2:	fa 81       	ldd	r31, Y+2	; 0x02
    16f4:	84 8d       	ldd	r24, Z+28	; 0x1c
    16f6:	88 2f       	mov	r24, r24
    16f8:	90 e0       	ldi	r25, 0x00	; 0
    16fa:	82 0f       	add	r24, r18
    16fc:	93 1f       	adc	r25, r19
    16fe:	e9 81       	ldd	r30, Y+1	; 0x01
    1700:	fa 81       	ldd	r31, Y+2	; 0x02
    1702:	95 83       	std	Z+5, r25	; 0x05
    1704:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1706:	e9 81       	ldd	r30, Y+1	; 0x01
    1708:	fa 81       	ldd	r31, Y+2	; 0x02
    170a:	24 81       	ldd	r18, Z+4	; 0x04
    170c:	35 81       	ldd	r19, Z+5	; 0x05
    170e:	e9 81       	ldd	r30, Y+1	; 0x01
    1710:	fa 81       	ldd	r31, Y+2	; 0x02
    1712:	82 81       	ldd	r24, Z+2	; 0x02
    1714:	93 81       	ldd	r25, Z+3	; 0x03
    1716:	28 17       	cp	r18, r24
    1718:	39 07       	cpc	r19, r25
    171a:	08 f4       	brcc	.+2      	; 0x171e <prvCopyDataToQueue+0x7e>
    171c:	47 c0       	rjmp	.+142    	; 0x17ac <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    171e:	e9 81       	ldd	r30, Y+1	; 0x01
    1720:	fa 81       	ldd	r31, Y+2	; 0x02
    1722:	80 81       	ld	r24, Z
    1724:	91 81       	ldd	r25, Z+1	; 0x01
    1726:	e9 81       	ldd	r30, Y+1	; 0x01
    1728:	fa 81       	ldd	r31, Y+2	; 0x02
    172a:	95 83       	std	Z+5, r25	; 0x05
    172c:	84 83       	std	Z+4, r24	; 0x04
    172e:	3e c0       	rjmp	.+124    	; 0x17ac <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1730:	e9 81       	ldd	r30, Y+1	; 0x01
    1732:	fa 81       	ldd	r31, Y+2	; 0x02
    1734:	66 81       	ldd	r22, Z+6	; 0x06
    1736:	77 81       	ldd	r23, Z+7	; 0x07
    1738:	e9 81       	ldd	r30, Y+1	; 0x01
    173a:	fa 81       	ldd	r31, Y+2	; 0x02
    173c:	84 8d       	ldd	r24, Z+28	; 0x1c
    173e:	48 2f       	mov	r20, r24
    1740:	50 e0       	ldi	r21, 0x00	; 0
    1742:	2b 81       	ldd	r18, Y+3	; 0x03
    1744:	3c 81       	ldd	r19, Y+4	; 0x04
    1746:	cb 01       	movw	r24, r22
    1748:	b9 01       	movw	r22, r18
    174a:	0e 94 b7 14 	call	0x296e	; 0x296e <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    174e:	e9 81       	ldd	r30, Y+1	; 0x01
    1750:	fa 81       	ldd	r31, Y+2	; 0x02
    1752:	26 81       	ldd	r18, Z+6	; 0x06
    1754:	37 81       	ldd	r19, Z+7	; 0x07
    1756:	e9 81       	ldd	r30, Y+1	; 0x01
    1758:	fa 81       	ldd	r31, Y+2	; 0x02
    175a:	84 8d       	ldd	r24, Z+28	; 0x1c
    175c:	88 2f       	mov	r24, r24
    175e:	90 e0       	ldi	r25, 0x00	; 0
    1760:	90 95       	com	r25
    1762:	81 95       	neg	r24
    1764:	9f 4f       	sbci	r25, 0xFF	; 255
    1766:	82 0f       	add	r24, r18
    1768:	93 1f       	adc	r25, r19
    176a:	e9 81       	ldd	r30, Y+1	; 0x01
    176c:	fa 81       	ldd	r31, Y+2	; 0x02
    176e:	97 83       	std	Z+7, r25	; 0x07
    1770:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1772:	e9 81       	ldd	r30, Y+1	; 0x01
    1774:	fa 81       	ldd	r31, Y+2	; 0x02
    1776:	26 81       	ldd	r18, Z+6	; 0x06
    1778:	37 81       	ldd	r19, Z+7	; 0x07
    177a:	e9 81       	ldd	r30, Y+1	; 0x01
    177c:	fa 81       	ldd	r31, Y+2	; 0x02
    177e:	80 81       	ld	r24, Z
    1780:	91 81       	ldd	r25, Z+1	; 0x01
    1782:	28 17       	cp	r18, r24
    1784:	39 07       	cpc	r19, r25
    1786:	90 f4       	brcc	.+36     	; 0x17ac <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1788:	e9 81       	ldd	r30, Y+1	; 0x01
    178a:	fa 81       	ldd	r31, Y+2	; 0x02
    178c:	22 81       	ldd	r18, Z+2	; 0x02
    178e:	33 81       	ldd	r19, Z+3	; 0x03
    1790:	e9 81       	ldd	r30, Y+1	; 0x01
    1792:	fa 81       	ldd	r31, Y+2	; 0x02
    1794:	84 8d       	ldd	r24, Z+28	; 0x1c
    1796:	88 2f       	mov	r24, r24
    1798:	90 e0       	ldi	r25, 0x00	; 0
    179a:	90 95       	com	r25
    179c:	81 95       	neg	r24
    179e:	9f 4f       	sbci	r25, 0xFF	; 255
    17a0:	82 0f       	add	r24, r18
    17a2:	93 1f       	adc	r25, r19
    17a4:	e9 81       	ldd	r30, Y+1	; 0x01
    17a6:	fa 81       	ldd	r31, Y+2	; 0x02
    17a8:	97 83       	std	Z+7, r25	; 0x07
    17aa:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    17ac:	e9 81       	ldd	r30, Y+1	; 0x01
    17ae:	fa 81       	ldd	r31, Y+2	; 0x02
    17b0:	82 8d       	ldd	r24, Z+26	; 0x1a
    17b2:	8f 5f       	subi	r24, 0xFF	; 255
    17b4:	e9 81       	ldd	r30, Y+1	; 0x01
    17b6:	fa 81       	ldd	r31, Y+2	; 0x02
    17b8:	82 8f       	std	Z+26, r24	; 0x1a
}
    17ba:	0f 90       	pop	r0
    17bc:	0f 90       	pop	r0
    17be:	0f 90       	pop	r0
    17c0:	0f 90       	pop	r0
    17c2:	0f 90       	pop	r0
    17c4:	cf 91       	pop	r28
    17c6:	df 91       	pop	r29
    17c8:	08 95       	ret

000017ca <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    17ca:	df 93       	push	r29
    17cc:	cf 93       	push	r28
    17ce:	00 d0       	rcall	.+0      	; 0x17d0 <prvCopyDataFromQueue+0x6>
    17d0:	00 d0       	rcall	.+0      	; 0x17d2 <prvCopyDataFromQueue+0x8>
    17d2:	cd b7       	in	r28, 0x3d	; 61
    17d4:	de b7       	in	r29, 0x3e	; 62
    17d6:	9a 83       	std	Y+2, r25	; 0x02
    17d8:	89 83       	std	Y+1, r24	; 0x01
    17da:	7c 83       	std	Y+4, r23	; 0x04
    17dc:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    17de:	e9 81       	ldd	r30, Y+1	; 0x01
    17e0:	fa 81       	ldd	r31, Y+2	; 0x02
    17e2:	80 81       	ld	r24, Z
    17e4:	91 81       	ldd	r25, Z+1	; 0x01
    17e6:	00 97       	sbiw	r24, 0x00	; 0
    17e8:	89 f1       	breq	.+98     	; 0x184c <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    17ea:	e9 81       	ldd	r30, Y+1	; 0x01
    17ec:	fa 81       	ldd	r31, Y+2	; 0x02
    17ee:	26 81       	ldd	r18, Z+6	; 0x06
    17f0:	37 81       	ldd	r19, Z+7	; 0x07
    17f2:	e9 81       	ldd	r30, Y+1	; 0x01
    17f4:	fa 81       	ldd	r31, Y+2	; 0x02
    17f6:	84 8d       	ldd	r24, Z+28	; 0x1c
    17f8:	88 2f       	mov	r24, r24
    17fa:	90 e0       	ldi	r25, 0x00	; 0
    17fc:	82 0f       	add	r24, r18
    17fe:	93 1f       	adc	r25, r19
    1800:	e9 81       	ldd	r30, Y+1	; 0x01
    1802:	fa 81       	ldd	r31, Y+2	; 0x02
    1804:	97 83       	std	Z+7, r25	; 0x07
    1806:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1808:	e9 81       	ldd	r30, Y+1	; 0x01
    180a:	fa 81       	ldd	r31, Y+2	; 0x02
    180c:	26 81       	ldd	r18, Z+6	; 0x06
    180e:	37 81       	ldd	r19, Z+7	; 0x07
    1810:	e9 81       	ldd	r30, Y+1	; 0x01
    1812:	fa 81       	ldd	r31, Y+2	; 0x02
    1814:	82 81       	ldd	r24, Z+2	; 0x02
    1816:	93 81       	ldd	r25, Z+3	; 0x03
    1818:	28 17       	cp	r18, r24
    181a:	39 07       	cpc	r19, r25
    181c:	40 f0       	brcs	.+16     	; 0x182e <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    181e:	e9 81       	ldd	r30, Y+1	; 0x01
    1820:	fa 81       	ldd	r31, Y+2	; 0x02
    1822:	80 81       	ld	r24, Z
    1824:	91 81       	ldd	r25, Z+1	; 0x01
    1826:	e9 81       	ldd	r30, Y+1	; 0x01
    1828:	fa 81       	ldd	r31, Y+2	; 0x02
    182a:	97 83       	std	Z+7, r25	; 0x07
    182c:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    182e:	e9 81       	ldd	r30, Y+1	; 0x01
    1830:	fa 81       	ldd	r31, Y+2	; 0x02
    1832:	46 81       	ldd	r20, Z+6	; 0x06
    1834:	57 81       	ldd	r21, Z+7	; 0x07
    1836:	e9 81       	ldd	r30, Y+1	; 0x01
    1838:	fa 81       	ldd	r31, Y+2	; 0x02
    183a:	84 8d       	ldd	r24, Z+28	; 0x1c
    183c:	28 2f       	mov	r18, r24
    183e:	30 e0       	ldi	r19, 0x00	; 0
    1840:	8b 81       	ldd	r24, Y+3	; 0x03
    1842:	9c 81       	ldd	r25, Y+4	; 0x04
    1844:	ba 01       	movw	r22, r20
    1846:	a9 01       	movw	r20, r18
    1848:	0e 94 b7 14 	call	0x296e	; 0x296e <memcpy>
	}
}
    184c:	0f 90       	pop	r0
    184e:	0f 90       	pop	r0
    1850:	0f 90       	pop	r0
    1852:	0f 90       	pop	r0
    1854:	cf 91       	pop	r28
    1856:	df 91       	pop	r29
    1858:	08 95       	ret

0000185a <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    185a:	df 93       	push	r29
    185c:	cf 93       	push	r28
    185e:	00 d0       	rcall	.+0      	; 0x1860 <prvUnlockQueue+0x6>
    1860:	cd b7       	in	r28, 0x3d	; 61
    1862:	de b7       	in	r29, 0x3e	; 62
    1864:	9a 83       	std	Y+2, r25	; 0x02
    1866:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1868:	0f b6       	in	r0, 0x3f	; 63
    186a:	f8 94       	cli
    186c:	0f 92       	push	r0
    186e:	15 c0       	rjmp	.+42     	; 0x189a <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1870:	e9 81       	ldd	r30, Y+1	; 0x01
    1872:	fa 81       	ldd	r31, Y+2	; 0x02
    1874:	81 89       	ldd	r24, Z+17	; 0x11
    1876:	88 23       	and	r24, r24
    1878:	a9 f0       	breq	.+42     	; 0x18a4 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    187a:	89 81       	ldd	r24, Y+1	; 0x01
    187c:	9a 81       	ldd	r25, Y+2	; 0x02
    187e:	41 96       	adiw	r24, 0x11	; 17
    1880:	0e 94 44 12 	call	0x2488	; 0x2488 <xTaskRemoveFromEventList>
    1884:	88 23       	and	r24, r24
    1886:	11 f0       	breq	.+4      	; 0x188c <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1888:	0e 94 22 13 	call	0x2644	; 0x2644 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    188c:	e9 81       	ldd	r30, Y+1	; 0x01
    188e:	fa 81       	ldd	r31, Y+2	; 0x02
    1890:	86 8d       	ldd	r24, Z+30	; 0x1e
    1892:	81 50       	subi	r24, 0x01	; 1
    1894:	e9 81       	ldd	r30, Y+1	; 0x01
    1896:	fa 81       	ldd	r31, Y+2	; 0x02
    1898:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    189a:	e9 81       	ldd	r30, Y+1	; 0x01
    189c:	fa 81       	ldd	r31, Y+2	; 0x02
    189e:	86 8d       	ldd	r24, Z+30	; 0x1e
    18a0:	18 16       	cp	r1, r24
    18a2:	34 f3       	brlt	.-52     	; 0x1870 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    18a4:	e9 81       	ldd	r30, Y+1	; 0x01
    18a6:	fa 81       	ldd	r31, Y+2	; 0x02
    18a8:	8f ef       	ldi	r24, 0xFF	; 255
    18aa:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    18ac:	0f 90       	pop	r0
    18ae:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    18b0:	0f b6       	in	r0, 0x3f	; 63
    18b2:	f8 94       	cli
    18b4:	0f 92       	push	r0
    18b6:	15 c0       	rjmp	.+42     	; 0x18e2 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    18b8:	e9 81       	ldd	r30, Y+1	; 0x01
    18ba:	fa 81       	ldd	r31, Y+2	; 0x02
    18bc:	80 85       	ldd	r24, Z+8	; 0x08
    18be:	88 23       	and	r24, r24
    18c0:	a9 f0       	breq	.+42     	; 0x18ec <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    18c2:	89 81       	ldd	r24, Y+1	; 0x01
    18c4:	9a 81       	ldd	r25, Y+2	; 0x02
    18c6:	08 96       	adiw	r24, 0x08	; 8
    18c8:	0e 94 44 12 	call	0x2488	; 0x2488 <xTaskRemoveFromEventList>
    18cc:	88 23       	and	r24, r24
    18ce:	11 f0       	breq	.+4      	; 0x18d4 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    18d0:	0e 94 22 13 	call	0x2644	; 0x2644 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    18d4:	e9 81       	ldd	r30, Y+1	; 0x01
    18d6:	fa 81       	ldd	r31, Y+2	; 0x02
    18d8:	85 8d       	ldd	r24, Z+29	; 0x1d
    18da:	81 50       	subi	r24, 0x01	; 1
    18dc:	e9 81       	ldd	r30, Y+1	; 0x01
    18de:	fa 81       	ldd	r31, Y+2	; 0x02
    18e0:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    18e2:	e9 81       	ldd	r30, Y+1	; 0x01
    18e4:	fa 81       	ldd	r31, Y+2	; 0x02
    18e6:	85 8d       	ldd	r24, Z+29	; 0x1d
    18e8:	18 16       	cp	r1, r24
    18ea:	34 f3       	brlt	.-52     	; 0x18b8 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    18ec:	e9 81       	ldd	r30, Y+1	; 0x01
    18ee:	fa 81       	ldd	r31, Y+2	; 0x02
    18f0:	8f ef       	ldi	r24, 0xFF	; 255
    18f2:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    18f4:	0f 90       	pop	r0
    18f6:	0f be       	out	0x3f, r0	; 63
}
    18f8:	0f 90       	pop	r0
    18fa:	0f 90       	pop	r0
    18fc:	cf 91       	pop	r28
    18fe:	df 91       	pop	r29
    1900:	08 95       	ret

00001902 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    1902:	df 93       	push	r29
    1904:	cf 93       	push	r28
    1906:	00 d0       	rcall	.+0      	; 0x1908 <prvIsQueueEmpty+0x6>
    1908:	0f 92       	push	r0
    190a:	cd b7       	in	r28, 0x3d	; 61
    190c:	de b7       	in	r29, 0x3e	; 62
    190e:	9b 83       	std	Y+3, r25	; 0x03
    1910:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1912:	0f b6       	in	r0, 0x3f	; 63
    1914:	f8 94       	cli
    1916:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1918:	ea 81       	ldd	r30, Y+2	; 0x02
    191a:	fb 81       	ldd	r31, Y+3	; 0x03
    191c:	82 8d       	ldd	r24, Z+26	; 0x1a
    191e:	19 82       	std	Y+1, r1	; 0x01
    1920:	88 23       	and	r24, r24
    1922:	11 f4       	brne	.+4      	; 0x1928 <prvIsQueueEmpty+0x26>
    1924:	81 e0       	ldi	r24, 0x01	; 1
    1926:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1928:	0f 90       	pop	r0
    192a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    192c:	89 81       	ldd	r24, Y+1	; 0x01
}
    192e:	0f 90       	pop	r0
    1930:	0f 90       	pop	r0
    1932:	0f 90       	pop	r0
    1934:	cf 91       	pop	r28
    1936:	df 91       	pop	r29
    1938:	08 95       	ret

0000193a <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    193a:	df 93       	push	r29
    193c:	cf 93       	push	r28
    193e:	00 d0       	rcall	.+0      	; 0x1940 <xQueueIsQueueEmptyFromISR+0x6>
    1940:	0f 92       	push	r0
    1942:	cd b7       	in	r28, 0x3d	; 61
    1944:	de b7       	in	r29, 0x3e	; 62
    1946:	9b 83       	std	Y+3, r25	; 0x03
    1948:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    194a:	ea 81       	ldd	r30, Y+2	; 0x02
    194c:	fb 81       	ldd	r31, Y+3	; 0x03
    194e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1950:	19 82       	std	Y+1, r1	; 0x01
    1952:	88 23       	and	r24, r24
    1954:	11 f4       	brne	.+4      	; 0x195a <xQueueIsQueueEmptyFromISR+0x20>
    1956:	81 e0       	ldi	r24, 0x01	; 1
    1958:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    195a:	89 81       	ldd	r24, Y+1	; 0x01
}
    195c:	0f 90       	pop	r0
    195e:	0f 90       	pop	r0
    1960:	0f 90       	pop	r0
    1962:	cf 91       	pop	r28
    1964:	df 91       	pop	r29
    1966:	08 95       	ret

00001968 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    1968:	df 93       	push	r29
    196a:	cf 93       	push	r28
    196c:	00 d0       	rcall	.+0      	; 0x196e <prvIsQueueFull+0x6>
    196e:	0f 92       	push	r0
    1970:	cd b7       	in	r28, 0x3d	; 61
    1972:	de b7       	in	r29, 0x3e	; 62
    1974:	9b 83       	std	Y+3, r25	; 0x03
    1976:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1978:	0f b6       	in	r0, 0x3f	; 63
    197a:	f8 94       	cli
    197c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    197e:	ea 81       	ldd	r30, Y+2	; 0x02
    1980:	fb 81       	ldd	r31, Y+3	; 0x03
    1982:	92 8d       	ldd	r25, Z+26	; 0x1a
    1984:	ea 81       	ldd	r30, Y+2	; 0x02
    1986:	fb 81       	ldd	r31, Y+3	; 0x03
    1988:	83 8d       	ldd	r24, Z+27	; 0x1b
    198a:	19 82       	std	Y+1, r1	; 0x01
    198c:	98 17       	cp	r25, r24
    198e:	11 f4       	brne	.+4      	; 0x1994 <prvIsQueueFull+0x2c>
    1990:	81 e0       	ldi	r24, 0x01	; 1
    1992:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1994:	0f 90       	pop	r0
    1996:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1998:	89 81       	ldd	r24, Y+1	; 0x01
}
    199a:	0f 90       	pop	r0
    199c:	0f 90       	pop	r0
    199e:	0f 90       	pop	r0
    19a0:	cf 91       	pop	r28
    19a2:	df 91       	pop	r29
    19a4:	08 95       	ret

000019a6 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    19a6:	df 93       	push	r29
    19a8:	cf 93       	push	r28
    19aa:	00 d0       	rcall	.+0      	; 0x19ac <xQueueIsQueueFullFromISR+0x6>
    19ac:	0f 92       	push	r0
    19ae:	cd b7       	in	r28, 0x3d	; 61
    19b0:	de b7       	in	r29, 0x3e	; 62
    19b2:	9b 83       	std	Y+3, r25	; 0x03
    19b4:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    19b6:	ea 81       	ldd	r30, Y+2	; 0x02
    19b8:	fb 81       	ldd	r31, Y+3	; 0x03
    19ba:	92 8d       	ldd	r25, Z+26	; 0x1a
    19bc:	ea 81       	ldd	r30, Y+2	; 0x02
    19be:	fb 81       	ldd	r31, Y+3	; 0x03
    19c0:	83 8d       	ldd	r24, Z+27	; 0x1b
    19c2:	19 82       	std	Y+1, r1	; 0x01
    19c4:	98 17       	cp	r25, r24
    19c6:	11 f4       	brne	.+4      	; 0x19cc <xQueueIsQueueFullFromISR+0x26>
    19c8:	81 e0       	ldi	r24, 0x01	; 1
    19ca:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    19cc:	89 81       	ldd	r24, Y+1	; 0x01
}
    19ce:	0f 90       	pop	r0
    19d0:	0f 90       	pop	r0
    19d2:	0f 90       	pop	r0
    19d4:	cf 91       	pop	r28
    19d6:	df 91       	pop	r29
    19d8:	08 95       	ret

000019da <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    19da:	af 92       	push	r10
    19dc:	bf 92       	push	r11
    19de:	cf 92       	push	r12
    19e0:	df 92       	push	r13
    19e2:	ef 92       	push	r14
    19e4:	ff 92       	push	r15
    19e6:	0f 93       	push	r16
    19e8:	1f 93       	push	r17
    19ea:	df 93       	push	r29
    19ec:	cf 93       	push	r28
    19ee:	cd b7       	in	r28, 0x3d	; 61
    19f0:	de b7       	in	r29, 0x3e	; 62
    19f2:	64 97       	sbiw	r28, 0x14	; 20
    19f4:	0f b6       	in	r0, 0x3f	; 63
    19f6:	f8 94       	cli
    19f8:	de bf       	out	0x3e, r29	; 62
    19fa:	0f be       	out	0x3f, r0	; 63
    19fc:	cd bf       	out	0x3d, r28	; 61
    19fe:	9f 83       	std	Y+7, r25	; 0x07
    1a00:	8e 83       	std	Y+6, r24	; 0x06
    1a02:	79 87       	std	Y+9, r23	; 0x09
    1a04:	68 87       	std	Y+8, r22	; 0x08
    1a06:	5b 87       	std	Y+11, r21	; 0x0b
    1a08:	4a 87       	std	Y+10, r20	; 0x0a
    1a0a:	3d 87       	std	Y+13, r19	; 0x0d
    1a0c:	2c 87       	std	Y+12, r18	; 0x0c
    1a0e:	0e 87       	std	Y+14, r16	; 0x0e
    1a10:	f8 8a       	std	Y+16, r15	; 0x10
    1a12:	ef 86       	std	Y+15, r14	; 0x0f
    1a14:	da 8a       	std	Y+18, r13	; 0x12
    1a16:	c9 8a       	std	Y+17, r12	; 0x11
    1a18:	bc 8a       	std	Y+20, r11	; 0x14
    1a1a:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    1a1c:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a1e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a20:	29 89       	ldd	r18, Y+17	; 0x11
    1a22:	3a 89       	ldd	r19, Y+18	; 0x12
    1a24:	b9 01       	movw	r22, r18
    1a26:	0e 94 51 14 	call	0x28a2	; 0x28a2 <prvAllocateTCBAndStack>
    1a2a:	9c 83       	std	Y+4, r25	; 0x04
    1a2c:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    1a2e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a30:	9c 81       	ldd	r25, Y+4	; 0x04
    1a32:	00 97       	sbiw	r24, 0x00	; 0
    1a34:	09 f4       	brne	.+2      	; 0x1a38 <xTaskGenericCreate+0x5e>
    1a36:	99 c0       	rjmp	.+306    	; 0x1b6a <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1a38:	eb 81       	ldd	r30, Y+3	; 0x03
    1a3a:	fc 81       	ldd	r31, Y+4	; 0x04
    1a3c:	27 89       	ldd	r18, Z+23	; 0x17
    1a3e:	30 8d       	ldd	r19, Z+24	; 0x18
    1a40:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a42:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a44:	01 97       	sbiw	r24, 0x01	; 1
    1a46:	82 0f       	add	r24, r18
    1a48:	93 1f       	adc	r25, r19
    1a4a:	9a 83       	std	Y+2, r25	; 0x02
    1a4c:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    1a4e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a50:	9c 81       	ldd	r25, Y+4	; 0x04
    1a52:	28 85       	ldd	r18, Y+8	; 0x08
    1a54:	39 85       	ldd	r19, Y+9	; 0x09
    1a56:	eb 89       	ldd	r30, Y+19	; 0x13
    1a58:	fc 89       	ldd	r31, Y+20	; 0x14
    1a5a:	aa 85       	ldd	r26, Y+10	; 0x0a
    1a5c:	bb 85       	ldd	r27, Y+11	; 0x0b
    1a5e:	b9 01       	movw	r22, r18
    1a60:	4e 85       	ldd	r20, Y+14	; 0x0e
    1a62:	9f 01       	movw	r18, r30
    1a64:	8d 01       	movw	r16, r26
    1a66:	0e 94 36 13 	call	0x266c	; 0x266c <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1a6a:	89 81       	ldd	r24, Y+1	; 0x01
    1a6c:	9a 81       	ldd	r25, Y+2	; 0x02
    1a6e:	2e 81       	ldd	r18, Y+6	; 0x06
    1a70:	3f 81       	ldd	r19, Y+7	; 0x07
    1a72:	4c 85       	ldd	r20, Y+12	; 0x0c
    1a74:	5d 85       	ldd	r21, Y+13	; 0x0d
    1a76:	b9 01       	movw	r22, r18
    1a78:	0e 94 9a 05 	call	0xb34	; 0xb34 <pxPortInitialiseStack>
    1a7c:	eb 81       	ldd	r30, Y+3	; 0x03
    1a7e:	fc 81       	ldd	r31, Y+4	; 0x04
    1a80:	91 83       	std	Z+1, r25	; 0x01
    1a82:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    1a84:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a86:	98 89       	ldd	r25, Y+16	; 0x10
    1a88:	00 97       	sbiw	r24, 0x00	; 0
    1a8a:	31 f0       	breq	.+12     	; 0x1a98 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1a8c:	ef 85       	ldd	r30, Y+15	; 0x0f
    1a8e:	f8 89       	ldd	r31, Y+16	; 0x10
    1a90:	8b 81       	ldd	r24, Y+3	; 0x03
    1a92:	9c 81       	ldd	r25, Y+4	; 0x04
    1a94:	91 83       	std	Z+1, r25	; 0x01
    1a96:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1a98:	0f b6       	in	r0, 0x3f	; 63
    1a9a:	f8 94       	cli
    1a9c:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1a9e:	80 91 17 03 	lds	r24, 0x0317
    1aa2:	8f 5f       	subi	r24, 0xFF	; 255
    1aa4:	80 93 17 03 	sts	0x0317, r24
			if( pxCurrentTCB == NULL )
    1aa8:	80 91 14 03 	lds	r24, 0x0314
    1aac:	90 91 15 03 	lds	r25, 0x0315
    1ab0:	00 97       	sbiw	r24, 0x00	; 0
    1ab2:	69 f4       	brne	.+26     	; 0x1ace <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1ab4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ab6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ab8:	90 93 15 03 	sts	0x0315, r25
    1abc:	80 93 14 03 	sts	0x0314, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1ac0:	80 91 17 03 	lds	r24, 0x0317
    1ac4:	81 30       	cpi	r24, 0x01	; 1
    1ac6:	a9 f4       	brne	.+42     	; 0x1af2 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    1ac8:	0e 94 8d 13 	call	0x271a	; 0x271a <prvInitialiseTaskLists>
    1acc:	12 c0       	rjmp	.+36     	; 0x1af2 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1ace:	80 91 1c 03 	lds	r24, 0x031C
    1ad2:	88 23       	and	r24, r24
    1ad4:	71 f4       	brne	.+28     	; 0x1af2 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1ad6:	e0 91 14 03 	lds	r30, 0x0314
    1ada:	f0 91 15 03 	lds	r31, 0x0315
    1ade:	96 89       	ldd	r25, Z+22	; 0x16
    1ae0:	8e 85       	ldd	r24, Y+14	; 0x0e
    1ae2:	89 17       	cp	r24, r25
    1ae4:	30 f0       	brcs	.+12     	; 0x1af2 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    1ae6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ae8:	9c 81       	ldd	r25, Y+4	; 0x04
    1aea:	90 93 15 03 	sts	0x0315, r25
    1aee:	80 93 14 03 	sts	0x0314, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1af2:	eb 81       	ldd	r30, Y+3	; 0x03
    1af4:	fc 81       	ldd	r31, Y+4	; 0x04
    1af6:	96 89       	ldd	r25, Z+22	; 0x16
    1af8:	80 91 1a 03 	lds	r24, 0x031A
    1afc:	89 17       	cp	r24, r25
    1afe:	28 f4       	brcc	.+10     	; 0x1b0a <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1b00:	eb 81       	ldd	r30, Y+3	; 0x03
    1b02:	fc 81       	ldd	r31, Y+4	; 0x04
    1b04:	86 89       	ldd	r24, Z+22	; 0x16
    1b06:	80 93 1a 03 	sts	0x031A, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1b0a:	80 91 21 03 	lds	r24, 0x0321
    1b0e:	8f 5f       	subi	r24, 0xFF	; 255
    1b10:	80 93 21 03 	sts	0x0321, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1b14:	eb 81       	ldd	r30, Y+3	; 0x03
    1b16:	fc 81       	ldd	r31, Y+4	; 0x04
    1b18:	96 89       	ldd	r25, Z+22	; 0x16
    1b1a:	80 91 1b 03 	lds	r24, 0x031B
    1b1e:	89 17       	cp	r24, r25
    1b20:	28 f4       	brcc	.+10     	; 0x1b2c <xTaskGenericCreate+0x152>
    1b22:	eb 81       	ldd	r30, Y+3	; 0x03
    1b24:	fc 81       	ldd	r31, Y+4	; 0x04
    1b26:	86 89       	ldd	r24, Z+22	; 0x16
    1b28:	80 93 1b 03 	sts	0x031B, r24
    1b2c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b2e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b30:	86 89       	ldd	r24, Z+22	; 0x16
    1b32:	28 2f       	mov	r18, r24
    1b34:	30 e0       	ldi	r19, 0x00	; 0
    1b36:	c9 01       	movw	r24, r18
    1b38:	88 0f       	add	r24, r24
    1b3a:	99 1f       	adc	r25, r25
    1b3c:	88 0f       	add	r24, r24
    1b3e:	99 1f       	adc	r25, r25
    1b40:	88 0f       	add	r24, r24
    1b42:	99 1f       	adc	r25, r25
    1b44:	82 0f       	add	r24, r18
    1b46:	93 1f       	adc	r25, r19
    1b48:	ac 01       	movw	r20, r24
    1b4a:	4e 5d       	subi	r20, 0xDE	; 222
    1b4c:	5c 4f       	sbci	r21, 0xFC	; 252
    1b4e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b50:	9c 81       	ldd	r25, Y+4	; 0x04
    1b52:	9c 01       	movw	r18, r24
    1b54:	2e 5f       	subi	r18, 0xFE	; 254
    1b56:	3f 4f       	sbci	r19, 0xFF	; 255
    1b58:	ca 01       	movw	r24, r20
    1b5a:	b9 01       	movw	r22, r18
    1b5c:	0e 94 99 04 	call	0x932	; 0x932 <vListInsertEnd>

			xReturn = pdPASS;
    1b60:	81 e0       	ldi	r24, 0x01	; 1
    1b62:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1b64:	0f 90       	pop	r0
    1b66:	0f be       	out	0x3f, r0	; 63
    1b68:	02 c0       	rjmp	.+4      	; 0x1b6e <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1b6a:	8f ef       	ldi	r24, 0xFF	; 255
    1b6c:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    1b6e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b70:	81 30       	cpi	r24, 0x01	; 1
    1b72:	71 f4       	brne	.+28     	; 0x1b90 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    1b74:	80 91 1c 03 	lds	r24, 0x031C
    1b78:	88 23       	and	r24, r24
    1b7a:	51 f0       	breq	.+20     	; 0x1b90 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1b7c:	e0 91 14 03 	lds	r30, 0x0314
    1b80:	f0 91 15 03 	lds	r31, 0x0315
    1b84:	96 89       	ldd	r25, Z+22	; 0x16
    1b86:	8e 85       	ldd	r24, Y+14	; 0x0e
    1b88:	98 17       	cp	r25, r24
    1b8a:	10 f4       	brcc	.+4      	; 0x1b90 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    1b8c:	0e 94 59 07 	call	0xeb2	; 0xeb2 <vPortYield>
			}
		}
	}

	return xReturn;
    1b90:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1b92:	64 96       	adiw	r28, 0x14	; 20
    1b94:	0f b6       	in	r0, 0x3f	; 63
    1b96:	f8 94       	cli
    1b98:	de bf       	out	0x3e, r29	; 62
    1b9a:	0f be       	out	0x3f, r0	; 63
    1b9c:	cd bf       	out	0x3d, r28	; 61
    1b9e:	cf 91       	pop	r28
    1ba0:	df 91       	pop	r29
    1ba2:	1f 91       	pop	r17
    1ba4:	0f 91       	pop	r16
    1ba6:	ff 90       	pop	r15
    1ba8:	ef 90       	pop	r14
    1baa:	df 90       	pop	r13
    1bac:	cf 90       	pop	r12
    1bae:	bf 90       	pop	r11
    1bb0:	af 90       	pop	r10
    1bb2:	08 95       	ret

00001bb4 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1bb4:	df 93       	push	r29
    1bb6:	cf 93       	push	r28
    1bb8:	00 d0       	rcall	.+0      	; 0x1bba <vTaskDelete+0x6>
    1bba:	00 d0       	rcall	.+0      	; 0x1bbc <vTaskDelete+0x8>
    1bbc:	00 d0       	rcall	.+0      	; 0x1bbe <vTaskDelete+0xa>
    1bbe:	cd b7       	in	r28, 0x3d	; 61
    1bc0:	de b7       	in	r29, 0x3e	; 62
    1bc2:	9c 83       	std	Y+4, r25	; 0x04
    1bc4:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1bc6:	0f b6       	in	r0, 0x3f	; 63
    1bc8:	f8 94       	cli
    1bca:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1bcc:	20 91 14 03 	lds	r18, 0x0314
    1bd0:	30 91 15 03 	lds	r19, 0x0315
    1bd4:	8b 81       	ldd	r24, Y+3	; 0x03
    1bd6:	9c 81       	ldd	r25, Y+4	; 0x04
    1bd8:	82 17       	cp	r24, r18
    1bda:	93 07       	cpc	r25, r19
    1bdc:	11 f4       	brne	.+4      	; 0x1be2 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    1bde:	1c 82       	std	Y+4, r1	; 0x04
    1be0:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1be2:	8b 81       	ldd	r24, Y+3	; 0x03
    1be4:	9c 81       	ldd	r25, Y+4	; 0x04
    1be6:	00 97       	sbiw	r24, 0x00	; 0
    1be8:	39 f4       	brne	.+14     	; 0x1bf8 <vTaskDelete+0x44>
    1bea:	80 91 14 03 	lds	r24, 0x0314
    1bee:	90 91 15 03 	lds	r25, 0x0315
    1bf2:	9e 83       	std	Y+6, r25	; 0x06
    1bf4:	8d 83       	std	Y+5, r24	; 0x05
    1bf6:	04 c0       	rjmp	.+8      	; 0x1c00 <vTaskDelete+0x4c>
    1bf8:	8b 81       	ldd	r24, Y+3	; 0x03
    1bfa:	9c 81       	ldd	r25, Y+4	; 0x04
    1bfc:	9e 83       	std	Y+6, r25	; 0x06
    1bfe:	8d 83       	std	Y+5, r24	; 0x05
    1c00:	8d 81       	ldd	r24, Y+5	; 0x05
    1c02:	9e 81       	ldd	r25, Y+6	; 0x06
    1c04:	9a 83       	std	Y+2, r25	; 0x02
    1c06:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1c08:	89 81       	ldd	r24, Y+1	; 0x01
    1c0a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c0c:	02 96       	adiw	r24, 0x02	; 2
    1c0e:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1c12:	e9 81       	ldd	r30, Y+1	; 0x01
    1c14:	fa 81       	ldd	r31, Y+2	; 0x02
    1c16:	84 89       	ldd	r24, Z+20	; 0x14
    1c18:	95 89       	ldd	r25, Z+21	; 0x15
    1c1a:	00 97       	sbiw	r24, 0x00	; 0
    1c1c:	29 f0       	breq	.+10     	; 0x1c28 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1c1e:	89 81       	ldd	r24, Y+1	; 0x01
    1c20:	9a 81       	ldd	r25, Y+2	; 0x02
    1c22:	0c 96       	adiw	r24, 0x0c	; 12
    1c24:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1c28:	89 81       	ldd	r24, Y+1	; 0x01
    1c2a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c2c:	9c 01       	movw	r18, r24
    1c2e:	2e 5f       	subi	r18, 0xFE	; 254
    1c30:	3f 4f       	sbci	r19, 0xFF	; 255
    1c32:	8e e6       	ldi	r24, 0x6E	; 110
    1c34:	93 e0       	ldi	r25, 0x03	; 3
    1c36:	b9 01       	movw	r22, r18
    1c38:	0e 94 99 04 	call	0x932	; 0x932 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1c3c:	80 91 16 03 	lds	r24, 0x0316
    1c40:	8f 5f       	subi	r24, 0xFF	; 255
    1c42:	80 93 16 03 	sts	0x0316, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1c46:	80 91 21 03 	lds	r24, 0x0321
    1c4a:	8f 5f       	subi	r24, 0xFF	; 255
    1c4c:	80 93 21 03 	sts	0x0321, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1c50:	0f 90       	pop	r0
    1c52:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1c54:	80 91 1c 03 	lds	r24, 0x031C
    1c58:	88 23       	and	r24, r24
    1c5a:	31 f0       	breq	.+12     	; 0x1c68 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1c5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c5e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c60:	00 97       	sbiw	r24, 0x00	; 0
    1c62:	11 f4       	brne	.+4      	; 0x1c68 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    1c64:	0e 94 59 07 	call	0xeb2	; 0xeb2 <vPortYield>
			}
		}
	}
    1c68:	26 96       	adiw	r28, 0x06	; 6
    1c6a:	0f b6       	in	r0, 0x3f	; 63
    1c6c:	f8 94       	cli
    1c6e:	de bf       	out	0x3e, r29	; 62
    1c70:	0f be       	out	0x3f, r0	; 63
    1c72:	cd bf       	out	0x3d, r28	; 61
    1c74:	cf 91       	pop	r28
    1c76:	df 91       	pop	r29
    1c78:	08 95       	ret

00001c7a <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1c7a:	df 93       	push	r29
    1c7c:	cf 93       	push	r28
    1c7e:	cd b7       	in	r28, 0x3d	; 61
    1c80:	de b7       	in	r29, 0x3e	; 62
    1c82:	28 97       	sbiw	r28, 0x08	; 8
    1c84:	0f b6       	in	r0, 0x3f	; 63
    1c86:	f8 94       	cli
    1c88:	de bf       	out	0x3e, r29	; 62
    1c8a:	0f be       	out	0x3f, r0	; 63
    1c8c:	cd bf       	out	0x3d, r28	; 61
    1c8e:	9e 83       	std	Y+6, r25	; 0x06
    1c90:	8d 83       	std	Y+5, r24	; 0x05
    1c92:	78 87       	std	Y+8, r23	; 0x08
    1c94:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    1c96:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1c98:	0e 94 08 10 	call	0x2010	; 0x2010 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1c9c:	ed 81       	ldd	r30, Y+5	; 0x05
    1c9e:	fe 81       	ldd	r31, Y+6	; 0x06
    1ca0:	20 81       	ld	r18, Z
    1ca2:	31 81       	ldd	r19, Z+1	; 0x01
    1ca4:	8f 81       	ldd	r24, Y+7	; 0x07
    1ca6:	98 85       	ldd	r25, Y+8	; 0x08
    1ca8:	82 0f       	add	r24, r18
    1caa:	93 1f       	adc	r25, r19
    1cac:	9c 83       	std	Y+4, r25	; 0x04
    1cae:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    1cb0:	ed 81       	ldd	r30, Y+5	; 0x05
    1cb2:	fe 81       	ldd	r31, Y+6	; 0x06
    1cb4:	20 81       	ld	r18, Z
    1cb6:	31 81       	ldd	r19, Z+1	; 0x01
    1cb8:	80 91 18 03 	lds	r24, 0x0318
    1cbc:	90 91 19 03 	lds	r25, 0x0319
    1cc0:	82 17       	cp	r24, r18
    1cc2:	93 07       	cpc	r25, r19
    1cc4:	a8 f4       	brcc	.+42     	; 0x1cf0 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1cc6:	ed 81       	ldd	r30, Y+5	; 0x05
    1cc8:	fe 81       	ldd	r31, Y+6	; 0x06
    1cca:	20 81       	ld	r18, Z
    1ccc:	31 81       	ldd	r19, Z+1	; 0x01
    1cce:	8b 81       	ldd	r24, Y+3	; 0x03
    1cd0:	9c 81       	ldd	r25, Y+4	; 0x04
    1cd2:	82 17       	cp	r24, r18
    1cd4:	93 07       	cpc	r25, r19
    1cd6:	00 f5       	brcc	.+64     	; 0x1d18 <vTaskDelayUntil+0x9e>
    1cd8:	20 91 18 03 	lds	r18, 0x0318
    1cdc:	30 91 19 03 	lds	r19, 0x0319
    1ce0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ce2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ce4:	28 17       	cp	r18, r24
    1ce6:	39 07       	cpc	r19, r25
    1ce8:	b8 f4       	brcc	.+46     	; 0x1d18 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1cea:	81 e0       	ldi	r24, 0x01	; 1
    1cec:	89 83       	std	Y+1, r24	; 0x01
    1cee:	14 c0       	rjmp	.+40     	; 0x1d18 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1cf0:	ed 81       	ldd	r30, Y+5	; 0x05
    1cf2:	fe 81       	ldd	r31, Y+6	; 0x06
    1cf4:	20 81       	ld	r18, Z
    1cf6:	31 81       	ldd	r19, Z+1	; 0x01
    1cf8:	8b 81       	ldd	r24, Y+3	; 0x03
    1cfa:	9c 81       	ldd	r25, Y+4	; 0x04
    1cfc:	82 17       	cp	r24, r18
    1cfe:	93 07       	cpc	r25, r19
    1d00:	48 f0       	brcs	.+18     	; 0x1d14 <vTaskDelayUntil+0x9a>
    1d02:	20 91 18 03 	lds	r18, 0x0318
    1d06:	30 91 19 03 	lds	r19, 0x0319
    1d0a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d0c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d0e:	28 17       	cp	r18, r24
    1d10:	39 07       	cpc	r19, r25
    1d12:	10 f4       	brcc	.+4      	; 0x1d18 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1d14:	81 e0       	ldi	r24, 0x01	; 1
    1d16:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1d18:	ed 81       	ldd	r30, Y+5	; 0x05
    1d1a:	fe 81       	ldd	r31, Y+6	; 0x06
    1d1c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d1e:	9c 81       	ldd	r25, Y+4	; 0x04
    1d20:	91 83       	std	Z+1, r25	; 0x01
    1d22:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1d24:	89 81       	ldd	r24, Y+1	; 0x01
    1d26:	88 23       	and	r24, r24
    1d28:	59 f0       	breq	.+22     	; 0x1d40 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1d2a:	80 91 14 03 	lds	r24, 0x0314
    1d2e:	90 91 15 03 	lds	r25, 0x0315
    1d32:	02 96       	adiw	r24, 0x02	; 2
    1d34:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1d38:	8b 81       	ldd	r24, Y+3	; 0x03
    1d3a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d3c:	0e 94 08 14 	call	0x2810	; 0x2810 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1d40:	0e 94 14 10 	call	0x2028	; 0x2028 <xTaskResumeAll>
    1d44:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1d46:	8a 81       	ldd	r24, Y+2	; 0x02
    1d48:	88 23       	and	r24, r24
    1d4a:	11 f4       	brne	.+4      	; 0x1d50 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    1d4c:	0e 94 59 07 	call	0xeb2	; 0xeb2 <vPortYield>
		}
	}
    1d50:	28 96       	adiw	r28, 0x08	; 8
    1d52:	0f b6       	in	r0, 0x3f	; 63
    1d54:	f8 94       	cli
    1d56:	de bf       	out	0x3e, r29	; 62
    1d58:	0f be       	out	0x3f, r0	; 63
    1d5a:	cd bf       	out	0x3d, r28	; 61
    1d5c:	cf 91       	pop	r28
    1d5e:	df 91       	pop	r29
    1d60:	08 95       	ret

00001d62 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1d62:	df 93       	push	r29
    1d64:	cf 93       	push	r28
    1d66:	00 d0       	rcall	.+0      	; 0x1d68 <vTaskDelay+0x6>
    1d68:	00 d0       	rcall	.+0      	; 0x1d6a <vTaskDelay+0x8>
    1d6a:	0f 92       	push	r0
    1d6c:	cd b7       	in	r28, 0x3d	; 61
    1d6e:	de b7       	in	r29, 0x3e	; 62
    1d70:	9d 83       	std	Y+5, r25	; 0x05
    1d72:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1d74:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1d76:	8c 81       	ldd	r24, Y+4	; 0x04
    1d78:	9d 81       	ldd	r25, Y+5	; 0x05
    1d7a:	00 97       	sbiw	r24, 0x00	; 0
    1d7c:	d1 f0       	breq	.+52     	; 0x1db2 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    1d7e:	0e 94 08 10 	call	0x2010	; 0x2010 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1d82:	20 91 18 03 	lds	r18, 0x0318
    1d86:	30 91 19 03 	lds	r19, 0x0319
    1d8a:	8c 81       	ldd	r24, Y+4	; 0x04
    1d8c:	9d 81       	ldd	r25, Y+5	; 0x05
    1d8e:	82 0f       	add	r24, r18
    1d90:	93 1f       	adc	r25, r19
    1d92:	9b 83       	std	Y+3, r25	; 0x03
    1d94:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1d96:	80 91 14 03 	lds	r24, 0x0314
    1d9a:	90 91 15 03 	lds	r25, 0x0315
    1d9e:	02 96       	adiw	r24, 0x02	; 2
    1da0:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1da4:	8a 81       	ldd	r24, Y+2	; 0x02
    1da6:	9b 81       	ldd	r25, Y+3	; 0x03
    1da8:	0e 94 08 14 	call	0x2810	; 0x2810 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1dac:	0e 94 14 10 	call	0x2028	; 0x2028 <xTaskResumeAll>
    1db0:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1db2:	89 81       	ldd	r24, Y+1	; 0x01
    1db4:	88 23       	and	r24, r24
    1db6:	11 f4       	brne	.+4      	; 0x1dbc <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    1db8:	0e 94 59 07 	call	0xeb2	; 0xeb2 <vPortYield>
		}
	}
    1dbc:	0f 90       	pop	r0
    1dbe:	0f 90       	pop	r0
    1dc0:	0f 90       	pop	r0
    1dc2:	0f 90       	pop	r0
    1dc4:	0f 90       	pop	r0
    1dc6:	cf 91       	pop	r28
    1dc8:	df 91       	pop	r29
    1dca:	08 95       	ret

00001dcc <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
    1dcc:	df 93       	push	r29
    1dce:	cf 93       	push	r28
    1dd0:	cd b7       	in	r28, 0x3d	; 61
    1dd2:	de b7       	in	r29, 0x3e	; 62
    1dd4:	27 97       	sbiw	r28, 0x07	; 7
    1dd6:	0f b6       	in	r0, 0x3f	; 63
    1dd8:	f8 94       	cli
    1dda:	de bf       	out	0x3e, r29	; 62
    1ddc:	0f be       	out	0x3f, r0	; 63
    1dde:	cd bf       	out	0x3d, r28	; 61
    1de0:	9d 83       	std	Y+5, r25	; 0x05
    1de2:	8c 83       	std	Y+4, r24	; 0x04
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
    1de4:	0f b6       	in	r0, 0x3f	; 63
    1de6:	f8 94       	cli
    1de8:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1dea:	8c 81       	ldd	r24, Y+4	; 0x04
    1dec:	9d 81       	ldd	r25, Y+5	; 0x05
    1dee:	00 97       	sbiw	r24, 0x00	; 0
    1df0:	39 f4       	brne	.+14     	; 0x1e00 <uxTaskPriorityGet+0x34>
    1df2:	80 91 14 03 	lds	r24, 0x0314
    1df6:	90 91 15 03 	lds	r25, 0x0315
    1dfa:	9f 83       	std	Y+7, r25	; 0x07
    1dfc:	8e 83       	std	Y+6, r24	; 0x06
    1dfe:	04 c0       	rjmp	.+8      	; 0x1e08 <uxTaskPriorityGet+0x3c>
    1e00:	8c 81       	ldd	r24, Y+4	; 0x04
    1e02:	9d 81       	ldd	r25, Y+5	; 0x05
    1e04:	9f 83       	std	Y+7, r25	; 0x07
    1e06:	8e 83       	std	Y+6, r24	; 0x06
    1e08:	8e 81       	ldd	r24, Y+6	; 0x06
    1e0a:	9f 81       	ldd	r25, Y+7	; 0x07
    1e0c:	9b 83       	std	Y+3, r25	; 0x03
    1e0e:	8a 83       	std	Y+2, r24	; 0x02
			uxReturn = pxTCB->uxPriority;
    1e10:	ea 81       	ldd	r30, Y+2	; 0x02
    1e12:	fb 81       	ldd	r31, Y+3	; 0x03
    1e14:	86 89       	ldd	r24, Z+22	; 0x16
    1e16:	89 83       	std	Y+1, r24	; 0x01
		}
		taskEXIT_CRITICAL();
    1e18:	0f 90       	pop	r0
    1e1a:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
    1e1c:	89 81       	ldd	r24, Y+1	; 0x01
	}
    1e1e:	27 96       	adiw	r28, 0x07	; 7
    1e20:	0f b6       	in	r0, 0x3f	; 63
    1e22:	f8 94       	cli
    1e24:	de bf       	out	0x3e, r29	; 62
    1e26:	0f be       	out	0x3f, r0	; 63
    1e28:	cd bf       	out	0x3d, r28	; 61
    1e2a:	cf 91       	pop	r28
    1e2c:	df 91       	pop	r29
    1e2e:	08 95       	ret

00001e30 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    1e30:	df 93       	push	r29
    1e32:	cf 93       	push	r28
    1e34:	cd b7       	in	r28, 0x3d	; 61
    1e36:	de b7       	in	r29, 0x3e	; 62
    1e38:	29 97       	sbiw	r28, 0x09	; 9
    1e3a:	0f b6       	in	r0, 0x3f	; 63
    1e3c:	f8 94       	cli
    1e3e:	de bf       	out	0x3e, r29	; 62
    1e40:	0f be       	out	0x3f, r0	; 63
    1e42:	cd bf       	out	0x3d, r28	; 61
    1e44:	9e 83       	std	Y+6, r25	; 0x06
    1e46:	8d 83       	std	Y+5, r24	; 0x05
    1e48:	6f 83       	std	Y+7, r22	; 0x07
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentPriority;
	portBASE_TYPE xYieldRequired = pdFALSE;
    1e4a:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= configMAX_PRIORITIES )
    1e4c:	8f 81       	ldd	r24, Y+7	; 0x07
    1e4e:	85 30       	cpi	r24, 0x05	; 5
    1e50:	10 f0       	brcs	.+4      	; 0x1e56 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    1e52:	84 e0       	ldi	r24, 0x04	; 4
    1e54:	8f 83       	std	Y+7, r24	; 0x07
		}

		taskENTER_CRITICAL();
    1e56:	0f b6       	in	r0, 0x3f	; 63
    1e58:	f8 94       	cli
    1e5a:	0f 92       	push	r0
		{
			if( pxTask == pxCurrentTCB )
    1e5c:	20 91 14 03 	lds	r18, 0x0314
    1e60:	30 91 15 03 	lds	r19, 0x0315
    1e64:	8d 81       	ldd	r24, Y+5	; 0x05
    1e66:	9e 81       	ldd	r25, Y+6	; 0x06
    1e68:	82 17       	cp	r24, r18
    1e6a:	93 07       	cpc	r25, r19
    1e6c:	11 f4       	brne	.+4      	; 0x1e72 <vTaskPrioritySet+0x42>
			{
				pxTask = NULL;
    1e6e:	1e 82       	std	Y+6, r1	; 0x06
    1e70:	1d 82       	std	Y+5, r1	; 0x05
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1e72:	8d 81       	ldd	r24, Y+5	; 0x05
    1e74:	9e 81       	ldd	r25, Y+6	; 0x06
    1e76:	00 97       	sbiw	r24, 0x00	; 0
    1e78:	39 f4       	brne	.+14     	; 0x1e88 <vTaskPrioritySet+0x58>
    1e7a:	80 91 14 03 	lds	r24, 0x0314
    1e7e:	90 91 15 03 	lds	r25, 0x0315
    1e82:	99 87       	std	Y+9, r25	; 0x09
    1e84:	88 87       	std	Y+8, r24	; 0x08
    1e86:	04 c0       	rjmp	.+8      	; 0x1e90 <vTaskPrioritySet+0x60>
    1e88:	8d 81       	ldd	r24, Y+5	; 0x05
    1e8a:	9e 81       	ldd	r25, Y+6	; 0x06
    1e8c:	99 87       	std	Y+9, r25	; 0x09
    1e8e:	88 87       	std	Y+8, r24	; 0x08
    1e90:	88 85       	ldd	r24, Y+8	; 0x08
    1e92:	99 85       	ldd	r25, Y+9	; 0x09
    1e94:	9c 83       	std	Y+4, r25	; 0x04
    1e96:	8b 83       	std	Y+3, r24	; 0x03
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentPriority = pxTCB->uxPriority;
    1e98:	eb 81       	ldd	r30, Y+3	; 0x03
    1e9a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e9c:	86 89       	ldd	r24, Z+22	; 0x16
    1e9e:	8a 83       	std	Y+2, r24	; 0x02
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    1ea0:	9a 81       	ldd	r25, Y+2	; 0x02
    1ea2:	8f 81       	ldd	r24, Y+7	; 0x07
    1ea4:	98 17       	cp	r25, r24
    1ea6:	09 f4       	brne	.+2      	; 0x1eaa <vTaskPrioritySet+0x7a>
    1ea8:	65 c0       	rjmp	.+202    	; 0x1f74 <vTaskPrioritySet+0x144>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    1eaa:	9f 81       	ldd	r25, Y+7	; 0x07
    1eac:	8a 81       	ldd	r24, Y+2	; 0x02
    1eae:	89 17       	cp	r24, r25
    1eb0:	38 f4       	brcc	.+14     	; 0x1ec0 <vTaskPrioritySet+0x90>
				{
					if( pxTask != NULL )
    1eb2:	8d 81       	ldd	r24, Y+5	; 0x05
    1eb4:	9e 81       	ldd	r25, Y+6	; 0x06
    1eb6:	00 97       	sbiw	r24, 0x00	; 0
    1eb8:	49 f0       	breq	.+18     	; 0x1ecc <vTaskPrioritySet+0x9c>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    1eba:	81 e0       	ldi	r24, 0x01	; 1
    1ebc:	89 83       	std	Y+1, r24	; 0x01
    1ebe:	06 c0       	rjmp	.+12     	; 0x1ecc <vTaskPrioritySet+0x9c>
					}
				}
				else if( pxTask == NULL )
    1ec0:	8d 81       	ldd	r24, Y+5	; 0x05
    1ec2:	9e 81       	ldd	r25, Y+6	; 0x06
    1ec4:	00 97       	sbiw	r24, 0x00	; 0
    1ec6:	11 f4       	brne	.+4      	; 0x1ecc <vTaskPrioritySet+0x9c>
				{
					/* Setting our own priority down means there may now be another
					task of higher priority that is ready to execute. */
					xYieldRequired = pdTRUE;
    1ec8:	81 e0       	ldi	r24, 0x01	; 1
    1eca:	89 83       	std	Y+1, r24	; 0x01
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    1ecc:	eb 81       	ldd	r30, Y+3	; 0x03
    1ece:	fc 81       	ldd	r31, Y+4	; 0x04
    1ed0:	8f 81       	ldd	r24, Y+7	; 0x07
    1ed2:	86 8b       	std	Z+22, r24	; 0x16
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    1ed4:	8f 81       	ldd	r24, Y+7	; 0x07
    1ed6:	28 2f       	mov	r18, r24
    1ed8:	30 e0       	ldi	r19, 0x00	; 0
    1eda:	85 e0       	ldi	r24, 0x05	; 5
    1edc:	90 e0       	ldi	r25, 0x00	; 0
    1ede:	82 1b       	sub	r24, r18
    1ee0:	93 0b       	sbc	r25, r19
    1ee2:	eb 81       	ldd	r30, Y+3	; 0x03
    1ee4:	fc 81       	ldd	r31, Y+4	; 0x04
    1ee6:	95 87       	std	Z+13, r25	; 0x0d
    1ee8:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    1eea:	eb 81       	ldd	r30, Y+3	; 0x03
    1eec:	fc 81       	ldd	r31, Y+4	; 0x04
    1eee:	42 85       	ldd	r20, Z+10	; 0x0a
    1ef0:	53 85       	ldd	r21, Z+11	; 0x0b
    1ef2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ef4:	28 2f       	mov	r18, r24
    1ef6:	30 e0       	ldi	r19, 0x00	; 0
    1ef8:	c9 01       	movw	r24, r18
    1efa:	88 0f       	add	r24, r24
    1efc:	99 1f       	adc	r25, r25
    1efe:	88 0f       	add	r24, r24
    1f00:	99 1f       	adc	r25, r25
    1f02:	88 0f       	add	r24, r24
    1f04:	99 1f       	adc	r25, r25
    1f06:	82 0f       	add	r24, r18
    1f08:	93 1f       	adc	r25, r19
    1f0a:	8e 5d       	subi	r24, 0xDE	; 222
    1f0c:	9c 4f       	sbci	r25, 0xFC	; 252
    1f0e:	48 17       	cp	r20, r24
    1f10:	59 07       	cpc	r21, r25
    1f12:	59 f5       	brne	.+86     	; 0x1f6a <vTaskPrioritySet+0x13a>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    1f14:	8b 81       	ldd	r24, Y+3	; 0x03
    1f16:	9c 81       	ldd	r25, Y+4	; 0x04
    1f18:	02 96       	adiw	r24, 0x02	; 2
    1f1a:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1f1e:	eb 81       	ldd	r30, Y+3	; 0x03
    1f20:	fc 81       	ldd	r31, Y+4	; 0x04
    1f22:	96 89       	ldd	r25, Z+22	; 0x16
    1f24:	80 91 1b 03 	lds	r24, 0x031B
    1f28:	89 17       	cp	r24, r25
    1f2a:	28 f4       	brcc	.+10     	; 0x1f36 <vTaskPrioritySet+0x106>
    1f2c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f2e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f30:	86 89       	ldd	r24, Z+22	; 0x16
    1f32:	80 93 1b 03 	sts	0x031B, r24
    1f36:	eb 81       	ldd	r30, Y+3	; 0x03
    1f38:	fc 81       	ldd	r31, Y+4	; 0x04
    1f3a:	86 89       	ldd	r24, Z+22	; 0x16
    1f3c:	28 2f       	mov	r18, r24
    1f3e:	30 e0       	ldi	r19, 0x00	; 0
    1f40:	c9 01       	movw	r24, r18
    1f42:	88 0f       	add	r24, r24
    1f44:	99 1f       	adc	r25, r25
    1f46:	88 0f       	add	r24, r24
    1f48:	99 1f       	adc	r25, r25
    1f4a:	88 0f       	add	r24, r24
    1f4c:	99 1f       	adc	r25, r25
    1f4e:	82 0f       	add	r24, r18
    1f50:	93 1f       	adc	r25, r19
    1f52:	ac 01       	movw	r20, r24
    1f54:	4e 5d       	subi	r20, 0xDE	; 222
    1f56:	5c 4f       	sbci	r21, 0xFC	; 252
    1f58:	8b 81       	ldd	r24, Y+3	; 0x03
    1f5a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f5c:	9c 01       	movw	r18, r24
    1f5e:	2e 5f       	subi	r18, 0xFE	; 254
    1f60:	3f 4f       	sbci	r19, 0xFF	; 255
    1f62:	ca 01       	movw	r24, r20
    1f64:	b9 01       	movw	r22, r18
    1f66:	0e 94 99 04 	call	0x932	; 0x932 <vListInsertEnd>
				}

				if( xYieldRequired == pdTRUE )
    1f6a:	89 81       	ldd	r24, Y+1	; 0x01
    1f6c:	81 30       	cpi	r24, 0x01	; 1
    1f6e:	11 f4       	brne	.+4      	; 0x1f74 <vTaskPrioritySet+0x144>
				{
					portYIELD_WITHIN_API();
    1f70:	0e 94 59 07 	call	0xeb2	; 0xeb2 <vPortYield>
				}
			}
		}
		taskEXIT_CRITICAL();
    1f74:	0f 90       	pop	r0
    1f76:	0f be       	out	0x3f, r0	; 63
	}
    1f78:	29 96       	adiw	r28, 0x09	; 9
    1f7a:	0f b6       	in	r0, 0x3f	; 63
    1f7c:	f8 94       	cli
    1f7e:	de bf       	out	0x3e, r29	; 62
    1f80:	0f be       	out	0x3f, r0	; 63
    1f82:	cd bf       	out	0x3d, r28	; 61
    1f84:	cf 91       	pop	r28
    1f86:	df 91       	pop	r29
    1f88:	08 95       	ret

00001f8a <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1f8a:	af 92       	push	r10
    1f8c:	bf 92       	push	r11
    1f8e:	cf 92       	push	r12
    1f90:	df 92       	push	r13
    1f92:	ef 92       	push	r14
    1f94:	ff 92       	push	r15
    1f96:	0f 93       	push	r16
    1f98:	df 93       	push	r29
    1f9a:	cf 93       	push	r28
    1f9c:	0f 92       	push	r0
    1f9e:	cd b7       	in	r28, 0x3d	; 61
    1fa0:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1fa2:	23 e7       	ldi	r18, 0x73	; 115
    1fa4:	30 e0       	ldi	r19, 0x00	; 0
    1fa6:	8c e2       	ldi	r24, 0x2C	; 44
    1fa8:	93 e1       	ldi	r25, 0x13	; 19
    1faa:	b9 01       	movw	r22, r18
    1fac:	45 e5       	ldi	r20, 0x55	; 85
    1fae:	50 e0       	ldi	r21, 0x00	; 0
    1fb0:	20 e0       	ldi	r18, 0x00	; 0
    1fb2:	30 e0       	ldi	r19, 0x00	; 0
    1fb4:	00 e0       	ldi	r16, 0x00	; 0
    1fb6:	ee 24       	eor	r14, r14
    1fb8:	ff 24       	eor	r15, r15
    1fba:	cc 24       	eor	r12, r12
    1fbc:	dd 24       	eor	r13, r13
    1fbe:	aa 24       	eor	r10, r10
    1fc0:	bb 24       	eor	r11, r11
    1fc2:	0e 94 ed 0c 	call	0x19da	; 0x19da <xTaskGenericCreate>
    1fc6:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1fc8:	89 81       	ldd	r24, Y+1	; 0x01
    1fca:	81 30       	cpi	r24, 0x01	; 1
    1fcc:	51 f4       	brne	.+20     	; 0x1fe2 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1fce:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1fd0:	81 e0       	ldi	r24, 0x01	; 1
    1fd2:	80 93 1c 03 	sts	0x031C, r24
		xTickCount = ( portTickType ) 0U;
    1fd6:	10 92 19 03 	sts	0x0319, r1
    1fda:	10 92 18 03 	sts	0x0318, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1fde:	0e 94 1d 07 	call	0xe3a	; 0xe3a <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1fe2:	0f 90       	pop	r0
    1fe4:	cf 91       	pop	r28
    1fe6:	df 91       	pop	r29
    1fe8:	0f 91       	pop	r16
    1fea:	ff 90       	pop	r15
    1fec:	ef 90       	pop	r14
    1fee:	df 90       	pop	r13
    1ff0:	cf 90       	pop	r12
    1ff2:	bf 90       	pop	r11
    1ff4:	af 90       	pop	r10
    1ff6:	08 95       	ret

00001ff8 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    1ff8:	df 93       	push	r29
    1ffa:	cf 93       	push	r28
    1ffc:	cd b7       	in	r28, 0x3d	; 61
    1ffe:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2000:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2002:	10 92 1c 03 	sts	0x031C, r1
	vPortEndScheduler();
    2006:	0e 94 52 07 	call	0xea4	; 0xea4 <vPortEndScheduler>
}
    200a:	cf 91       	pop	r28
    200c:	df 91       	pop	r29
    200e:	08 95       	ret

00002010 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2010:	df 93       	push	r29
    2012:	cf 93       	push	r28
    2014:	cd b7       	in	r28, 0x3d	; 61
    2016:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2018:	80 91 1d 03 	lds	r24, 0x031D
    201c:	8f 5f       	subi	r24, 0xFF	; 255
    201e:	80 93 1d 03 	sts	0x031D, r24
}
    2022:	cf 91       	pop	r28
    2024:	df 91       	pop	r29
    2026:	08 95       	ret

00002028 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2028:	df 93       	push	r29
    202a:	cf 93       	push	r28
    202c:	00 d0       	rcall	.+0      	; 0x202e <xTaskResumeAll+0x6>
    202e:	00 d0       	rcall	.+0      	; 0x2030 <xTaskResumeAll+0x8>
    2030:	cd b7       	in	r28, 0x3d	; 61
    2032:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2034:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2036:	0f b6       	in	r0, 0x3f	; 63
    2038:	f8 94       	cli
    203a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    203c:	80 91 1d 03 	lds	r24, 0x031D
    2040:	81 50       	subi	r24, 0x01	; 1
    2042:	80 93 1d 03 	sts	0x031D, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2046:	80 91 1d 03 	lds	r24, 0x031D
    204a:	88 23       	and	r24, r24
    204c:	09 f0       	breq	.+2      	; 0x2050 <xTaskResumeAll+0x28>
    204e:	6c c0       	rjmp	.+216    	; 0x2128 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2050:	80 91 17 03 	lds	r24, 0x0317
    2054:	88 23       	and	r24, r24
    2056:	09 f4       	brne	.+2      	; 0x205a <xTaskResumeAll+0x32>
    2058:	67 c0       	rjmp	.+206    	; 0x2128 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    205a:	19 82       	std	Y+1, r1	; 0x01
    205c:	41 c0       	rjmp	.+130    	; 0x20e0 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    205e:	e0 91 6a 03 	lds	r30, 0x036A
    2062:	f0 91 6b 03 	lds	r31, 0x036B
    2066:	86 81       	ldd	r24, Z+6	; 0x06
    2068:	97 81       	ldd	r25, Z+7	; 0x07
    206a:	9c 83       	std	Y+4, r25	; 0x04
    206c:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    206e:	8b 81       	ldd	r24, Y+3	; 0x03
    2070:	9c 81       	ldd	r25, Y+4	; 0x04
    2072:	0c 96       	adiw	r24, 0x0c	; 12
    2074:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2078:	8b 81       	ldd	r24, Y+3	; 0x03
    207a:	9c 81       	ldd	r25, Y+4	; 0x04
    207c:	02 96       	adiw	r24, 0x02	; 2
    207e:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2082:	eb 81       	ldd	r30, Y+3	; 0x03
    2084:	fc 81       	ldd	r31, Y+4	; 0x04
    2086:	96 89       	ldd	r25, Z+22	; 0x16
    2088:	80 91 1b 03 	lds	r24, 0x031B
    208c:	89 17       	cp	r24, r25
    208e:	28 f4       	brcc	.+10     	; 0x209a <xTaskResumeAll+0x72>
    2090:	eb 81       	ldd	r30, Y+3	; 0x03
    2092:	fc 81       	ldd	r31, Y+4	; 0x04
    2094:	86 89       	ldd	r24, Z+22	; 0x16
    2096:	80 93 1b 03 	sts	0x031B, r24
    209a:	eb 81       	ldd	r30, Y+3	; 0x03
    209c:	fc 81       	ldd	r31, Y+4	; 0x04
    209e:	86 89       	ldd	r24, Z+22	; 0x16
    20a0:	28 2f       	mov	r18, r24
    20a2:	30 e0       	ldi	r19, 0x00	; 0
    20a4:	c9 01       	movw	r24, r18
    20a6:	88 0f       	add	r24, r24
    20a8:	99 1f       	adc	r25, r25
    20aa:	88 0f       	add	r24, r24
    20ac:	99 1f       	adc	r25, r25
    20ae:	88 0f       	add	r24, r24
    20b0:	99 1f       	adc	r25, r25
    20b2:	82 0f       	add	r24, r18
    20b4:	93 1f       	adc	r25, r19
    20b6:	8e 5d       	subi	r24, 0xDE	; 222
    20b8:	9c 4f       	sbci	r25, 0xFC	; 252
    20ba:	2b 81       	ldd	r18, Y+3	; 0x03
    20bc:	3c 81       	ldd	r19, Y+4	; 0x04
    20be:	2e 5f       	subi	r18, 0xFE	; 254
    20c0:	3f 4f       	sbci	r19, 0xFF	; 255
    20c2:	b9 01       	movw	r22, r18
    20c4:	0e 94 99 04 	call	0x932	; 0x932 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    20c8:	eb 81       	ldd	r30, Y+3	; 0x03
    20ca:	fc 81       	ldd	r31, Y+4	; 0x04
    20cc:	96 89       	ldd	r25, Z+22	; 0x16
    20ce:	e0 91 14 03 	lds	r30, 0x0314
    20d2:	f0 91 15 03 	lds	r31, 0x0315
    20d6:	86 89       	ldd	r24, Z+22	; 0x16
    20d8:	98 17       	cp	r25, r24
    20da:	10 f0       	brcs	.+4      	; 0x20e0 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    20dc:	81 e0       	ldi	r24, 0x01	; 1
    20de:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    20e0:	80 91 65 03 	lds	r24, 0x0365
    20e4:	88 23       	and	r24, r24
    20e6:	09 f0       	breq	.+2      	; 0x20ea <xTaskResumeAll+0xc2>
    20e8:	ba cf       	rjmp	.-140    	; 0x205e <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    20ea:	80 91 1e 03 	lds	r24, 0x031E
    20ee:	88 23       	and	r24, r24
    20f0:	71 f0       	breq	.+28     	; 0x210e <xTaskResumeAll+0xe6>
    20f2:	07 c0       	rjmp	.+14     	; 0x2102 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    20f4:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <vTaskIncrementTick>
						--uxMissedTicks;
    20f8:	80 91 1e 03 	lds	r24, 0x031E
    20fc:	81 50       	subi	r24, 0x01	; 1
    20fe:	80 93 1e 03 	sts	0x031E, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2102:	80 91 1e 03 	lds	r24, 0x031E
    2106:	88 23       	and	r24, r24
    2108:	a9 f7       	brne	.-22     	; 0x20f4 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    210a:	81 e0       	ldi	r24, 0x01	; 1
    210c:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    210e:	89 81       	ldd	r24, Y+1	; 0x01
    2110:	81 30       	cpi	r24, 0x01	; 1
    2112:	21 f0       	breq	.+8      	; 0x211c <xTaskResumeAll+0xf4>
    2114:	80 91 1f 03 	lds	r24, 0x031F
    2118:	81 30       	cpi	r24, 0x01	; 1
    211a:	31 f4       	brne	.+12     	; 0x2128 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    211c:	81 e0       	ldi	r24, 0x01	; 1
    211e:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    2120:	10 92 1f 03 	sts	0x031F, r1
					portYIELD_WITHIN_API();
    2124:	0e 94 59 07 	call	0xeb2	; 0xeb2 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2128:	0f 90       	pop	r0
    212a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    212c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    212e:	0f 90       	pop	r0
    2130:	0f 90       	pop	r0
    2132:	0f 90       	pop	r0
    2134:	0f 90       	pop	r0
    2136:	cf 91       	pop	r28
    2138:	df 91       	pop	r29
    213a:	08 95       	ret

0000213c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    213c:	df 93       	push	r29
    213e:	cf 93       	push	r28
    2140:	00 d0       	rcall	.+0      	; 0x2142 <xTaskGetTickCount+0x6>
    2142:	cd b7       	in	r28, 0x3d	; 61
    2144:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2146:	0f b6       	in	r0, 0x3f	; 63
    2148:	f8 94       	cli
    214a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    214c:	80 91 18 03 	lds	r24, 0x0318
    2150:	90 91 19 03 	lds	r25, 0x0319
    2154:	9a 83       	std	Y+2, r25	; 0x02
    2156:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2158:	0f 90       	pop	r0
    215a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    215c:	89 81       	ldd	r24, Y+1	; 0x01
    215e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2160:	0f 90       	pop	r0
    2162:	0f 90       	pop	r0
    2164:	cf 91       	pop	r28
    2166:	df 91       	pop	r29
    2168:	08 95       	ret

0000216a <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    216a:	df 93       	push	r29
    216c:	cf 93       	push	r28
    216e:	00 d0       	rcall	.+0      	; 0x2170 <xTaskGetTickCountFromISR+0x6>
    2170:	0f 92       	push	r0
    2172:	cd b7       	in	r28, 0x3d	; 61
    2174:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2176:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    2178:	80 91 18 03 	lds	r24, 0x0318
    217c:	90 91 19 03 	lds	r25, 0x0319
    2180:	9b 83       	std	Y+3, r25	; 0x03
    2182:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2184:	8a 81       	ldd	r24, Y+2	; 0x02
    2186:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2188:	0f 90       	pop	r0
    218a:	0f 90       	pop	r0
    218c:	0f 90       	pop	r0
    218e:	cf 91       	pop	r28
    2190:	df 91       	pop	r29
    2192:	08 95       	ret

00002194 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    2194:	df 93       	push	r29
    2196:	cf 93       	push	r28
    2198:	cd b7       	in	r28, 0x3d	; 61
    219a:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    219c:	80 91 17 03 	lds	r24, 0x0317
}
    21a0:	cf 91       	pop	r28
    21a2:	df 91       	pop	r29
    21a4:	08 95       	ret

000021a6 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    21a6:	df 93       	push	r29
    21a8:	cf 93       	push	r28
    21aa:	00 d0       	rcall	.+0      	; 0x21ac <vTaskIncrementTick+0x6>
    21ac:	00 d0       	rcall	.+0      	; 0x21ae <vTaskIncrementTick+0x8>
    21ae:	00 d0       	rcall	.+0      	; 0x21b0 <vTaskIncrementTick+0xa>
    21b0:	cd b7       	in	r28, 0x3d	; 61
    21b2:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    21b4:	80 91 1d 03 	lds	r24, 0x031D
    21b8:	88 23       	and	r24, r24
    21ba:	09 f0       	breq	.+2      	; 0x21be <vTaskIncrementTick+0x18>
    21bc:	bb c0       	rjmp	.+374    	; 0x2334 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    21be:	80 91 18 03 	lds	r24, 0x0318
    21c2:	90 91 19 03 	lds	r25, 0x0319
    21c6:	01 96       	adiw	r24, 0x01	; 1
    21c8:	90 93 19 03 	sts	0x0319, r25
    21cc:	80 93 18 03 	sts	0x0318, r24
		if( xTickCount == ( portTickType ) 0U )
    21d0:	80 91 18 03 	lds	r24, 0x0318
    21d4:	90 91 19 03 	lds	r25, 0x0319
    21d8:	00 97       	sbiw	r24, 0x00	; 0
    21da:	d1 f5       	brne	.+116    	; 0x2250 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    21dc:	80 91 61 03 	lds	r24, 0x0361
    21e0:	90 91 62 03 	lds	r25, 0x0362
    21e4:	9c 83       	std	Y+4, r25	; 0x04
    21e6:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    21e8:	80 91 63 03 	lds	r24, 0x0363
    21ec:	90 91 64 03 	lds	r25, 0x0364
    21f0:	90 93 62 03 	sts	0x0362, r25
    21f4:	80 93 61 03 	sts	0x0361, r24
			pxOverflowDelayedTaskList = pxTemp;
    21f8:	8b 81       	ldd	r24, Y+3	; 0x03
    21fa:	9c 81       	ldd	r25, Y+4	; 0x04
    21fc:	90 93 64 03 	sts	0x0364, r25
    2200:	80 93 63 03 	sts	0x0363, r24
			xNumOfOverflows++;
    2204:	80 91 20 03 	lds	r24, 0x0320
    2208:	8f 5f       	subi	r24, 0xFF	; 255
    220a:	80 93 20 03 	sts	0x0320, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    220e:	e0 91 61 03 	lds	r30, 0x0361
    2212:	f0 91 62 03 	lds	r31, 0x0362
    2216:	80 81       	ld	r24, Z
    2218:	88 23       	and	r24, r24
    221a:	39 f4       	brne	.+14     	; 0x222a <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    221c:	8f ef       	ldi	r24, 0xFF	; 255
    221e:	9f ef       	ldi	r25, 0xFF	; 255
    2220:	90 93 79 00 	sts	0x0079, r25
    2224:	80 93 78 00 	sts	0x0078, r24
    2228:	13 c0       	rjmp	.+38     	; 0x2250 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    222a:	e0 91 61 03 	lds	r30, 0x0361
    222e:	f0 91 62 03 	lds	r31, 0x0362
    2232:	05 80       	ldd	r0, Z+5	; 0x05
    2234:	f6 81       	ldd	r31, Z+6	; 0x06
    2236:	e0 2d       	mov	r30, r0
    2238:	86 81       	ldd	r24, Z+6	; 0x06
    223a:	97 81       	ldd	r25, Z+7	; 0x07
    223c:	9e 83       	std	Y+6, r25	; 0x06
    223e:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2240:	ed 81       	ldd	r30, Y+5	; 0x05
    2242:	fe 81       	ldd	r31, Y+6	; 0x06
    2244:	82 81       	ldd	r24, Z+2	; 0x02
    2246:	93 81       	ldd	r25, Z+3	; 0x03
    2248:	90 93 79 00 	sts	0x0079, r25
    224c:	80 93 78 00 	sts	0x0078, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2250:	20 91 18 03 	lds	r18, 0x0318
    2254:	30 91 19 03 	lds	r19, 0x0319
    2258:	80 91 78 00 	lds	r24, 0x0078
    225c:	90 91 79 00 	lds	r25, 0x0079
    2260:	28 17       	cp	r18, r24
    2262:	39 07       	cpc	r19, r25
    2264:	08 f4       	brcc	.+2      	; 0x2268 <vTaskIncrementTick+0xc2>
    2266:	6b c0       	rjmp	.+214    	; 0x233e <vTaskIncrementTick+0x198>
    2268:	e0 91 61 03 	lds	r30, 0x0361
    226c:	f0 91 62 03 	lds	r31, 0x0362
    2270:	80 81       	ld	r24, Z
    2272:	88 23       	and	r24, r24
    2274:	39 f4       	brne	.+14     	; 0x2284 <vTaskIncrementTick+0xde>
    2276:	8f ef       	ldi	r24, 0xFF	; 255
    2278:	9f ef       	ldi	r25, 0xFF	; 255
    227a:	90 93 79 00 	sts	0x0079, r25
    227e:	80 93 78 00 	sts	0x0078, r24
    2282:	5d c0       	rjmp	.+186    	; 0x233e <vTaskIncrementTick+0x198>
    2284:	e0 91 61 03 	lds	r30, 0x0361
    2288:	f0 91 62 03 	lds	r31, 0x0362
    228c:	05 80       	ldd	r0, Z+5	; 0x05
    228e:	f6 81       	ldd	r31, Z+6	; 0x06
    2290:	e0 2d       	mov	r30, r0
    2292:	86 81       	ldd	r24, Z+6	; 0x06
    2294:	97 81       	ldd	r25, Z+7	; 0x07
    2296:	9e 83       	std	Y+6, r25	; 0x06
    2298:	8d 83       	std	Y+5, r24	; 0x05
    229a:	ed 81       	ldd	r30, Y+5	; 0x05
    229c:	fe 81       	ldd	r31, Y+6	; 0x06
    229e:	82 81       	ldd	r24, Z+2	; 0x02
    22a0:	93 81       	ldd	r25, Z+3	; 0x03
    22a2:	9a 83       	std	Y+2, r25	; 0x02
    22a4:	89 83       	std	Y+1, r24	; 0x01
    22a6:	20 91 18 03 	lds	r18, 0x0318
    22aa:	30 91 19 03 	lds	r19, 0x0319
    22ae:	89 81       	ldd	r24, Y+1	; 0x01
    22b0:	9a 81       	ldd	r25, Y+2	; 0x02
    22b2:	28 17       	cp	r18, r24
    22b4:	39 07       	cpc	r19, r25
    22b6:	38 f4       	brcc	.+14     	; 0x22c6 <vTaskIncrementTick+0x120>
    22b8:	89 81       	ldd	r24, Y+1	; 0x01
    22ba:	9a 81       	ldd	r25, Y+2	; 0x02
    22bc:	90 93 79 00 	sts	0x0079, r25
    22c0:	80 93 78 00 	sts	0x0078, r24
    22c4:	3c c0       	rjmp	.+120    	; 0x233e <vTaskIncrementTick+0x198>
    22c6:	8d 81       	ldd	r24, Y+5	; 0x05
    22c8:	9e 81       	ldd	r25, Y+6	; 0x06
    22ca:	02 96       	adiw	r24, 0x02	; 2
    22cc:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>
    22d0:	ed 81       	ldd	r30, Y+5	; 0x05
    22d2:	fe 81       	ldd	r31, Y+6	; 0x06
    22d4:	84 89       	ldd	r24, Z+20	; 0x14
    22d6:	95 89       	ldd	r25, Z+21	; 0x15
    22d8:	00 97       	sbiw	r24, 0x00	; 0
    22da:	29 f0       	breq	.+10     	; 0x22e6 <vTaskIncrementTick+0x140>
    22dc:	8d 81       	ldd	r24, Y+5	; 0x05
    22de:	9e 81       	ldd	r25, Y+6	; 0x06
    22e0:	0c 96       	adiw	r24, 0x0c	; 12
    22e2:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>
    22e6:	ed 81       	ldd	r30, Y+5	; 0x05
    22e8:	fe 81       	ldd	r31, Y+6	; 0x06
    22ea:	96 89       	ldd	r25, Z+22	; 0x16
    22ec:	80 91 1b 03 	lds	r24, 0x031B
    22f0:	89 17       	cp	r24, r25
    22f2:	28 f4       	brcc	.+10     	; 0x22fe <vTaskIncrementTick+0x158>
    22f4:	ed 81       	ldd	r30, Y+5	; 0x05
    22f6:	fe 81       	ldd	r31, Y+6	; 0x06
    22f8:	86 89       	ldd	r24, Z+22	; 0x16
    22fa:	80 93 1b 03 	sts	0x031B, r24
    22fe:	ed 81       	ldd	r30, Y+5	; 0x05
    2300:	fe 81       	ldd	r31, Y+6	; 0x06
    2302:	86 89       	ldd	r24, Z+22	; 0x16
    2304:	28 2f       	mov	r18, r24
    2306:	30 e0       	ldi	r19, 0x00	; 0
    2308:	c9 01       	movw	r24, r18
    230a:	88 0f       	add	r24, r24
    230c:	99 1f       	adc	r25, r25
    230e:	88 0f       	add	r24, r24
    2310:	99 1f       	adc	r25, r25
    2312:	88 0f       	add	r24, r24
    2314:	99 1f       	adc	r25, r25
    2316:	82 0f       	add	r24, r18
    2318:	93 1f       	adc	r25, r19
    231a:	ac 01       	movw	r20, r24
    231c:	4e 5d       	subi	r20, 0xDE	; 222
    231e:	5c 4f       	sbci	r21, 0xFC	; 252
    2320:	8d 81       	ldd	r24, Y+5	; 0x05
    2322:	9e 81       	ldd	r25, Y+6	; 0x06
    2324:	9c 01       	movw	r18, r24
    2326:	2e 5f       	subi	r18, 0xFE	; 254
    2328:	3f 4f       	sbci	r19, 0xFF	; 255
    232a:	ca 01       	movw	r24, r20
    232c:	b9 01       	movw	r22, r18
    232e:	0e 94 99 04 	call	0x932	; 0x932 <vListInsertEnd>
    2332:	9a cf       	rjmp	.-204    	; 0x2268 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    2334:	80 91 1e 03 	lds	r24, 0x031E
    2338:	8f 5f       	subi	r24, 0xFF	; 255
    233a:	80 93 1e 03 	sts	0x031E, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    233e:	26 96       	adiw	r28, 0x06	; 6
    2340:	0f b6       	in	r0, 0x3f	; 63
    2342:	f8 94       	cli
    2344:	de bf       	out	0x3e, r29	; 62
    2346:	0f be       	out	0x3f, r0	; 63
    2348:	cd bf       	out	0x3d, r28	; 61
    234a:	cf 91       	pop	r28
    234c:	df 91       	pop	r29
    234e:	08 95       	ret

00002350 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2350:	df 93       	push	r29
    2352:	cf 93       	push	r28
    2354:	00 d0       	rcall	.+0      	; 0x2356 <vTaskSwitchContext+0x6>
    2356:	cd b7       	in	r28, 0x3d	; 61
    2358:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    235a:	80 91 1d 03 	lds	r24, 0x031D
    235e:	88 23       	and	r24, r24
    2360:	49 f0       	breq	.+18     	; 0x2374 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2362:	81 e0       	ldi	r24, 0x01	; 1
    2364:	80 93 1f 03 	sts	0x031F, r24
    2368:	54 c0       	rjmp	.+168    	; 0x2412 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    236a:	80 91 1b 03 	lds	r24, 0x031B
    236e:	81 50       	subi	r24, 0x01	; 1
    2370:	80 93 1b 03 	sts	0x031B, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2374:	80 91 1b 03 	lds	r24, 0x031B
    2378:	28 2f       	mov	r18, r24
    237a:	30 e0       	ldi	r19, 0x00	; 0
    237c:	c9 01       	movw	r24, r18
    237e:	88 0f       	add	r24, r24
    2380:	99 1f       	adc	r25, r25
    2382:	88 0f       	add	r24, r24
    2384:	99 1f       	adc	r25, r25
    2386:	88 0f       	add	r24, r24
    2388:	99 1f       	adc	r25, r25
    238a:	82 0f       	add	r24, r18
    238c:	93 1f       	adc	r25, r19
    238e:	fc 01       	movw	r30, r24
    2390:	ee 5d       	subi	r30, 0xDE	; 222
    2392:	fc 4f       	sbci	r31, 0xFC	; 252
    2394:	80 81       	ld	r24, Z
    2396:	88 23       	and	r24, r24
    2398:	41 f3       	breq	.-48     	; 0x236a <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    239a:	80 91 1b 03 	lds	r24, 0x031B
    239e:	28 2f       	mov	r18, r24
    23a0:	30 e0       	ldi	r19, 0x00	; 0
    23a2:	c9 01       	movw	r24, r18
    23a4:	88 0f       	add	r24, r24
    23a6:	99 1f       	adc	r25, r25
    23a8:	88 0f       	add	r24, r24
    23aa:	99 1f       	adc	r25, r25
    23ac:	88 0f       	add	r24, r24
    23ae:	99 1f       	adc	r25, r25
    23b0:	82 0f       	add	r24, r18
    23b2:	93 1f       	adc	r25, r19
    23b4:	8e 5d       	subi	r24, 0xDE	; 222
    23b6:	9c 4f       	sbci	r25, 0xFC	; 252
    23b8:	9a 83       	std	Y+2, r25	; 0x02
    23ba:	89 83       	std	Y+1, r24	; 0x01
    23bc:	e9 81       	ldd	r30, Y+1	; 0x01
    23be:	fa 81       	ldd	r31, Y+2	; 0x02
    23c0:	01 80       	ldd	r0, Z+1	; 0x01
    23c2:	f2 81       	ldd	r31, Z+2	; 0x02
    23c4:	e0 2d       	mov	r30, r0
    23c6:	82 81       	ldd	r24, Z+2	; 0x02
    23c8:	93 81       	ldd	r25, Z+3	; 0x03
    23ca:	e9 81       	ldd	r30, Y+1	; 0x01
    23cc:	fa 81       	ldd	r31, Y+2	; 0x02
    23ce:	92 83       	std	Z+2, r25	; 0x02
    23d0:	81 83       	std	Z+1, r24	; 0x01
    23d2:	e9 81       	ldd	r30, Y+1	; 0x01
    23d4:	fa 81       	ldd	r31, Y+2	; 0x02
    23d6:	21 81       	ldd	r18, Z+1	; 0x01
    23d8:	32 81       	ldd	r19, Z+2	; 0x02
    23da:	89 81       	ldd	r24, Y+1	; 0x01
    23dc:	9a 81       	ldd	r25, Y+2	; 0x02
    23de:	03 96       	adiw	r24, 0x03	; 3
    23e0:	28 17       	cp	r18, r24
    23e2:	39 07       	cpc	r19, r25
    23e4:	59 f4       	brne	.+22     	; 0x23fc <vTaskSwitchContext+0xac>
    23e6:	e9 81       	ldd	r30, Y+1	; 0x01
    23e8:	fa 81       	ldd	r31, Y+2	; 0x02
    23ea:	01 80       	ldd	r0, Z+1	; 0x01
    23ec:	f2 81       	ldd	r31, Z+2	; 0x02
    23ee:	e0 2d       	mov	r30, r0
    23f0:	82 81       	ldd	r24, Z+2	; 0x02
    23f2:	93 81       	ldd	r25, Z+3	; 0x03
    23f4:	e9 81       	ldd	r30, Y+1	; 0x01
    23f6:	fa 81       	ldd	r31, Y+2	; 0x02
    23f8:	92 83       	std	Z+2, r25	; 0x02
    23fa:	81 83       	std	Z+1, r24	; 0x01
    23fc:	e9 81       	ldd	r30, Y+1	; 0x01
    23fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2400:	01 80       	ldd	r0, Z+1	; 0x01
    2402:	f2 81       	ldd	r31, Z+2	; 0x02
    2404:	e0 2d       	mov	r30, r0
    2406:	86 81       	ldd	r24, Z+6	; 0x06
    2408:	97 81       	ldd	r25, Z+7	; 0x07
    240a:	90 93 15 03 	sts	0x0315, r25
    240e:	80 93 14 03 	sts	0x0314, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    2412:	0f 90       	pop	r0
    2414:	0f 90       	pop	r0
    2416:	cf 91       	pop	r28
    2418:	df 91       	pop	r29
    241a:	08 95       	ret

0000241c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    241c:	df 93       	push	r29
    241e:	cf 93       	push	r28
    2420:	00 d0       	rcall	.+0      	; 0x2422 <vTaskPlaceOnEventList+0x6>
    2422:	00 d0       	rcall	.+0      	; 0x2424 <vTaskPlaceOnEventList+0x8>
    2424:	00 d0       	rcall	.+0      	; 0x2426 <vTaskPlaceOnEventList+0xa>
    2426:	cd b7       	in	r28, 0x3d	; 61
    2428:	de b7       	in	r29, 0x3e	; 62
    242a:	9c 83       	std	Y+4, r25	; 0x04
    242c:	8b 83       	std	Y+3, r24	; 0x03
    242e:	7e 83       	std	Y+6, r23	; 0x06
    2430:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2432:	4b 81       	ldd	r20, Y+3	; 0x03
    2434:	5c 81       	ldd	r21, Y+4	; 0x04
    2436:	80 91 14 03 	lds	r24, 0x0314
    243a:	90 91 15 03 	lds	r25, 0x0315
    243e:	9c 01       	movw	r18, r24
    2440:	24 5f       	subi	r18, 0xF4	; 244
    2442:	3f 4f       	sbci	r19, 0xFF	; 255
    2444:	ca 01       	movw	r24, r20
    2446:	b9 01       	movw	r22, r18
    2448:	0e 94 e5 04 	call	0x9ca	; 0x9ca <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    244c:	80 91 14 03 	lds	r24, 0x0314
    2450:	90 91 15 03 	lds	r25, 0x0315
    2454:	02 96       	adiw	r24, 0x02	; 2
    2456:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    245a:	20 91 18 03 	lds	r18, 0x0318
    245e:	30 91 19 03 	lds	r19, 0x0319
    2462:	8d 81       	ldd	r24, Y+5	; 0x05
    2464:	9e 81       	ldd	r25, Y+6	; 0x06
    2466:	82 0f       	add	r24, r18
    2468:	93 1f       	adc	r25, r19
    246a:	9a 83       	std	Y+2, r25	; 0x02
    246c:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    246e:	89 81       	ldd	r24, Y+1	; 0x01
    2470:	9a 81       	ldd	r25, Y+2	; 0x02
    2472:	0e 94 08 14 	call	0x2810	; 0x2810 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2476:	26 96       	adiw	r28, 0x06	; 6
    2478:	0f b6       	in	r0, 0x3f	; 63
    247a:	f8 94       	cli
    247c:	de bf       	out	0x3e, r29	; 62
    247e:	0f be       	out	0x3f, r0	; 63
    2480:	cd bf       	out	0x3d, r28	; 61
    2482:	cf 91       	pop	r28
    2484:	df 91       	pop	r29
    2486:	08 95       	ret

00002488 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2488:	df 93       	push	r29
    248a:	cf 93       	push	r28
    248c:	00 d0       	rcall	.+0      	; 0x248e <xTaskRemoveFromEventList+0x6>
    248e:	00 d0       	rcall	.+0      	; 0x2490 <xTaskRemoveFromEventList+0x8>
    2490:	0f 92       	push	r0
    2492:	cd b7       	in	r28, 0x3d	; 61
    2494:	de b7       	in	r29, 0x3e	; 62
    2496:	9d 83       	std	Y+5, r25	; 0x05
    2498:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    249a:	ec 81       	ldd	r30, Y+4	; 0x04
    249c:	fd 81       	ldd	r31, Y+5	; 0x05
    249e:	05 80       	ldd	r0, Z+5	; 0x05
    24a0:	f6 81       	ldd	r31, Z+6	; 0x06
    24a2:	e0 2d       	mov	r30, r0
    24a4:	86 81       	ldd	r24, Z+6	; 0x06
    24a6:	97 81       	ldd	r25, Z+7	; 0x07
    24a8:	9b 83       	std	Y+3, r25	; 0x03
    24aa:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    24ac:	8a 81       	ldd	r24, Y+2	; 0x02
    24ae:	9b 81       	ldd	r25, Y+3	; 0x03
    24b0:	0c 96       	adiw	r24, 0x0c	; 12
    24b2:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    24b6:	80 91 1d 03 	lds	r24, 0x031D
    24ba:	88 23       	and	r24, r24
    24bc:	61 f5       	brne	.+88     	; 0x2516 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    24be:	8a 81       	ldd	r24, Y+2	; 0x02
    24c0:	9b 81       	ldd	r25, Y+3	; 0x03
    24c2:	02 96       	adiw	r24, 0x02	; 2
    24c4:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    24c8:	ea 81       	ldd	r30, Y+2	; 0x02
    24ca:	fb 81       	ldd	r31, Y+3	; 0x03
    24cc:	96 89       	ldd	r25, Z+22	; 0x16
    24ce:	80 91 1b 03 	lds	r24, 0x031B
    24d2:	89 17       	cp	r24, r25
    24d4:	28 f4       	brcc	.+10     	; 0x24e0 <xTaskRemoveFromEventList+0x58>
    24d6:	ea 81       	ldd	r30, Y+2	; 0x02
    24d8:	fb 81       	ldd	r31, Y+3	; 0x03
    24da:	86 89       	ldd	r24, Z+22	; 0x16
    24dc:	80 93 1b 03 	sts	0x031B, r24
    24e0:	ea 81       	ldd	r30, Y+2	; 0x02
    24e2:	fb 81       	ldd	r31, Y+3	; 0x03
    24e4:	86 89       	ldd	r24, Z+22	; 0x16
    24e6:	28 2f       	mov	r18, r24
    24e8:	30 e0       	ldi	r19, 0x00	; 0
    24ea:	c9 01       	movw	r24, r18
    24ec:	88 0f       	add	r24, r24
    24ee:	99 1f       	adc	r25, r25
    24f0:	88 0f       	add	r24, r24
    24f2:	99 1f       	adc	r25, r25
    24f4:	88 0f       	add	r24, r24
    24f6:	99 1f       	adc	r25, r25
    24f8:	82 0f       	add	r24, r18
    24fa:	93 1f       	adc	r25, r19
    24fc:	ac 01       	movw	r20, r24
    24fe:	4e 5d       	subi	r20, 0xDE	; 222
    2500:	5c 4f       	sbci	r21, 0xFC	; 252
    2502:	8a 81       	ldd	r24, Y+2	; 0x02
    2504:	9b 81       	ldd	r25, Y+3	; 0x03
    2506:	9c 01       	movw	r18, r24
    2508:	2e 5f       	subi	r18, 0xFE	; 254
    250a:	3f 4f       	sbci	r19, 0xFF	; 255
    250c:	ca 01       	movw	r24, r20
    250e:	b9 01       	movw	r22, r18
    2510:	0e 94 99 04 	call	0x932	; 0x932 <vListInsertEnd>
    2514:	0a c0       	rjmp	.+20     	; 0x252a <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2516:	8a 81       	ldd	r24, Y+2	; 0x02
    2518:	9b 81       	ldd	r25, Y+3	; 0x03
    251a:	9c 01       	movw	r18, r24
    251c:	24 5f       	subi	r18, 0xF4	; 244
    251e:	3f 4f       	sbci	r19, 0xFF	; 255
    2520:	85 e6       	ldi	r24, 0x65	; 101
    2522:	93 e0       	ldi	r25, 0x03	; 3
    2524:	b9 01       	movw	r22, r18
    2526:	0e 94 99 04 	call	0x932	; 0x932 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    252a:	ea 81       	ldd	r30, Y+2	; 0x02
    252c:	fb 81       	ldd	r31, Y+3	; 0x03
    252e:	96 89       	ldd	r25, Z+22	; 0x16
    2530:	e0 91 14 03 	lds	r30, 0x0314
    2534:	f0 91 15 03 	lds	r31, 0x0315
    2538:	86 89       	ldd	r24, Z+22	; 0x16
    253a:	98 17       	cp	r25, r24
    253c:	18 f0       	brcs	.+6      	; 0x2544 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    253e:	81 e0       	ldi	r24, 0x01	; 1
    2540:	89 83       	std	Y+1, r24	; 0x01
    2542:	01 c0       	rjmp	.+2      	; 0x2546 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    2544:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2546:	89 81       	ldd	r24, Y+1	; 0x01
}
    2548:	0f 90       	pop	r0
    254a:	0f 90       	pop	r0
    254c:	0f 90       	pop	r0
    254e:	0f 90       	pop	r0
    2550:	0f 90       	pop	r0
    2552:	cf 91       	pop	r28
    2554:	df 91       	pop	r29
    2556:	08 95       	ret

00002558 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2558:	df 93       	push	r29
    255a:	cf 93       	push	r28
    255c:	00 d0       	rcall	.+0      	; 0x255e <vTaskSetTimeOutState+0x6>
    255e:	cd b7       	in	r28, 0x3d	; 61
    2560:	de b7       	in	r29, 0x3e	; 62
    2562:	9a 83       	std	Y+2, r25	; 0x02
    2564:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2566:	80 91 20 03 	lds	r24, 0x0320
    256a:	e9 81       	ldd	r30, Y+1	; 0x01
    256c:	fa 81       	ldd	r31, Y+2	; 0x02
    256e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2570:	80 91 18 03 	lds	r24, 0x0318
    2574:	90 91 19 03 	lds	r25, 0x0319
    2578:	e9 81       	ldd	r30, Y+1	; 0x01
    257a:	fa 81       	ldd	r31, Y+2	; 0x02
    257c:	92 83       	std	Z+2, r25	; 0x02
    257e:	81 83       	std	Z+1, r24	; 0x01
}
    2580:	0f 90       	pop	r0
    2582:	0f 90       	pop	r0
    2584:	cf 91       	pop	r28
    2586:	df 91       	pop	r29
    2588:	08 95       	ret

0000258a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    258a:	df 93       	push	r29
    258c:	cf 93       	push	r28
    258e:	00 d0       	rcall	.+0      	; 0x2590 <xTaskCheckForTimeOut+0x6>
    2590:	00 d0       	rcall	.+0      	; 0x2592 <xTaskCheckForTimeOut+0x8>
    2592:	0f 92       	push	r0
    2594:	cd b7       	in	r28, 0x3d	; 61
    2596:	de b7       	in	r29, 0x3e	; 62
    2598:	9b 83       	std	Y+3, r25	; 0x03
    259a:	8a 83       	std	Y+2, r24	; 0x02
    259c:	7d 83       	std	Y+5, r23	; 0x05
    259e:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    25a0:	0f b6       	in	r0, 0x3f	; 63
    25a2:	f8 94       	cli
    25a4:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    25a6:	ea 81       	ldd	r30, Y+2	; 0x02
    25a8:	fb 81       	ldd	r31, Y+3	; 0x03
    25aa:	90 81       	ld	r25, Z
    25ac:	80 91 20 03 	lds	r24, 0x0320
    25b0:	98 17       	cp	r25, r24
    25b2:	71 f0       	breq	.+28     	; 0x25d0 <xTaskCheckForTimeOut+0x46>
    25b4:	ea 81       	ldd	r30, Y+2	; 0x02
    25b6:	fb 81       	ldd	r31, Y+3	; 0x03
    25b8:	21 81       	ldd	r18, Z+1	; 0x01
    25ba:	32 81       	ldd	r19, Z+2	; 0x02
    25bc:	80 91 18 03 	lds	r24, 0x0318
    25c0:	90 91 19 03 	lds	r25, 0x0319
    25c4:	82 17       	cp	r24, r18
    25c6:	93 07       	cpc	r25, r19
    25c8:	18 f0       	brcs	.+6      	; 0x25d0 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    25ca:	81 e0       	ldi	r24, 0x01	; 1
    25cc:	89 83       	std	Y+1, r24	; 0x01
    25ce:	2f c0       	rjmp	.+94     	; 0x262e <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    25d0:	20 91 18 03 	lds	r18, 0x0318
    25d4:	30 91 19 03 	lds	r19, 0x0319
    25d8:	ea 81       	ldd	r30, Y+2	; 0x02
    25da:	fb 81       	ldd	r31, Y+3	; 0x03
    25dc:	81 81       	ldd	r24, Z+1	; 0x01
    25de:	92 81       	ldd	r25, Z+2	; 0x02
    25e0:	28 1b       	sub	r18, r24
    25e2:	39 0b       	sbc	r19, r25
    25e4:	ec 81       	ldd	r30, Y+4	; 0x04
    25e6:	fd 81       	ldd	r31, Y+5	; 0x05
    25e8:	80 81       	ld	r24, Z
    25ea:	91 81       	ldd	r25, Z+1	; 0x01
    25ec:	28 17       	cp	r18, r24
    25ee:	39 07       	cpc	r19, r25
    25f0:	e0 f4       	brcc	.+56     	; 0x262a <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    25f2:	ec 81       	ldd	r30, Y+4	; 0x04
    25f4:	fd 81       	ldd	r31, Y+5	; 0x05
    25f6:	40 81       	ld	r20, Z
    25f8:	51 81       	ldd	r21, Z+1	; 0x01
    25fa:	ea 81       	ldd	r30, Y+2	; 0x02
    25fc:	fb 81       	ldd	r31, Y+3	; 0x03
    25fe:	21 81       	ldd	r18, Z+1	; 0x01
    2600:	32 81       	ldd	r19, Z+2	; 0x02
    2602:	80 91 18 03 	lds	r24, 0x0318
    2606:	90 91 19 03 	lds	r25, 0x0319
    260a:	b9 01       	movw	r22, r18
    260c:	68 1b       	sub	r22, r24
    260e:	79 0b       	sbc	r23, r25
    2610:	cb 01       	movw	r24, r22
    2612:	84 0f       	add	r24, r20
    2614:	95 1f       	adc	r25, r21
    2616:	ec 81       	ldd	r30, Y+4	; 0x04
    2618:	fd 81       	ldd	r31, Y+5	; 0x05
    261a:	91 83       	std	Z+1, r25	; 0x01
    261c:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    261e:	8a 81       	ldd	r24, Y+2	; 0x02
    2620:	9b 81       	ldd	r25, Y+3	; 0x03
    2622:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2626:	19 82       	std	Y+1, r1	; 0x01
    2628:	02 c0       	rjmp	.+4      	; 0x262e <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    262a:	81 e0       	ldi	r24, 0x01	; 1
    262c:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    262e:	0f 90       	pop	r0
    2630:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2632:	89 81       	ldd	r24, Y+1	; 0x01
}
    2634:	0f 90       	pop	r0
    2636:	0f 90       	pop	r0
    2638:	0f 90       	pop	r0
    263a:	0f 90       	pop	r0
    263c:	0f 90       	pop	r0
    263e:	cf 91       	pop	r28
    2640:	df 91       	pop	r29
    2642:	08 95       	ret

00002644 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2644:	df 93       	push	r29
    2646:	cf 93       	push	r28
    2648:	cd b7       	in	r28, 0x3d	; 61
    264a:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    264c:	81 e0       	ldi	r24, 0x01	; 1
    264e:	80 93 1f 03 	sts	0x031F, r24
}
    2652:	cf 91       	pop	r28
    2654:	df 91       	pop	r29
    2656:	08 95       	ret

00002658 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2658:	df 93       	push	r29
    265a:	cf 93       	push	r28
    265c:	00 d0       	rcall	.+0      	; 0x265e <prvIdleTask+0x6>
    265e:	cd b7       	in	r28, 0x3d	; 61
    2660:	de b7       	in	r29, 0x3e	; 62
    2662:	9a 83       	std	Y+2, r25	; 0x02
    2664:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    2666:	0e 94 ca 13 	call	0x2794	; 0x2794 <prvCheckTasksWaitingTermination>
    266a:	fd cf       	rjmp	.-6      	; 0x2666 <prvIdleTask+0xe>

0000266c <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    266c:	0f 93       	push	r16
    266e:	1f 93       	push	r17
    2670:	df 93       	push	r29
    2672:	cf 93       	push	r28
    2674:	cd b7       	in	r28, 0x3d	; 61
    2676:	de b7       	in	r29, 0x3e	; 62
    2678:	29 97       	sbiw	r28, 0x09	; 9
    267a:	0f b6       	in	r0, 0x3f	; 63
    267c:	f8 94       	cli
    267e:	de bf       	out	0x3e, r29	; 62
    2680:	0f be       	out	0x3f, r0	; 63
    2682:	cd bf       	out	0x3d, r28	; 61
    2684:	9a 83       	std	Y+2, r25	; 0x02
    2686:	89 83       	std	Y+1, r24	; 0x01
    2688:	7c 83       	std	Y+4, r23	; 0x04
    268a:	6b 83       	std	Y+3, r22	; 0x03
    268c:	4d 83       	std	Y+5, r20	; 0x05
    268e:	3f 83       	std	Y+7, r19	; 0x07
    2690:	2e 83       	std	Y+6, r18	; 0x06
    2692:	19 87       	std	Y+9, r17	; 0x09
    2694:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2696:	89 81       	ldd	r24, Y+1	; 0x01
    2698:	9a 81       	ldd	r25, Y+2	; 0x02
    269a:	49 96       	adiw	r24, 0x19	; 25
    269c:	2b 81       	ldd	r18, Y+3	; 0x03
    269e:	3c 81       	ldd	r19, Y+4	; 0x04
    26a0:	b9 01       	movw	r22, r18
    26a2:	48 e0       	ldi	r20, 0x08	; 8
    26a4:	50 e0       	ldi	r21, 0x00	; 0
    26a6:	0e 94 c7 14 	call	0x298e	; 0x298e <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    26aa:	e9 81       	ldd	r30, Y+1	; 0x01
    26ac:	fa 81       	ldd	r31, Y+2	; 0x02
    26ae:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    26b0:	8d 81       	ldd	r24, Y+5	; 0x05
    26b2:	85 30       	cpi	r24, 0x05	; 5
    26b4:	10 f0       	brcs	.+4      	; 0x26ba <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    26b6:	84 e0       	ldi	r24, 0x04	; 4
    26b8:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    26ba:	e9 81       	ldd	r30, Y+1	; 0x01
    26bc:	fa 81       	ldd	r31, Y+2	; 0x02
    26be:	8d 81       	ldd	r24, Y+5	; 0x05
    26c0:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    26c2:	89 81       	ldd	r24, Y+1	; 0x01
    26c4:	9a 81       	ldd	r25, Y+2	; 0x02
    26c6:	02 96       	adiw	r24, 0x02	; 2
    26c8:	0e 94 89 04 	call	0x912	; 0x912 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    26cc:	89 81       	ldd	r24, Y+1	; 0x01
    26ce:	9a 81       	ldd	r25, Y+2	; 0x02
    26d0:	0c 96       	adiw	r24, 0x0c	; 12
    26d2:	0e 94 89 04 	call	0x912	; 0x912 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    26d6:	e9 81       	ldd	r30, Y+1	; 0x01
    26d8:	fa 81       	ldd	r31, Y+2	; 0x02
    26da:	89 81       	ldd	r24, Y+1	; 0x01
    26dc:	9a 81       	ldd	r25, Y+2	; 0x02
    26de:	91 87       	std	Z+9, r25	; 0x09
    26e0:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    26e2:	8d 81       	ldd	r24, Y+5	; 0x05
    26e4:	28 2f       	mov	r18, r24
    26e6:	30 e0       	ldi	r19, 0x00	; 0
    26e8:	85 e0       	ldi	r24, 0x05	; 5
    26ea:	90 e0       	ldi	r25, 0x00	; 0
    26ec:	82 1b       	sub	r24, r18
    26ee:	93 0b       	sbc	r25, r19
    26f0:	e9 81       	ldd	r30, Y+1	; 0x01
    26f2:	fa 81       	ldd	r31, Y+2	; 0x02
    26f4:	95 87       	std	Z+13, r25	; 0x0d
    26f6:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    26f8:	e9 81       	ldd	r30, Y+1	; 0x01
    26fa:	fa 81       	ldd	r31, Y+2	; 0x02
    26fc:	89 81       	ldd	r24, Y+1	; 0x01
    26fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2700:	93 8b       	std	Z+19, r25	; 0x13
    2702:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    2704:	29 96       	adiw	r28, 0x09	; 9
    2706:	0f b6       	in	r0, 0x3f	; 63
    2708:	f8 94       	cli
    270a:	de bf       	out	0x3e, r29	; 62
    270c:	0f be       	out	0x3f, r0	; 63
    270e:	cd bf       	out	0x3d, r28	; 61
    2710:	cf 91       	pop	r28
    2712:	df 91       	pop	r29
    2714:	1f 91       	pop	r17
    2716:	0f 91       	pop	r16
    2718:	08 95       	ret

0000271a <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    271a:	df 93       	push	r29
    271c:	cf 93       	push	r28
    271e:	0f 92       	push	r0
    2720:	cd b7       	in	r28, 0x3d	; 61
    2722:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2724:	19 82       	std	Y+1, r1	; 0x01
    2726:	13 c0       	rjmp	.+38     	; 0x274e <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2728:	89 81       	ldd	r24, Y+1	; 0x01
    272a:	28 2f       	mov	r18, r24
    272c:	30 e0       	ldi	r19, 0x00	; 0
    272e:	c9 01       	movw	r24, r18
    2730:	88 0f       	add	r24, r24
    2732:	99 1f       	adc	r25, r25
    2734:	88 0f       	add	r24, r24
    2736:	99 1f       	adc	r25, r25
    2738:	88 0f       	add	r24, r24
    273a:	99 1f       	adc	r25, r25
    273c:	82 0f       	add	r24, r18
    273e:	93 1f       	adc	r25, r19
    2740:	8e 5d       	subi	r24, 0xDE	; 222
    2742:	9c 4f       	sbci	r25, 0xFC	; 252
    2744:	0e 94 5f 04 	call	0x8be	; 0x8be <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2748:	89 81       	ldd	r24, Y+1	; 0x01
    274a:	8f 5f       	subi	r24, 0xFF	; 255
    274c:	89 83       	std	Y+1, r24	; 0x01
    274e:	89 81       	ldd	r24, Y+1	; 0x01
    2750:	85 30       	cpi	r24, 0x05	; 5
    2752:	50 f3       	brcs	.-44     	; 0x2728 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2754:	8f e4       	ldi	r24, 0x4F	; 79
    2756:	93 e0       	ldi	r25, 0x03	; 3
    2758:	0e 94 5f 04 	call	0x8be	; 0x8be <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    275c:	88 e5       	ldi	r24, 0x58	; 88
    275e:	93 e0       	ldi	r25, 0x03	; 3
    2760:	0e 94 5f 04 	call	0x8be	; 0x8be <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2764:	85 e6       	ldi	r24, 0x65	; 101
    2766:	93 e0       	ldi	r25, 0x03	; 3
    2768:	0e 94 5f 04 	call	0x8be	; 0x8be <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    276c:	8e e6       	ldi	r24, 0x6E	; 110
    276e:	93 e0       	ldi	r25, 0x03	; 3
    2770:	0e 94 5f 04 	call	0x8be	; 0x8be <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2774:	8f e4       	ldi	r24, 0x4F	; 79
    2776:	93 e0       	ldi	r25, 0x03	; 3
    2778:	90 93 62 03 	sts	0x0362, r25
    277c:	80 93 61 03 	sts	0x0361, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2780:	88 e5       	ldi	r24, 0x58	; 88
    2782:	93 e0       	ldi	r25, 0x03	; 3
    2784:	90 93 64 03 	sts	0x0364, r25
    2788:	80 93 63 03 	sts	0x0363, r24
}
    278c:	0f 90       	pop	r0
    278e:	cf 91       	pop	r28
    2790:	df 91       	pop	r29
    2792:	08 95       	ret

00002794 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2794:	df 93       	push	r29
    2796:	cf 93       	push	r28
    2798:	00 d0       	rcall	.+0      	; 0x279a <prvCheckTasksWaitingTermination+0x6>
    279a:	0f 92       	push	r0
    279c:	cd b7       	in	r28, 0x3d	; 61
    279e:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    27a0:	80 91 16 03 	lds	r24, 0x0316
    27a4:	88 23       	and	r24, r24
    27a6:	71 f1       	breq	.+92     	; 0x2804 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    27a8:	0e 94 08 10 	call	0x2010	; 0x2010 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    27ac:	80 91 6e 03 	lds	r24, 0x036E
    27b0:	1b 82       	std	Y+3, r1	; 0x03
    27b2:	88 23       	and	r24, r24
    27b4:	11 f4       	brne	.+4      	; 0x27ba <prvCheckTasksWaitingTermination+0x26>
    27b6:	81 e0       	ldi	r24, 0x01	; 1
    27b8:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    27ba:	0e 94 14 10 	call	0x2028	; 0x2028 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    27be:	8b 81       	ldd	r24, Y+3	; 0x03
    27c0:	88 23       	and	r24, r24
    27c2:	01 f5       	brne	.+64     	; 0x2804 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    27c4:	0f b6       	in	r0, 0x3f	; 63
    27c6:	f8 94       	cli
    27c8:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    27ca:	e0 91 73 03 	lds	r30, 0x0373
    27ce:	f0 91 74 03 	lds	r31, 0x0374
    27d2:	86 81       	ldd	r24, Z+6	; 0x06
    27d4:	97 81       	ldd	r25, Z+7	; 0x07
    27d6:	9a 83       	std	Y+2, r25	; 0x02
    27d8:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    27da:	89 81       	ldd	r24, Y+1	; 0x01
    27dc:	9a 81       	ldd	r25, Y+2	; 0x02
    27de:	02 96       	adiw	r24, 0x02	; 2
    27e0:	0e 94 51 05 	call	0xaa2	; 0xaa2 <vListRemove>
					--uxCurrentNumberOfTasks;
    27e4:	80 91 17 03 	lds	r24, 0x0317
    27e8:	81 50       	subi	r24, 0x01	; 1
    27ea:	80 93 17 03 	sts	0x0317, r24
					--uxTasksDeleted;
    27ee:	80 91 16 03 	lds	r24, 0x0316
    27f2:	81 50       	subi	r24, 0x01	; 1
    27f4:	80 93 16 03 	sts	0x0316, r24
				}
				taskEXIT_CRITICAL();
    27f8:	0f 90       	pop	r0
    27fa:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    27fc:	89 81       	ldd	r24, Y+1	; 0x01
    27fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2800:	0e 94 a1 14 	call	0x2942	; 0x2942 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    2804:	0f 90       	pop	r0
    2806:	0f 90       	pop	r0
    2808:	0f 90       	pop	r0
    280a:	cf 91       	pop	r28
    280c:	df 91       	pop	r29
    280e:	08 95       	ret

00002810 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    2810:	df 93       	push	r29
    2812:	cf 93       	push	r28
    2814:	00 d0       	rcall	.+0      	; 0x2816 <prvAddCurrentTaskToDelayedList+0x6>
    2816:	cd b7       	in	r28, 0x3d	; 61
    2818:	de b7       	in	r29, 0x3e	; 62
    281a:	9a 83       	std	Y+2, r25	; 0x02
    281c:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    281e:	e0 91 14 03 	lds	r30, 0x0314
    2822:	f0 91 15 03 	lds	r31, 0x0315
    2826:	89 81       	ldd	r24, Y+1	; 0x01
    2828:	9a 81       	ldd	r25, Y+2	; 0x02
    282a:	93 83       	std	Z+3, r25	; 0x03
    282c:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    282e:	20 91 18 03 	lds	r18, 0x0318
    2832:	30 91 19 03 	lds	r19, 0x0319
    2836:	89 81       	ldd	r24, Y+1	; 0x01
    2838:	9a 81       	ldd	r25, Y+2	; 0x02
    283a:	82 17       	cp	r24, r18
    283c:	93 07       	cpc	r25, r19
    283e:	70 f4       	brcc	.+28     	; 0x285c <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2840:	80 91 63 03 	lds	r24, 0x0363
    2844:	90 91 64 03 	lds	r25, 0x0364
    2848:	20 91 14 03 	lds	r18, 0x0314
    284c:	30 91 15 03 	lds	r19, 0x0315
    2850:	2e 5f       	subi	r18, 0xFE	; 254
    2852:	3f 4f       	sbci	r19, 0xFF	; 255
    2854:	b9 01       	movw	r22, r18
    2856:	0e 94 e5 04 	call	0x9ca	; 0x9ca <vListInsert>
    285a:	1e c0       	rjmp	.+60     	; 0x2898 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    285c:	40 91 61 03 	lds	r20, 0x0361
    2860:	50 91 62 03 	lds	r21, 0x0362
    2864:	80 91 14 03 	lds	r24, 0x0314
    2868:	90 91 15 03 	lds	r25, 0x0315
    286c:	9c 01       	movw	r18, r24
    286e:	2e 5f       	subi	r18, 0xFE	; 254
    2870:	3f 4f       	sbci	r19, 0xFF	; 255
    2872:	ca 01       	movw	r24, r20
    2874:	b9 01       	movw	r22, r18
    2876:	0e 94 e5 04 	call	0x9ca	; 0x9ca <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    287a:	20 91 78 00 	lds	r18, 0x0078
    287e:	30 91 79 00 	lds	r19, 0x0079
    2882:	89 81       	ldd	r24, Y+1	; 0x01
    2884:	9a 81       	ldd	r25, Y+2	; 0x02
    2886:	82 17       	cp	r24, r18
    2888:	93 07       	cpc	r25, r19
    288a:	30 f4       	brcc	.+12     	; 0x2898 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    288c:	89 81       	ldd	r24, Y+1	; 0x01
    288e:	9a 81       	ldd	r25, Y+2	; 0x02
    2890:	90 93 79 00 	sts	0x0079, r25
    2894:	80 93 78 00 	sts	0x0078, r24
		}
	}
}
    2898:	0f 90       	pop	r0
    289a:	0f 90       	pop	r0
    289c:	cf 91       	pop	r28
    289e:	df 91       	pop	r29
    28a0:	08 95       	ret

000028a2 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    28a2:	df 93       	push	r29
    28a4:	cf 93       	push	r28
    28a6:	cd b7       	in	r28, 0x3d	; 61
    28a8:	de b7       	in	r29, 0x3e	; 62
    28aa:	28 97       	sbiw	r28, 0x08	; 8
    28ac:	0f b6       	in	r0, 0x3f	; 63
    28ae:	f8 94       	cli
    28b0:	de bf       	out	0x3e, r29	; 62
    28b2:	0f be       	out	0x3f, r0	; 63
    28b4:	cd bf       	out	0x3d, r28	; 61
    28b6:	9c 83       	std	Y+4, r25	; 0x04
    28b8:	8b 83       	std	Y+3, r24	; 0x03
    28ba:	7e 83       	std	Y+6, r23	; 0x06
    28bc:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    28be:	81 e2       	ldi	r24, 0x21	; 33
    28c0:	90 e0       	ldi	r25, 0x00	; 0
    28c2:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <pvPortMalloc>
    28c6:	9a 83       	std	Y+2, r25	; 0x02
    28c8:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    28ca:	89 81       	ldd	r24, Y+1	; 0x01
    28cc:	9a 81       	ldd	r25, Y+2	; 0x02
    28ce:	00 97       	sbiw	r24, 0x00	; 0
    28d0:	69 f1       	breq	.+90     	; 0x292c <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    28d2:	8d 81       	ldd	r24, Y+5	; 0x05
    28d4:	9e 81       	ldd	r25, Y+6	; 0x06
    28d6:	00 97       	sbiw	r24, 0x00	; 0
    28d8:	39 f4       	brne	.+14     	; 0x28e8 <prvAllocateTCBAndStack+0x46>
    28da:	8b 81       	ldd	r24, Y+3	; 0x03
    28dc:	9c 81       	ldd	r25, Y+4	; 0x04
    28de:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <pvPortMalloc>
    28e2:	98 87       	std	Y+8, r25	; 0x08
    28e4:	8f 83       	std	Y+7, r24	; 0x07
    28e6:	04 c0       	rjmp	.+8      	; 0x28f0 <prvAllocateTCBAndStack+0x4e>
    28e8:	8d 81       	ldd	r24, Y+5	; 0x05
    28ea:	9e 81       	ldd	r25, Y+6	; 0x06
    28ec:	98 87       	std	Y+8, r25	; 0x08
    28ee:	8f 83       	std	Y+7, r24	; 0x07
    28f0:	e9 81       	ldd	r30, Y+1	; 0x01
    28f2:	fa 81       	ldd	r31, Y+2	; 0x02
    28f4:	8f 81       	ldd	r24, Y+7	; 0x07
    28f6:	98 85       	ldd	r25, Y+8	; 0x08
    28f8:	90 8f       	std	Z+24, r25	; 0x18
    28fa:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    28fc:	e9 81       	ldd	r30, Y+1	; 0x01
    28fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2900:	87 89       	ldd	r24, Z+23	; 0x17
    2902:	90 8d       	ldd	r25, Z+24	; 0x18
    2904:	00 97       	sbiw	r24, 0x00	; 0
    2906:	39 f4       	brne	.+14     	; 0x2916 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2908:	89 81       	ldd	r24, Y+1	; 0x01
    290a:	9a 81       	ldd	r25, Y+2	; 0x02
    290c:	0e 94 39 04 	call	0x872	; 0x872 <vPortFree>
			pxNewTCB = NULL;
    2910:	1a 82       	std	Y+2, r1	; 0x02
    2912:	19 82       	std	Y+1, r1	; 0x01
    2914:	0b c0       	rjmp	.+22     	; 0x292c <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    2916:	e9 81       	ldd	r30, Y+1	; 0x01
    2918:	fa 81       	ldd	r31, Y+2	; 0x02
    291a:	87 89       	ldd	r24, Z+23	; 0x17
    291c:	90 8d       	ldd	r25, Z+24	; 0x18
    291e:	2b 81       	ldd	r18, Y+3	; 0x03
    2920:	3c 81       	ldd	r19, Y+4	; 0x04
    2922:	65 ea       	ldi	r22, 0xA5	; 165
    2924:	70 e0       	ldi	r23, 0x00	; 0
    2926:	a9 01       	movw	r20, r18
    2928:	0e 94 c0 14 	call	0x2980	; 0x2980 <memset>
		}
	}

	return pxNewTCB;
    292c:	89 81       	ldd	r24, Y+1	; 0x01
    292e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2930:	28 96       	adiw	r28, 0x08	; 8
    2932:	0f b6       	in	r0, 0x3f	; 63
    2934:	f8 94       	cli
    2936:	de bf       	out	0x3e, r29	; 62
    2938:	0f be       	out	0x3f, r0	; 63
    293a:	cd bf       	out	0x3d, r28	; 61
    293c:	cf 91       	pop	r28
    293e:	df 91       	pop	r29
    2940:	08 95       	ret

00002942 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    2942:	df 93       	push	r29
    2944:	cf 93       	push	r28
    2946:	00 d0       	rcall	.+0      	; 0x2948 <prvDeleteTCB+0x6>
    2948:	cd b7       	in	r28, 0x3d	; 61
    294a:	de b7       	in	r29, 0x3e	; 62
    294c:	9a 83       	std	Y+2, r25	; 0x02
    294e:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2950:	e9 81       	ldd	r30, Y+1	; 0x01
    2952:	fa 81       	ldd	r31, Y+2	; 0x02
    2954:	87 89       	ldd	r24, Z+23	; 0x17
    2956:	90 8d       	ldd	r25, Z+24	; 0x18
    2958:	0e 94 39 04 	call	0x872	; 0x872 <vPortFree>
		vPortFree( pxTCB );
    295c:	89 81       	ldd	r24, Y+1	; 0x01
    295e:	9a 81       	ldd	r25, Y+2	; 0x02
    2960:	0e 94 39 04 	call	0x872	; 0x872 <vPortFree>
	}
    2964:	0f 90       	pop	r0
    2966:	0f 90       	pop	r0
    2968:	cf 91       	pop	r28
    296a:	df 91       	pop	r29
    296c:	08 95       	ret

0000296e <memcpy>:
    296e:	fb 01       	movw	r30, r22
    2970:	dc 01       	movw	r26, r24
    2972:	02 c0       	rjmp	.+4      	; 0x2978 <memcpy+0xa>
    2974:	01 90       	ld	r0, Z+
    2976:	0d 92       	st	X+, r0
    2978:	41 50       	subi	r20, 0x01	; 1
    297a:	50 40       	sbci	r21, 0x00	; 0
    297c:	d8 f7       	brcc	.-10     	; 0x2974 <memcpy+0x6>
    297e:	08 95       	ret

00002980 <memset>:
    2980:	dc 01       	movw	r26, r24
    2982:	01 c0       	rjmp	.+2      	; 0x2986 <memset+0x6>
    2984:	6d 93       	st	X+, r22
    2986:	41 50       	subi	r20, 0x01	; 1
    2988:	50 40       	sbci	r21, 0x00	; 0
    298a:	e0 f7       	brcc	.-8      	; 0x2984 <memset+0x4>
    298c:	08 95       	ret

0000298e <strncpy>:
    298e:	fb 01       	movw	r30, r22
    2990:	dc 01       	movw	r26, r24
    2992:	41 50       	subi	r20, 0x01	; 1
    2994:	50 40       	sbci	r21, 0x00	; 0
    2996:	48 f0       	brcs	.+18     	; 0x29aa <strncpy+0x1c>
    2998:	01 90       	ld	r0, Z+
    299a:	0d 92       	st	X+, r0
    299c:	00 20       	and	r0, r0
    299e:	c9 f7       	brne	.-14     	; 0x2992 <strncpy+0x4>
    29a0:	01 c0       	rjmp	.+2      	; 0x29a4 <strncpy+0x16>
    29a2:	1d 92       	st	X+, r1
    29a4:	41 50       	subi	r20, 0x01	; 1
    29a6:	50 40       	sbci	r21, 0x00	; 0
    29a8:	e0 f7       	brcc	.-8      	; 0x29a2 <strncpy+0x14>
    29aa:	08 95       	ret

000029ac <_exit>:
    29ac:	f8 94       	cli

000029ae <__stop_program>:
    29ae:	ff cf       	rjmp	.-2      	; 0x29ae <__stop_program>
